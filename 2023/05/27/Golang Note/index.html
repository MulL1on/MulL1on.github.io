<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>goland note | 梁伟健的博客</title><meta name="author" content="GDshenqingNo1"><meta name="copyright" content="GDshenqingNo1"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Golang Note Fundamental前面写的没啥用的东西json1.json.Unmarshal 只能传指针 2.struct内的字段名要大写才能被json访问，如果要求转化为json后字段名为小写可以在字段明后加上 json:小写 map1.map必须初始化才能使用 hash函数是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种">
<meta property="og:type" content="article">
<meta property="og:title" content="goland note">
<meta property="og:url" content="http://example.com/2023/05/27/Golang%20Note/index.html">
<meta property="og:site_name" content="梁伟健的博客">
<meta property="og:description" content="Golang Note Fundamental前面写的没啥用的东西json1.json.Unmarshal 只能传指针 2.struct内的字段名要大写才能被json访问，如果要求转化为json后字段名为小写可以在字段明后加上 json:小写 map1.map必须初始化才能使用 hash函数是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/lucy.jpg">
<meta property="article:published_time" content="2023-05-27T10:32:12.127Z">
<meta property="article:modified_time" content="2023-05-27T10:31:14.915Z">
<meta property="article:author" content="GDshenqingNo1">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/lucy.jpg"><link rel="shortcut icon" href="/img/gundam.png"><link rel="canonical" href="http://example.com/2023/05/27/Golang%20Note/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'goland note',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-27 18:31:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/lucy.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">梁伟健的博客</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">goland note</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-27T10:32:12.127Z" title="发表于 2023-05-27 18:32:12">2023-05-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-27T10:31:14.915Z" title="更新于 2023-05-27 18:31:14">2023-05-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="goland note"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Golang-Note-Fundamental"><a href="#Golang-Note-Fundamental" class="headerlink" title="Golang Note Fundamental"></a>Golang Note Fundamental</h1><h2 id="前面写的没啥用的东西"><a href="#前面写的没啥用的东西" class="headerlink" title="前面写的没啥用的东西"></a>前面写的没啥用的东西</h2><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><p>1.json.Unmarshal 只能传指针</p>
<p>2.struct内的字段名要大写才能被json访问，如果要求转化为json后字段名为小写可以在字段明后加上</p>
<p><code>json:小写</code></p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>1.map必须初始化才能使用</p>
<h3 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h3><p>是把任意长度的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BE%93%E5%85%A5/5481954?fromModule=lemma_inlink">输入</a>（又叫做预映射pre-image）通过散列算法变换成固定长度的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BE%93%E5%87%BA/11056752?fromModule=lemma_inlink">输出</a>，该输出就是散列值。这种转换是一种<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%8B%E7%BC%A9%E6%98%A0%E5%B0%84/5114126?fromModule=lemma_inlink">压缩映射</a>，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。</p>
<p>简单的说就是一种将任意长度的消息压缩到某一固定长度的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81/4547744?fromModule=lemma_inlink">消息摘要</a>的函数。</p>
<h4 id="HMAC-Hash-based-Message-Authentication-Code"><a href="#HMAC-Hash-based-Message-Authentication-Code" class="headerlink" title="HMAC(Hash-based Message Authentication Code)"></a>HMAC(Hash-based Message Authentication Code)</h4><p>①消息完整性认证：能够证明消息内容在传送过程没有被修改。</p>
<p>②信源身份认证：因为通信双方共享了认证的密钥，接收方能够认证发送该数据的信源与所宣称的一致，即能够可靠地确认接收的消息与发送的一致。</p>
<p>HMAC运算利用hash算法，以一个消息M和一个密钥K作为输入，生成一个定长的消息摘要作为输出。HMAC算法利用已有的Hash函数，关键问题是如何使用密钥。</p>
<h3 id="JWT（-Json-web-token）"><a href="#JWT（-Json-web-token）" class="headerlink" title="JWT（ Json web token）"></a>JWT（ Json web token）</h3><ul>
<li>用户使用用户名密码来请求服务器</li>
<li>服务器进行验证用户的信息</li>
<li>服务器通过验证发送给用户一个token</li>
<li>客户端存储token，并在每次请求时附送上这个token值</li>
<li>服务端验证token值，并返回数据</li>
</ul>
<p>在gin框架下使用JWT</p>
<p>1.定义一个用于签名的字符串</p>
<p>2.创建一个claim （自定义Claim或者默认Claim)</p>
<p>3.生成token</p>
<p>4.客户端发送携带token的请求</p>
<p>5.解析token，获取token中的claim</p>
<p>6.将claim想要的信息保存在c上下文中，后续函数可以通过c.Get()获取这个信息，实现身份验证。</p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>Gin框架允许开发者在处理请求的过程中 ，加入用户自己的逻辑函数，这个逻辑函数就被成为中间键，中间间适合处理一些公共逻辑，比如登录认证、权限校验、记录日志、耗时统计等。</p>
<p>同时也可以通过<code>c.Next</code>和<code>c.Abort</code>决定是否请求走向下一个中间件</p>
<h2 id="Golang中蛋疼的三个点"><a href="#Golang中蛋疼的三个点" class="headerlink" title="Golang中蛋疼的三个点"></a>Golang中蛋疼的三个点</h2><p>”…“其实是golang的一种语法糖</p>
<h3 id="函数的不定参数"><a href="#函数的不定参数" class="headerlink" title="函数的不定参数"></a>函数的不定参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(args ...<span class="type">string</span>)</span></span>  &#123;  <span class="comment">//可以接收任意多个string参数，此时args是切片</span></span><br><span class="line">	<span class="keyword">for</span> index, value := <span class="keyword">range</span> args&#123;</span><br><span class="line">		fmt.Println(index, <span class="string">&quot; : &quot;</span>, value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := []<span class="type">string</span> &#123;</span><br><span class="line">		<span class="string">&quot;ABC&quot;</span>,</span><br><span class="line">		<span class="string">&quot;DEF&quot;</span>,</span><br><span class="line">		<span class="string">&quot;GHI&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	test1(str...)  <span class="comment">//切片被打散传入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="切片的打散"><a href="#切片的打散" class="headerlink" title="切片的打散"></a>切片的打散</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := []<span class="type">string</span> &#123;</span><br><span class="line">		<span class="string">&quot;ABC&quot;</span>,</span><br><span class="line">		<span class="string">&quot;DEF&quot;</span>,</span><br><span class="line">		<span class="string">&quot;GHI&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(str)</span><br><span class="line">	str = <span class="built_in">append</span>(str[<span class="number">0</span>:<span class="number">1</span>], str[<span class="number">2</span>:]...) <span class="comment">//将slice打散然后合并，否则需要传入元素而不能传入切片</span></span><br><span class="line">	fmt.Println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组自行推断数组的长度"><a href="#数组自行推断数组的长度" class="headerlink" title="数组自行推断数组的长度"></a>数组自行推断数组的长度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var numArray = [...]int&#123;1, 2&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Context上下文"><a href="#Context上下文" class="headerlink" title="Context上下文"></a>Context上下文</h2><h3 id="Context概念"><a href="#Context概念" class="headerlink" title="Context概念"></a>Context概念</h3><p>Go1.7加入了一个新的标准库<code>context</code>，它定义了<code>Context</code>类型，专门用来简化 对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。</p>
<p>对服务器传入的请求应该创建上下文，而对服务器的传出调用应该接受上下文。它们之间的函数调用链必须传递上下文，或者可以使用<code>WithCancel</code>、<code>WithDeadline</code>、<code>WithTimeout</code>或<code>WithValue</code>创建的派生上下文。当一个上下文被取消时，它派生的所有上下文也被取消。</p>
<p>&#x2F;&#x2F;context的功能也可以手搓（定义全局变量，channel等方法），<code>context</code>相当于官方提供的解决方案，建立的一种标准，方便程序员之间阅读。</p>
<h3 id="Context接口"><a href="#Context接口" class="headerlink" title="Context接口"></a>Context接口</h3><p><code>context.Context</code>是一个接口，该接口定义了四个需要实现的方法。具体签名如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.<code>Deadline</code>方法返回当前<code>Context</code>被取消的时间</p>
<p>2.<code>Done</code>方法返回一个<code>Channel</code>,这个<code>Channel</code>在当前工作完成或者上下文被取消后关闭，多次调用<code>Done</code>方法返回同一个<code>Channel</code></p>
<p>3.Err方法返回当前<code>Context</code>结束的原因，它只会在<code>Done</code>返回的<code>Channel</code>被关闭时才会返回非空的值</p>
<p>&#x2F;&#x2F;当前<code>Context</code>被取消就会返回<code>Canceled</code>错误；</p>
<p>&#x2F;&#x2F;当前<code>Context</code>超时就会返回<code>DeadlineExcceeded</code>错误；</p>
<p>4.<code>Value</code>方法会从<code>Context</code>中返回<code>Key</code>对应的值，对同一个上下文，多次调用<code>Value</code>并传入相同的</p>
<p><code>Key</code>会返回相同的结果，该方法仅用于传递跨API和进程间跟请求域的数据；</p>
<h3 id="Background-和TODO"><a href="#Background-和TODO" class="headerlink" title="Background()和TODO()"></a>Background()和TODO()</h3><p>两个函数分别返回一个实现了<code>Context</code>接口的<code>background</code>和<code>todo</code>。我们代码中最开始都是以这两个内置的上下文对象作为最顶层的<code>partent context</code>，衍生出更多的子上下文对象。</p>
<p><code>background</code>和<code>todo</code>本质上都是<code>emptyCtx</code>结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context。</p>
<h3 id="With系列函数"><a href="#With系列函数" class="headerlink" title="With系列函数"></a>With系列函数</h3><h4 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a>WithCancel</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)</span><br></pre></td></tr></table></figure>

<p><code>WithCancel</code>返回带有新<code>Done</code>通道的父节点的副本。当调用<code>cancel</code>方法或关闭父上下文的<code>Done</code>通道时，将关闭返回的上下文的<code>Done</code>通道。</p>
<p>调用<code>Cancel</code>方法会查找对应<code>context</code>的全部<code>Done</code>通道,并关闭从而实现关闭子Goroutine的功能。</p>
<h4 id="WithDeadline"><a href="#WithDeadline" class="headerlink" title="WithDeadline"></a>WithDeadline</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span></span> (Context, CancelFunc)</span><br></pre></td></tr></table></figure>

<p>返回父上下文的副本，并将deadline调整为不迟于d。如果父上下文的deadline已经早于d，则WithDeadline(parent, d)在语义上等同于父上下文。当截止日过期时，当调用返回的cancel函数时，或者当父上下文的Done通道关闭时，返回上下文的Done通道将被关闭，<strong>以最先发生的情况为准</strong>。</p>
<h4 id="WithTimeout"><a href="#WithTimeout" class="headerlink" title="WithTimeout"></a>WithTimeout</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br></pre></td></tr></table></figure>

<p>与<code>WithDeadline</code>类似，不同在于<code>WithTimeout</code>设置一段时间，而<code>WithDeaddline</code>设置一个时间点。</p>
<h4 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a>WithValue</h4><p><code>WithValue</code>函数能够将请求作用域的数据与 Context 对象建立关系。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context</span><br></pre></td></tr></table></figure>

<p>其中<code>key</code>不能是<code>string</code>或任何内置类型，以避免使用上下文在包之间发生冲突，要定义自己的类型。</p>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><h3 id="一般格式"><a href="#一般格式" class="headerlink" title="一般格式"></a>一般格式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x,err:=interfaceText.(T)</span><br></pre></td></tr></table></figure>

<p>如果转换合法，则<code>x</code>为<code>InterfaceText</code>转换为类型<code>T</code>值，<code>err</code>为<code>ture</code>，反之<code>err</code>为<code>false</code>。</p>
<h3 id="特殊用法"><a href="#特殊用法" class="headerlink" title="特殊用法"></a>特殊用法</h3><p>可以用于判断某个类型是否实现了某个接口。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ discovery.Resolver = (*consulResolver)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码中将一个<code>nil</code>指针转换成<code>*consulResolver</code>类型，并判断该类型是否实现了<code>discovery.Resolver</code>接口，如果实现了，则不会产生编译错误；如果没有实现，则会产生并编译错误。</p>
<p>在go语言中，我们经常需要判断某个类型是否实现了某个接口，可以通过这种方式进行静态检查，避免在运行时出现类型错误。</p>
<p>这种类型断言的写法，一般用于声明某个类型实现了某个接口，但是不需要使用该接口的任何方法。在这种情况下，我们使用一个空白标识符<code>_</code>来表示该接口，而不需要给它起一个变量名。</p>
<h3 id="type-switch"><a href="#type-switch" class="headerlink" title="type-switch"></a>type-switch</h3><p>和switch很相似,如果InterfaceText中有*Square,*Circle,nil三种类型，就会执行对应的代码，若都没有，便会执行default里的代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> InterfaceText.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> *Square:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;text:%v&quot;</span>,i)</span><br><span class="line">    <span class="keyword">case</span> *Circle:</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    <span class="comment">//..and so forth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="net-x2F-http"><a href="#net-x2F-http" class="headerlink" title="net&#x2F;http"></a>net&#x2F;http</h2><h4 id="net-x2F-http介绍"><a href="#net-x2F-http介绍" class="headerlink" title="net&#x2F;http介绍"></a>net&#x2F;http介绍</h4><p><code>net/http</code>是Go内置的包，提供HTTP客户端和服务端的实现。</p>
<h4 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h4><p>我们的浏览器其实就是一个发送和接收HTTP协议数据的客户端，我们平时通过浏览器访问网页其实就是从网站的服务器接收HTTP数据，然后浏览器会按照HTML、CSS等规则将网页渲染展示出来</p>
<h6 id="基本的http-x2F-https请求"><a href="#基本的http-x2F-https请求" class="headerlink" title="基本的http&#x2F;https请求"></a>基本的http&#x2F;https请求</h6><p>Get、Head、Post和PostForm函数发出HTTP&#x2F;HTTPS请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">&quot;http://example.com/&quot;</span>)</span><br><span class="line">...</span><br><span class="line">resp, err := http.Post(<span class="string">&quot;http://example.com/upload&quot;</span>, <span class="string">&quot;image/jpeg&quot;</span>, &amp;buf)</span><br><span class="line">...</span><br><span class="line">resp, err := http.PostForm(<span class="string">&quot;http://example.com/form&quot;</span>,</span><br><span class="line">	url.Values&#123;<span class="string">&quot;key&quot;</span>: &#123;<span class="string">&quot;Value&quot;</span>&#125;, <span class="string">&quot;id&quot;</span>: &#123;<span class="string">&quot;123&quot;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>程序在使用完response后必须关闭回复的<code>body</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">&quot;http://example.com/&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>



<h6 id="不带参数Get请求示例"><a href="#不带参数Get请求示例" class="headerlink" title="不带参数Get请求示例"></a>不带参数Get请求示例</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	resp, err := http.Get(<span class="string">&quot;https://www.liwenzhou.com/&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;get failed, err:%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;read from resp.Body failed, err:%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Print(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="带参数的GET请求示例"><a href="#带参数的GET请求示例" class="headerlink" title="带参数的GET请求示例"></a>带参数的GET请求示例</h6><p>要使用<code>net/url</code>这个包</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	apiUrl := <span class="string">&quot;http://127.0.0.1:9090/get&quot;</span></span><br><span class="line">	<span class="comment">// URL param</span></span><br><span class="line">	data := url.Values&#123;&#125;</span><br><span class="line">	data.Set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小王子&quot;</span>)</span><br><span class="line">	data.Set(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;18&quot;</span>)</span><br><span class="line">	u, err := url.ParseRequestURI(apiUrl)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;parse url requestUrl failed, err:%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	u.RawQuery = data.Encode() <span class="comment">// URL encode</span></span><br><span class="line">	fmt.Println(u.String())</span><br><span class="line">	resp, err := http.Get(u.String())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;post failed, err:%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	b, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;get resp failed, err:%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="type">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应Server端HandlerFunc：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> r.Body.Close()</span><br><span class="line">	data := r.URL.Query()</span><br><span class="line">	fmt.Println(data.Get(<span class="string">&quot;name&quot;</span>))</span><br><span class="line">	fmt.Println(data.Get(<span class="string">&quot;age&quot;</span>))</span><br><span class="line">	answer := <span class="string">`&#123;&quot;status&quot;: &quot;ok&quot;&#125;`</span></span><br><span class="line">	w.Write([]<span class="type">byte</span>(answer))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>URL类型代表一个解析后的URL（或者说，一个URL参照）。URL基本格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme://[userinfo@]host/path[?query][#fragment]</span><br></pre></td></tr></table></figure>

<h6 id="POST请求示例"><a href="#POST请求示例" class="headerlink" title="POST请求示例"></a>POST请求示例</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	apiUrl := <span class="string">&quot;http://127.0.0.1:9090/get&quot;</span></span><br><span class="line">	<span class="comment">// URL param</span></span><br><span class="line">	data := url.Values&#123;&#125;</span><br><span class="line">	data.Set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小王子&quot;</span>)</span><br><span class="line">	data.Set(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;18&quot;</span>)</span><br><span class="line">	u, err := url.ParseRequestURI(apiUrl)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;parse url requestUrl failed, err:%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	u.RawQuery = data.Encode() <span class="comment">// URL encode</span></span><br><span class="line">	fmt.Println(u.String())</span><br><span class="line">	resp, err := http.Get(u.String())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;post failed, err:%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	b, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;get resp failed, err:%v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="type">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;待完善&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p>
<h2 id="在Go中使用MySQL"><a href="#在Go中使用MySQL" class="headerlink" title="在Go中使用MySQL"></a>在Go中使用MySQL</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>Go语言中的<code>database/sql</code>包提供了保证SQL或类SQL数据库的泛用接口，并不提供具体的数据库驱动。使用<code>database/sql</code>包时必须注入（至少）一个数据库驱动。</p>
<h4 id="访问数据库"><a href="#访问数据库" class="headerlink" title="访问数据库"></a>访问数据库</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(driverName, dataSourceName <span class="type">string</span>)</span></span> (*DB, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;database/sql&quot;</span></span><br><span class="line"></span><br><span class="line">	_ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// DSN:Data Source Name</span></span><br><span class="line">	dsn := <span class="string">&quot;[用户名[:密码]@][协议[(地址:端口)]]/dbname[?param1=value1&amp;...&amp;paramN=valueN]&quot;</span></span><br><span class="line">	db, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, dsn)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> db.Close()  <span class="comment">// 注意这行代码要写在上面err判断的下面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化连接"><a href="#初始化连接" class="headerlink" title="初始化连接"></a>初始化连接</h4><p>Open函数可能只是验证其参数格式是否正确，实际上并不创建与数据库的连接。如果要检查数据源的名称是否真实有效，应该调用Ping方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">err = db.Ping()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个全局变量<code>db</code>保存数据库连接对象<code>var db *sql.DB</code></p>
<p>将上面的代码包装成一个<code>initDB</code>函数，只需在启动时调用一次函数完成全局变量<code>db</code>的初始化，其他函数就可以直接使用全局变量<code>db</code></p>
<h4 id="SetMaxOpenConns"><a href="#SetMaxOpenConns" class="headerlink" title="SetMaxOpenConns"></a><del>SetMaxOpenConns</del></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> SetMaxOpenConns(n <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>设置与数据库<strong>建立连接的最大数目</strong>。</p>
<p>如果n大于0且小于<strong>最大闲置连接数</strong>，会将<strong>最大闲置连接数</strong>减小到匹配<strong>最大开启连接数</strong>的限制。 如果n&lt;&#x3D;0，不会限制最大开启连接数，默认为0（无限制）。</p>
<h4 id="SetMaxIdleConns"><a href="#SetMaxIdleConns" class="headerlink" title="SetMaxIdleConns"></a><del>SetMaxIdleConns</del></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> SetMaxIdleConns(n <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>设置连接池中的<strong>最大闲置连接数</strong>。</p>
<p>如果n大于<strong>最大开启连接数</strong>，则新的<strong>最大闲置连接数</strong>会减小到匹配<strong>最大开启连接数</strong>的限制。 如果n&lt;&#x3D;0，不会保留闲置连接。</p>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p><strong>多行检索</strong></p>
<p><code>db.Query()</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">rows, err := db.Query(<span class="string">&quot;select * from stu where id= ?&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  延迟调用关闭rows释放持有的数据库链接</span></span><br><span class="line">    <span class="keyword">defer</span> rows.Close()</span><br><span class="line">    <span class="keyword">var</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">        name    <span class="type">string</span></span><br><span class="line">        id      <span class="type">int</span></span><br><span class="line">        math    <span class="type">int</span></span><br><span class="line">        english <span class="type">int</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  迭代查询获取数据</span></span><br><span class="line">    <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">        err := rows.Scan(&amp;user.id, &amp;user.name, &amp;user.math, &amp;user.english)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(user)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​	<strong>单行检索</strong>	</p>
<p><code>db.QueryRow()</code> QueryRow总是返回非nil的值，知道返回值的Scan方法被调用时，才会返回被延迟的错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">row := db.QueryRow(<span class="string">&quot;select * from stu where id=?&quot;</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">var</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">        name    <span class="type">string</span></span><br><span class="line">        id      <span class="type">int</span></span><br><span class="line">        math    <span class="type">int</span></span><br><span class="line">        english <span class="type">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    err = row.Scan(&amp;user.id, &amp;user.name, &amp;user.math, &amp;user.english)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(user)</span><br></pre></td></tr></table></figure>

<h3 id="增-x2F-改-x2F-删"><a href="#增-x2F-改-x2F-删" class="headerlink" title="增&#x2F;改&#x2F;删"></a>增&#x2F;改&#x2F;删</h3><p>GO中使用<code>Exec()</code>实现MySQL中的<code>insert</code> <code>update</code> <code>delete</code>操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Exec(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>​	arg表示占位符中的任何参数，Result是对已执行的SQL命令的总结。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result, err := db.Exec(<span class="string">&quot;insert into stu (name ,math ,english) value (?,?,?)&quot;</span>, <span class="string">&quot;小j&quot;</span>, <span class="number">100</span>, <span class="number">120</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新插入数据的id</span></span><br><span class="line">    result.LastInsertId()</span><br><span class="line">    <span class="comment">// 返回影响的行数</span></span><br><span class="line">    result.RowsAffected()</span><br></pre></td></tr></table></figure>

<p><strong>删除数据</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result, err := db.Exec(<span class="string">&quot;delete from stu where id=?&quot;</span>, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新插入数据的id</span></span><br><span class="line">    result.LastInsertId()</span><br><span class="line">    <span class="comment">// 返回影响的行数</span></span><br><span class="line">    result.RowsAffected()</span><br></pre></td></tr></table></figure>

<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>预处理是 MySQL 为了防止客户端频繁请求的一种技术，是对相同处理语句进行预先加载在 MySQL 中，将操作变量数据用占位符来代替，减少对 MySQL 的频繁请求，使得服务器高效运行。</p>
<p><code>Prepare</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Prepare(query <span class="type">string</span>) (*Stmt, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p><code>Prepare</code>方法会先将sql语句发送给MySQL服务端，返回一个准备好的状态<code>*Stmt</code>用于之后的查询和命令。返回值可以同时执行多个查询和命令。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stmt, err := db.Prepare(<span class="string">&quot;select * from stu where id= ?&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;prepare failed, err:%v\n&quot;</span>, err)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> stmt.Close()<span class="comment">//记得关闭状态连接</span></span><br></pre></td></tr></table></figure>

<p>此时查询写为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rows, err := stmt.Query(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>其他删除 更新 插入操作类似</p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p><strong><code>os.Create（）</code></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="type">string</span>)</span></span> (file *File, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>Create采用模式0666（任何人都可读写，不可执行）创建一个名为name的文件，如果文件已存在会截断它（为空文件）。如果成功，返回的文件对象可用于I&#x2F;O；对应的文件描述符具有O_RDWR模式。</p>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p><strong><code>os.Open()</code></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="type">string</span>)</span></span> (file *File, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>打开的文件只能用于读操作</p>
<p><strong><code>os.OpenFile()</code></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (file *File, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p><strong>flag表示指定的选项&#x2F;&#x2F;&#x2F;&#x2F;<em>&#x2F;异或操作</em></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    O_RDONLY <span class="type">int</span> = syscall.O_RDONLY <span class="comment">// 只读模式打开文件</span></span><br><span class="line">    O_WRONLY <span class="type">int</span> = syscall.O_WRONLY <span class="comment">// 只写模式打开文件</span></span><br><span class="line">    O_RDWR   <span class="type">int</span> = syscall.O_RDWR   <span class="comment">// 读写模式打开文件</span></span><br><span class="line">    O_APPEND <span class="type">int</span> = syscall.O_APPEND <span class="comment">// 写操作时将数据附加到文件尾部</span></span><br><span class="line">    O_CREATE <span class="type">int</span> = syscall.O_CREAT  <span class="comment">// 如果不存在将创建一个新文件</span></span><br><span class="line">    O_EXCL   <span class="type">int</span> = syscall.O_EXCL   <span class="comment">// 和O_CREATE配合使用，文件必须不存在</span></span><br><span class="line">    O_SYNC   <span class="type">int</span> = syscall.O_SYNC   <span class="comment">// 打开文件用于同步I/O</span></span><br><span class="line">    O_TRUNC  <span class="type">int</span> = syscall.O_TRUNC  <span class="comment">// 如果可能，打开时清空文件</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="io流"><a href="#io流" class="headerlink" title="io流"></a>io流</h3><h4 id="Reader接口"><a href="#Reader接口" class="headerlink" title="Reader接口"></a>Reader接口</h4><p><code>type Reader</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Writer接口"><a href="#Writer接口" class="headerlink" title="Writer接口"></a>Writer接口</h4><p><code>tpye Writer</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>os.File 同时实现了 io.Reader 和 io.Writer</li>
<li>strings.Reader 实现了 io.Reader</li>
<li>strings.Builder 实现了 io.Writer</li>
<li>bufio.Reader&#x2F;Writer 分别实现了 io.Reader 和 io.Writer</li>
<li>bytes.Buffer 同时实现了 io.Reader 和 io.Writer</li>
<li>bytes.Reader 实现了 io.Reader</li>
<li>compress&#x2F;gzip.Reader&#x2F;Writer 分别实现了 io.Reader 和 io.Writer</li>
<li>crypto&#x2F;cipher.StreamReader&#x2F;StreamWriter 分别实现了 io.Reader 和 io.Writer</li>
<li>crypto&#x2F;tls.Conn 同时实现了 io.Reader 和 io.Writer</li>
<li>encoding&#x2F;csv.Reader&#x2F;Writer 分别实现了 io.Reader 和 io.Writer</li>
<li>mime&#x2F;multipart.Part 实现了 io.Reader</li>
<li>net&#x2F;conn 分别实现了 io.Reader 和 io.Writer(Conn接口定义了Read&#x2F;Write</li>
</ul>
<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><h4 id="普通读"><a href="#普通读" class="headerlink" title="普通读"></a><strong>普通读</strong></h4><p><strong><code>Read</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) Read(p []byte) (n int, err error)</span><br></pre></td></tr></table></figure>

<p>Read读取数据写入p。本方法返回写入p的字节数。本方法一次调用最多会调用下层Reader接口一次Read方法，因此返回值n可能小于len(p)。读取到达结尾时，返回值n将为0而err将为io.EOF。</p>
<h4 id="bufio读"><a href="#bufio读" class="headerlink" title="bufio读"></a><strong>bufio读</strong></h4><p><strong><code>bufio.NewReader</code></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span></span> *bufio.Reader</span><br></pre></td></tr></table></figure>

<p><code>NewReader</code>创建一个具有默认大小缓冲，从rd读取的*bufio.Reader</p>
<p><strong><code>type bufio.Reader</code></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">   buf          []<span class="type">byte</span></span><br><span class="line">   rd           io.Reader <span class="comment">// reader provided by the client</span></span><br><span class="line">   r, w         <span class="type">int</span>       <span class="comment">// buf read and write positions</span></span><br><span class="line">   err          <span class="type">error</span></span><br><span class="line">   lastByte     <span class="type">int</span> <span class="comment">// last byte read for UnreadByte; -1 means invalid</span></span><br><span class="line">   lastRuneSize <span class="type">int</span> <span class="comment">// size of last rune read for UnreadRune; -1 means invalid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>(*Reader)ReadBytes</code></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> Read(delim <span class="type">byte</span>) (line []<span class="type">byte</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p><strong><code>(*Reader)ReadString</code></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> ReadString(delim <span class="type">byte</span>) (line <span class="type">string</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p><code>ReadBytes</code>和<code>ReaderString</code>分别返回一个包含已读取的数据和delim字节的<code>[]Byte</code>和<code>string</code></p>
<p>如果在读取到<code>delim</code>之前遇到了错误，它会返回在错误之前读取的数据以及该错误（一般是<code>io.EOF</code>）。当且仅当<code>ReadString</code>方法返回的切片不以<code>delim</code>结尾时，会返回一个非<code>nil</code>的错误。</p>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><h4 id="普通写"><a href="#普通写" class="headerlink" title="普通写"></a>普通写</h4><p><strong><code>(*Writer)Write</code></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> Write(p []<span class="type">byte</span>) (nn <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>



<h4 id="bufio写"><a href="#bufio写" class="headerlink" title="bufio写"></a>bufio写</h4><p><strong><code>bufio.NewWriter</code></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(w io.Writer)</span></span> *bufio.Writer</span><br></pre></td></tr></table></figure>

<p>因为用bufio写所以要调用Flush方法将缓冲中的数据写入下层的io.Writer接口</p>
<p><strong><code>(*Writer)WriteByte</code></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> WriteByte(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p><strong><code>(*Writer)WriteString</code></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> WriteString(s <span class="type">string</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p><code>WriteByte</code>和<code>WriteString</code>分别写入一个字节切片和一个字符串，返回写入的字节数。如果返回值小于<code>len(s)</code>，还会返回一个错误说明原因。</p>
<p><strong><code>(*Write)Flush</code></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> Flush() <span class="type">error</span></span><br></pre></td></tr></table></figure>

<h2 id="Gorm"><a href="#Gorm" class="headerlink" title="Gorm"></a>Gorm</h2><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>连接不同的数据库都需要导入对应数据的驱动程序，<code>GORM</code>已经贴心的为我们包装了一些驱动程序，只需要按如下方式导入需要的数据库驱动即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span></span><br><span class="line"><span class="comment">// import _ &quot;github.com/jinzhu/gorm/dialects/postgres&quot;</span></span><br><span class="line"><span class="comment">// import _ &quot;github.com/jinzhu/gorm/dialects/sqlite&quot;</span></span><br><span class="line"><span class="comment">// import _ &quot;github.com/jinzhu/gorm/dialects/mssql&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>连接<code>mysql</code></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">  _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db, err := gorm.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;user:password@(localhost)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义GORM-Model"><a href="#定义GORM-Model" class="headerlink" title="定义GORM Model"></a>定义GORM Model</h3><p>在使用ORM工具时，通常我们需要在代码中定义模型（Models）与数据库中的数据表进行映射，在GORM中模型（Models）通常是正常定义的结构体、基本的go类型或它们的指针。 <del>同时也支持<code>sql.Scanner</code>及<code>driver.Valuer</code>接口（interfaces）。</del></p>
<h4 id="gorm-Model"><a href="#gorm-Model" class="headerlink" title="gorm.Model"></a>gorm.Model</h4><p>gorm.Model是Gorm内置的一个结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gorm.Model定义</span></span><br><span class="line"><span class="keyword">type</span> Model <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">uint</span> <span class="string">`gorm:&quot;primary_key&quot;`</span></span><br><span class="line">  CreatedAt time.Time</span><br><span class="line">  UpdatedAt time.Time</span><br><span class="line">  DeletedAt *time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以内嵌到自己的model中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以完全自己定义模型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">int</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结构体标记"><a href="#结构体标记" class="headerlink" title="结构体标记"></a>结构体标记</h4><p>支持的结构体标记</p>
<table>
<thead>
<tr>
<th align="left">结构体标记</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">column</td>
<td>指定列名</td>
</tr>
<tr>
<td align="left">type</td>
<td>指定数据类型</td>
</tr>
<tr>
<td align="left">size</td>
<td>指定列大小，默认值为255</td>
</tr>
<tr>
<td align="left">primary_key</td>
<td>将列指定为主键</td>
</tr>
<tr>
<td align="left">unique</td>
<td>将列指定为唯一</td>
</tr>
<tr>
<td align="left">default</td>
<td>指定列默认值</td>
</tr>
<tr>
<td align="left">precision</td>
<td>指定列精度</td>
</tr>
<tr>
<td align="left">not null</td>
<td>将列指定为非null</td>
</tr>
<tr>
<td align="left">auto_increment</td>
<td>指定列<strong>是否</strong>为自增类型</td>
</tr>
<tr>
<td align="left">index</td>
<td>创建具有或不带名称的索引, 如果多个索引同名则创建复合索引</td>
</tr>
<tr>
<td align="left">unique_index</td>
<td>和 <code>INDEX</code> 类似，只不过创建的是唯一索引</td>
</tr>
<tr>
<td align="left">embedded</td>
<td>将结构设置为嵌入</td>
</tr>
<tr>
<td align="left">embeddedPrefix</td>
<td>设置嵌入结构的前缀</td>
</tr>
<tr>
<td align="left">&lt;-&#x2F;-&gt;</td>
<td>设置字段写入的权限， &lt;-:create 只创建、&lt;-:update 只更新、&lt;-:false 无写入权限、&lt;- 创建和更新权限。设置字段读的权限，<code>-&gt;:false</code> 无读权限</td>
</tr>
<tr>
<td align="left">-</td>
<td>忽略该字段，<code>-</code> 表示无读写，<code>-:migration</code> 表示无迁移权限，<code>-:all</code> 表示无读写迁移权限</td>
</tr>
</tbody></table>
<p>关联相关标记&#x2F;&#x2F;施工中&#x2F;&#x2F;</p>
<table>
<thead>
<tr>
<th>结构体标记</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="主键、表名、列名的约定"><a href="#主键、表名、列名的约定" class="headerlink" title="主键、表名、列名的约定"></a>主键、表名、列名的约定</h4><h5 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h5><p>gorm默认使用名为ID的字段作为表的主键，也可以使用tag将指定字段设置为主键</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">string</span> <span class="comment">// 名为`ID`的字段会默认作为表的主键</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用`AnimalID`作为主键</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">  AnimalID <span class="type">int64</span> <span class="string">`gorm:&quot;primary_key&quot;`</span></span><br><span class="line">  Name     <span class="type">string</span></span><br><span class="line">  Age      <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="表名"><a href="#表名" class="headerlink" title="表名"></a>表名</h5><p>表名默认是结构体名称的小写复数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;&#125; <span class="comment">// 默认表名是 `users`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 User 的表名设置为 `profiles`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(User)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;profiles&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> u.Role == <span class="string">&quot;admin&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;admin_users&quot;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;users&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>禁用默认表名的复数形式，如果置为 true，则 <code>User</code> 的默认表名是 <code>user</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.SingularTable(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>也可以通过<code>Table()</code>指定表名</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用User结构体创建名为`deleted_users`的表</span></span><br><span class="line">db.Table(<span class="string">&quot;deleted_users&quot;</span>).CreateTable(&amp;User&#123;&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="列名"><a href="#列名" class="headerlink" title="列名"></a>列名</h5><p>列名由字段名称进行下划线分割来生成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">uint</span>      <span class="comment">// column name is `id`</span></span><br><span class="line">  Name      <span class="type">string</span>    <span class="comment">// column name is `name`</span></span><br><span class="line">  Birthday  time.Time <span class="comment">// column name is `birthday`</span></span><br><span class="line">  CreatedAt time.Time <span class="comment">// column name is `created_at`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用tag指定列名</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">  AnimalId    <span class="type">int64</span>     <span class="string">`gorm:&quot;column:beast_id&quot;`</span>         <span class="comment">// set column name to `beast_id`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><h5 id="创建记录"><a href="#创建记录" class="headerlink" title="创建记录"></a>创建记录</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>, Age: <span class="number">18</span>, Birthday: time.Now()&#125;</span><br><span class="line"></span><br><span class="line">result := db.Create(&amp;user) <span class="comment">// 通过数据的指针来创建</span></span><br><span class="line"></span><br><span class="line">user.ID             <span class="comment">// 返回插入数据的主键</span></span><br><span class="line">result.Error        <span class="comment">// 返回 error</span></span><br><span class="line">result.RowsAffected <span class="comment">// 返回插入记录的条数</span></span><br></pre></td></tr></table></figure>

<h5 id="用指定字段创建记录"><a href="#用指定字段创建记录" class="headerlink" title="用指定字段创建记录"></a>用指定字段创建记录</h5><p>创建记录并更新给出的字段<code>select</code><strong>传入的字段名应该是结构体的字段名而不是数据表的字段名</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;CreatedAt&quot;</span>).Create(&amp;user)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`,`age`,`created_at`) VALUES (&quot;jinzhu&quot;, 18, &quot;2020-07-04 11:05:21.775&quot;)</span></span><br></pre></td></tr></table></figure>

<p>创建记录切忽略传递给略去的字段<code>omit</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Omit(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;CreatedAt&quot;</span>).Create(&amp;user)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`birthday`,`updated_at`) VALUES (&quot;2020-01-01 00:00:00.000&quot;, &quot;2020-07-04 11:05:21.775&quot;)</span></span><br></pre></td></tr></table></figure>

<h5 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h5><p>可以将一个切片传递给Create方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;Name: <span class="string">&quot;jinzhu1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu2&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu3&quot;</span>&#125;&#125;</span><br><span class="line">db.Create(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> users &#123;</span><br><span class="line">  user.ID <span class="comment">// 1,2,3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="创建钩子-hook"><a href="#创建钩子-hook" class="headerlink" title="创建钩子(hook)"></a>创建钩子(hook)</h5><p>GORM 允许用户定义的钩子有 <code>BeforeSave</code>, <code>BeforeCreate</code>, <code>AfterSave</code>, <code>AfterCreate</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> BeforeCreate(tx *gorm.DB) (err <span class="type">error</span>) &#123;</span><br><span class="line">  u.UUID = uuid.New()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> u.Role == <span class="string">&quot;admin&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;invalid role&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="根据Map创建"><a href="#根据Map创建" class="headerlink" title="根据Map创建"></a>根据Map创建</h5><p>GORM 支持根据 <code>map[string]interface&#123;&#125;</code> 和 <code>[]map[string]interface&#123;&#125;&#123;&#125;</code> 创建记录</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据map创建</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Create(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//根据[]map创建</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Create([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu_1&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">18</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu_2&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">20</span>&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="使用SQL表达式创建"><a href="#使用SQL表达式创建" class="headerlink" title="使用SQL表达式创建"></a>使用SQL表达式创建</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.Model(&amp;user).Update(<span class="string">&quot;age&quot;</span>, gorm.Expr(<span class="string">&quot;age * ? + ?&quot;</span>, <span class="number">2</span>, <span class="number">100</span>))</span><br><span class="line"><span class="comment">//// UPDATE `users` SET `age` = age * 2 + 100, `updated_at` = &#x27;2020-02-16 13:10:20&#x27;  WHERE `users`.`id` = 1;</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;age&quot;</span>: gorm.Expr(<span class="string">&quot;age * ? + ?&quot;</span>, <span class="number">2</span>, <span class="number">100</span>)&#125;)</span><br><span class="line"><span class="comment">//// UPDATE &quot;users&quot; SET &quot;age&quot; = age * &#x27;2&#x27; + &#x27;100&#x27;, &quot;updated_at&quot; = &#x27;2020-02-16 13:05:51&#x27; WHERE `users`.`id` = 1;</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).UpdateColumn(<span class="string">&quot;age&quot;</span>, gorm.Expr(<span class="string">&quot;age - ?&quot;</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment">//// UPDATE &quot;users&quot; SET &quot;age&quot; = age - 1 WHERE &quot;id&quot; = &#x27;1&#x27;;</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).Where(<span class="string">&quot;age &gt; 10&quot;</span>).UpdateColumn(<span class="string">&quot;age&quot;</span>, gorm.Expr(<span class="string">&quot;age - ?&quot;</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment">//// UPDATE &quot;users&quot; SET &quot;age&quot; = age - 1 WHERE &quot;id&quot; = &#x27;1&#x27; AND quantity &gt; 10;</span></span><br></pre></td></tr></table></figure>

<h5 id="使用-SQL-表达式、Context-Valuer-创建记录-x2F-x2F-施工中-x2F-x2F"><a href="#使用-SQL-表达式、Context-Valuer-创建记录-x2F-x2F-施工中-x2F-x2F" class="headerlink" title="使用 SQL 表达式、Context Valuer 创建记录&#x2F;&#x2F;施工中&#x2F;&#x2F;"></a>使用 SQL 表达式、Context Valuer 创建记录&#x2F;&#x2F;施工中&#x2F;&#x2F;</h5><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><h5 id="检索单个对象"><a href="#检索单个对象" class="headerlink" title="检索单个对象"></a>检索单个对象</h5><p><code>First</code> <code>Take</code> <code>Last</code>方法，查询数据库时添加了<code>limit 1</code>条件，当没有找到记录时，他会返回<code>ErrRecordNotFound</code>错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取第一条记录（主键升序）</span></span><br><span class="line">db.First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一条记录，没有指定排序字段</span></span><br><span class="line">db.Take(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最后一条记录（主键降序）</span></span><br><span class="line">db.Last(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY id DESC LIMIT 1;</span></span><br><span class="line"></span><br><span class="line">result := db.First(&amp;user)</span><br><span class="line">result.RowsAffected <span class="comment">// 返回找到的记录数</span></span><br><span class="line">result.Error        <span class="comment">// returns error or nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 ErrRecordNotFound 错误</span></span><br><span class="line">errors.Is(result.Error, gorm.ErrRecordNotFound)</span><br></pre></td></tr></table></figure>

<h6 id="根据主键检索"><a href="#根据主键检索" class="headerlink" title="根据主键检索"></a>根据主键检索</h6><p>如果主键是数字类型，可以使用内联条件来检索对象。<strong>注意sql注入问题。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.First(&amp;user, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.First(&amp;user, <span class="string">&quot;10&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Find(&amp;users, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id IN (1,2,3);</span></span><br></pre></td></tr></table></figure>

<p>如果主键是字符串</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.First(&amp;user, <span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = &quot;string&quot;;</span></span><br></pre></td></tr></table></figure>

<p>当目标对象有一个主要值时，使用主键构建条件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = User&#123;ID: <span class="number">10</span>&#125;</span><br><span class="line">db.First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result User</span><br><span class="line">db.Model(User&#123;ID: <span class="number">10</span>&#125;).First(&amp;result)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br></pre></td></tr></table></figure>

<h5 id="检索全部对象"><a href="#检索全部对象" class="headerlink" title="检索全部对象"></a>检索全部对象</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">result := db.Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users;</span></span><br><span class="line"></span><br><span class="line">result.RowsAffected</span><br><span class="line"><span class="comment">// returns found records count, equals `len(users)`</span></span><br><span class="line"></span><br><span class="line">result.Error</span><br><span class="line"><span class="comment">// returns error</span></span><br></pre></td></tr></table></figure>

<h5 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h5><h6 id="string"><a href="#string" class="headerlink" title="string"></a>string</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get first matched record</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get all matched records</span></span><br><span class="line">db.Where(<span class="string">&quot;name &lt;&gt; ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name &lt;&gt; &#x27;jinzhu&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IN</span></span><br><span class="line">db.Where(<span class="string">&quot;name IN ?&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name IN (&#x27;jinzhu&#x27;,&#x27;jinzhu 2&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LIKE</span></span><br><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jin%&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name LIKE &#x27;%jin%&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AND</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ? AND age &gt;= ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;22&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; AND age &gt;= 22;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Time</span></span><br><span class="line">db.Where(<span class="string">&quot;updated_at &gt; ?&quot;</span>, lastWeek).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE updated_at &gt; &#x27;2000-01-01 00:00:00&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BETWEEN</span></span><br><span class="line">db.Where(<span class="string">&quot;created_at BETWEEN ? AND ?&quot;</span>, lastWeek, today).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE created_at BETWEEN &#x27;2000-01-01 00:00:00&#x27; AND &#x27;2000-01-08 00:00:00&#x27;;</span></span><br></pre></td></tr></table></figure>



<h2 id="在Go中使用redis"><a href="#在Go中使用redis" class="headerlink" title="在Go中使用redis"></a>在Go中使用redis</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>连接池以及链接设置</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Rdb *redis.Client</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitRedis</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Rdb = redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">		<span class="comment">//连接信息</span></span><br><span class="line">		Network:  <span class="string">&quot;tcp&quot;</span>,            <span class="comment">//网络类型，tcp or unix，默认tcp</span></span><br><span class="line">		Addr:     <span class="string">&quot;127.0.0.1:6379&quot;</span>, <span class="comment">//主机名+冒号+端口，默认localhost:6379</span></span><br><span class="line">		Password: <span class="string">&quot;123456&quot;</span>,         <span class="comment">//密码</span></span><br><span class="line">		DB:       <span class="number">0</span>,                <span class="comment">// redis数据库index</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//连接池容量及闲置连接数量</span></span><br><span class="line">		PoolSize:     <span class="number">15</span>, <span class="comment">// 连接池最大socket连接数，默认为4倍CPU数， 4 * runtime.NumCPU</span></span><br><span class="line">		MinIdleConns: <span class="number">10</span>, <span class="comment">//在启动阶段创建指定数量的Idle连接，并长期维持idle状态的连接数不少于指定数量；。</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//超时</span></span><br><span class="line">		DialTimeout:  <span class="number">5</span> * time.Second, <span class="comment">//连接建立超时时间，默认5秒。</span></span><br><span class="line">		ReadTimeout:  <span class="number">3</span> * time.Second, <span class="comment">//读超时，默认3秒， -1表示取消读超时</span></span><br><span class="line">		WriteTimeout: <span class="number">3</span> * time.Second, <span class="comment">//写超时，默认等于读超时</span></span><br><span class="line">		PoolTimeout:  <span class="number">4</span> * time.Second, <span class="comment">//当所有连接都处在繁忙状态时，客户端等待可用连接的最大等待时长，默认为读超时+1秒。</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//闲置连接检查包括IdleTimeout，MaxConnAge</span></span><br><span class="line">		IdleCheckFrequency: <span class="number">60</span> * time.Second, <span class="comment">//闲置连接检查的周期，默认为1分钟，-1表示不做周期性检查，只在客户端获取连接时对闲置连接进行处理。</span></span><br><span class="line">		IdleTimeout:        <span class="number">5</span> * time.Minute,  <span class="comment">//闲置超时，默认5分钟，-1表示取消闲置超时检查</span></span><br><span class="line">		MaxConnAge:         <span class="number">0</span> * time.Second,  <span class="comment">//连接存活时长，从创建开始计时，超过指定时长则关闭连接，默认为0，即不关闭存活时长较长的连接</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//命令执行失败时的重试策略</span></span><br><span class="line">		MaxRetries:      <span class="number">0</span>,                      <span class="comment">// 命令执行失败时，最多重试多少次，默认为0即不重试</span></span><br><span class="line">		MinRetryBackoff: <span class="number">8</span> * time.Millisecond,   <span class="comment">//每次计算重试间隔时间的下限，默认8毫秒，-1表示取消间隔</span></span><br><span class="line">		MaxRetryBackoff: <span class="number">512</span> * time.Millisecond, <span class="comment">//每次计算重试间隔时间的上限，默认512毫秒，-1表示取消间隔</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//可自定义连接函数</span></span><br><span class="line">		Dialer: <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">			netDialer := &amp;net.Dialer&#123;</span><br><span class="line">				Timeout:   <span class="number">5</span> * time.Second,</span><br><span class="line">				KeepAlive: <span class="number">5</span> * time.Minute,</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> netDialer.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:6379&quot;</span>)</span><br><span class="line">		&#125;,</span><br><span class="line"></span><br><span class="line">		<span class="comment">//钩子函数</span></span><br><span class="line">		OnConnect: <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, conn *redis.Conn)</span></span> <span class="type">error</span> &#123; <span class="comment">//仅当客户端执行命令时需要从连接池获取连接时，如果连接池需要新建连接时则会调用此钩子函数</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;conn=%v\n&quot;</span>, conn)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	_, err := Rdb.Ping(context.Background()).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Print(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;redis 链接成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般设置成这样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rdb = redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">		Addr:     <span class="string">&quot;127.0.0.1:6379&quot;</span>,</span><br><span class="line">		Password: <span class="string">&quot;123456&quot;</span>, </span><br><span class="line">		DB:       <span class="number">0</span>,        </span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="一般写操作"><a href="#一般写操作" class="headerlink" title="一般写操作"></a>一般写操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String</span></span><br><span class="line">err := rdb.Set(ctx, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>, <span class="number">0</span>).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列表 List</span></span><br><span class="line">rdb.LPush(ctx, <span class="string">&quot;list&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合</span></span><br><span class="line">rdb.SAdd(ctx, <span class="string">&quot;team&quot;</span>, <span class="string">&quot;kobe&quot;</span>, <span class="string">&quot;jordan&quot;</span>)</span><br><span class="line">rdb.SAdd(ctx, <span class="string">&quot;team&quot;</span>, <span class="string">&quot;curry&quot;</span>)</span><br><span class="line">rdb.SAdd(ctx, <span class="string">&quot;team&quot;</span>, <span class="string">&quot;kobe&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash</span></span><br><span class="line">rdb.HSet(ctx, <span class="string">&quot;user&quot;</span>, <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>, <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>)</span><br><span class="line">rdb.HSet(ctx, <span class="string">&quot;user&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>, <span class="string">&quot;key4&quot;</span>, <span class="string">&quot;value4&quot;</span>&#125;)</span><br><span class="line">rdb.HSet(ctx, <span class="string">&quot;user&quot;</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;key5&quot;</span>: <span class="string">&quot;value5&quot;</span>, <span class="string">&quot;key6&quot;</span>: <span class="string">&quot;value6&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有序集合</span></span><br><span class="line">rdb.ZAdd(ctx, <span class="string">&quot;zSet&quot;</span>, &amp;redis.Z&#123;</span><br><span class="line">    Score:  <span class="number">0</span>,</span><br><span class="line">    Member: <span class="number">1</span>,</span><br><span class="line">&#125;)</span><br><span class="line">rdb.ZAdd(ctx, <span class="string">&quot;zSet&quot;</span>, &amp;redis.Z&#123;</span><br><span class="line">    Score:  <span class="number">0</span>,</span><br><span class="line">    Member: <span class="number">2</span>,</span><br><span class="line">&#125;)</span><br><span class="line">rdb.ZAdd(ctx, <span class="string">&quot;zSet&quot;</span>, &amp;redis.Z&#123;</span><br><span class="line">    Score:  <span class="number">0</span>,</span><br><span class="line">    Member: <span class="number">3</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道</span></span><br><span class="line">pipe := rdb.Pipeline()</span><br><span class="line"></span><br><span class="line">incr := pipe.Incr(ctx, <span class="string">&quot;pipeline_counter&quot;</span>)</span><br><span class="line">pipe.Expire(ctx, <span class="string">&quot;pipeline_counter&quot;</span>, time.Hour)</span><br><span class="line"></span><br><span class="line">cmds, err := pipe.Exec(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The value is available only after Exec is called.</span></span><br><span class="line">fmt.Println(incr.Val())</span><br></pre></td></tr></table></figure>

<h2 id="Zap"><a href="#Zap" class="headerlink" title="Zap"></a>Zap</h2><h3 id="配置日志记录器"><a href="#配置日志记录器" class="headerlink" title="配置日志记录器"></a>配置日志记录器</h3><p>Zap提供两种类型的日志记录器<code>Sugared Logger</code>和<code>Logger</code>，两种<strong>logger都打印输出JSON结构格式</strong>。</p>
<p><code>Logger</code>比<code>Sugared Logger</code>更快，内存分配次数更少，但只支持强类型的结构化 日志记录。</p>
<h4 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h4><ul>
<li>通过调用<code>Zap.NewProoduction()</code> 、<code>Zap.NewDevelopment()</code> 或者 <code>Zap.Example()</code>创建一个<code>Logger</code>  </li>
<li>以上函数都可创建一个<code>Logger</code> 区别在于它们记录的信息不同</li>
<li>默认情况下日志都会打印到应用程序的<code>console</code>界面</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger *zap.Logger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	InitLogger()</span><br><span class="line">  <span class="keyword">defer</span> logger.Sync()</span><br><span class="line">	simpleHttpGet(<span class="string">&quot;www.google.com&quot;</span>)</span><br><span class="line">	simpleHttpGet(<span class="string">&quot;http://www.google.com&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个logger</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">	logger, _ = zap.NewProduction()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simpleHttpGet</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	resp, err := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">//使用info/error等logger方法记录消息</span></span><br><span class="line">		logger.Error(</span><br><span class="line">			<span class="string">&quot;Error fetching url..&quot;</span>,</span><br><span class="line">			zap.String(<span class="string">&quot;url&quot;</span>, url),</span><br><span class="line">			zap.Error(err))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		logger.Info(<span class="string">&quot;Success..&quot;</span>,</span><br><span class="line">			zap.String(<span class="string">&quot;statusCode&quot;</span>, resp.Status),</span><br><span class="line">			zap.String(<span class="string">&quot;url&quot;</span>, url))</span><br><span class="line">		resp.Body.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志记录器方法的语法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(log *Logger)</span></span> MethodXXX(msg <span class="type">string</span>, fields ...Field) </span><br></pre></td></tr></table></figure>

<p>其中<code>MethodXXX</code>是一个可变参数函数，可以是<code>Info/Error/Debug/Panic</code>等。每个方法都接受一个消息字符串和任意数量的<code>zapcore.Field</code>场参数</p>
<p><code>zapcore.Field</code>就是一组键值对参数</p>
<h4 id="Sugared-Logger"><a href="#Sugared-Logger" class="headerlink" title="Sugared Logger"></a>Sugared Logger</h4><p>大部分实现相同，区别在于要先调用主logger的<code>Sugar()</code>方法来获取一个<code>Sugared Logger</code>然后一使用<code>Suggar Logger</code> 代替<code>Logger</code>的代码</p>
<p>替换后的对应代码如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sugarLogger *zap.SugaredLogger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	InitLogger()</span><br><span class="line">	<span class="keyword">defer</span> sugarLogger.Sync()</span><br><span class="line">	simpleHttpGet(<span class="string">&quot;www.google.com&quot;</span>)</span><br><span class="line">	simpleHttpGet(<span class="string">&quot;http://www.google.com&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个Sugared Logger</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">  logger, _ := zap.NewProduction()</span><br><span class="line">	sugarLogger = logger.Sugar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以printf格式输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simpleHttpGet</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	sugarLogger.Debugf(<span class="string">&quot;Trying to hit GET request for %s&quot;</span>, url)</span><br><span class="line">	resp, err := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		sugarLogger.Errorf(<span class="string">&quot;Error fetching URL %s : Error = %s&quot;</span>, url, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		sugarLogger.Infof(<span class="string">&quot;Success! statusCode = %s for URL %s&quot;</span>, resp.Status, url)</span><br><span class="line">		resp.Body.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定制logger"><a href="#定制logger" class="headerlink" title="定制logger"></a>定制logger</h3><h4 id="将日志写入文件而不是输出终端"><a href="#将日志写入文件而不是输出终端" class="headerlink" title="将日志写入文件而不是输出终端"></a>将日志写入文件而不是输出终端</h4><p>使用<code>Zap.New(...)</code>方法传递所有配置，而不是使用像<code>Zap.Newproduction()</code>这样的预置方法创建<code>logger</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(core zapcore.Core, options ...Option)</span></span> *Logger</span><br></pre></td></tr></table></figure>

<p><code>zapcore.Core</code>需要三个配置：<code>Encoder</code>,<code>WriteSyncer</code>,<code>LogerLevel</code></p>
<ol>
<li><p>Encoder:编码器，配置如何写入日志。可以使用<code>NewJSONEncoder()</code>，并使用预先配置好的<code>ProducitonEncoderConfig()</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig())</span><br></pre></td></tr></table></figure>
</li>
<li><p>WriteSyncer:指定日志写入的位置。使用<code>zapcore.AddSync</code>函数并将打开文件的句子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file, _ := os.Create(<span class="string">&quot;./test.log&quot;</span>)</span><br><span class="line">   writeSyncer := zapcore.AddSync(file)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Log Level:那种级别的日志将被写入</p>
<p><strong>DebugLevel表示全部输出</strong></p>
</li>
</ol>
<h4 id="将JSON-Encoder更改为普通的Log-Encoder"><a href="#将JSON-Encoder更改为普通的Log-Encoder" class="headerlink" title="将JSON Encoder更改为普通的Log Encoder"></a>将JSON Encoder更改为普通的Log Encoder</h4><p>将<code>NewJSONEncoder()</code>更改为<code>NewConsoleEncoder()</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> zapcore.NewConsoleEncoder(zap.NewProductionEncoderConfig())</span><br></pre></td></tr></table></figure>

<p>此时会输出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.572161051846623e+09</span>	debug	Trying to hit GET request <span class="keyword">for</span> www.sogo.com</span><br><span class="line"><span class="number">1.572161051846828e+09</span>	<span class="type">error</span>	Error fetching URL www.sogo.com : Error = Get www.sogo.com: unsupported protocol scheme <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="number">1.5721610518468401e+09</span>	debug	Trying to hit GET request <span class="keyword">for</span> http:<span class="comment">//www.sogo.com</span></span><br><span class="line"><span class="number">1.572161052068744e+09</span>	info	Success! statusCode = <span class="number">200</span> OK <span class="keyword">for</span> URL http:<span class="comment">//www.sogo.com</span></span><br></pre></td></tr></table></figure>

<h4 id="更改时间编码并添加调用者详细信息"><a href="#更改时间编码并添加调用者详细信息" class="headerlink" title="更改时间编码并添加调用者详细信息"></a>更改时间编码并添加调用者详细信息</h4><p>覆盖默认的<code>PronductionConfig()</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getEncoder</span><span class="params">()</span></span> zapcore.Encoder &#123;</span><br><span class="line">	encoderConfig := zap.NewProductionEncoderConfig()</span><br><span class="line">	<span class="comment">//修改时间编码器</span></span><br><span class="line">	encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder</span><br><span class="line">	<span class="comment">//在日志文件中使用大写字母记录日志级别</span></span><br><span class="line">	encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder</span><br><span class="line">	<span class="keyword">return</span> zapcore.NewConsoleEncoder(encoderConfig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改zap logger代码，在<code>zap.New()</code>添加一个<code>Option</code>添加将调用函数信息记录到日志中的功能</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger := zap.New(core, zap.AddCaller())</span><br></pre></td></tr></table></figure>

<h4 id="AddCallerSkip"><a href="#AddCallerSkip" class="headerlink" title="AddCallerSkip"></a>AddCallerSkip</h4><p>当我们不是直接使用初始化好的logger实例记录日志，而是将其包装成一个函数等，此时日录日志的函数调用链会增加，想要获得准确的调用信息就需要通过<code>AddCallerSkip</code>函数来跳过。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger := zap.New(core, zap.AddCaller(), zap.AddCallerSkip(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<h4 id="将日志输出到多个位置"><a href="#将日志输出到多个位置" class="headerlink" title="将日志输出到多个位置"></a>将日志输出到多个位置</h4><p>利用io.MultiWriter，可以将日志同时输出到文件和终端</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLogWriter</span><span class="params">()</span></span> zapcore.WriteSyncer &#123;</span><br><span class="line">	file, _ := os.Create(<span class="string">&quot;./test.log&quot;</span>)</span><br><span class="line">	ws := io.MultiWriter(file, os.Stdout)</span><br><span class="line">	<span class="keyword">return</span> zapcore.AddSync(ws)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="将err日志单独输出到文件"><a href="#将err日志单独输出到文件" class="headerlink" title="将err日志单独输出到文件"></a>将err日志单独输出到文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">	encoder := getEncoder()</span><br><span class="line">	<span class="comment">// test.log记录全量日志</span></span><br><span class="line">	logF, _ := os.Create(<span class="string">&quot;./test.log&quot;</span>)</span><br><span class="line">	c1 := zapcore.NewCore(encoder, zapcore.AddSync(logF), zapcore.DebugLevel)</span><br><span class="line">	<span class="comment">// test.err.log记录ERROR级别的日志</span></span><br><span class="line">	errF, _ := os.Create(<span class="string">&quot;./test.err.log&quot;</span>)</span><br><span class="line">	c2 := zapcore.NewCore(encoder, zapcore.AddSync(errF), zap.ErrorLevel)</span><br><span class="line">	<span class="comment">// 使用NewTee将c1和c2合并到core</span></span><br><span class="line">	core := zapcore.NewTee(c1, c2)</span><br><span class="line">	logger = zap.New(core, zap.AddCaller())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用Lumberjack进行日志切割归档"><a href="#使用Lumberjack进行日志切割归档" class="headerlink" title="使用Lumberjack进行日志切割归档"></a>使用Lumberjack进行日志切割归档</h3><p>Zap本身不支持切割归档日志</p>
<p>官方为了添加日志切割归档功能，要使用Lumberjack来实现</p>
<p>目前只支持文件大小切割，原因是按时间切割效率低且不能保证日志数据不被破坏。</p>
<p>想按日期切割可以使用<a target="_blank" rel="noopener" href="https://github.com/lestrrat-go/file-rotatelogs">https://github.com/lestrrat-go/file-rotatelogs</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用file-rotatelogs按天切割日志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rotatelogs <span class="string">&quot;github.com/lestrrat-go/file-rotatelogs&quot;</span></span><br><span class="line"></span><br><span class="line">l, _ := rotatelogs.New(</span><br><span class="line">	filename+<span class="string">&quot;.%Y%m%d%H%M&quot;</span>,</span><br><span class="line">	rotatelogs.WithMaxAge(<span class="number">30</span>*<span class="number">24</span>*time.Hour),    <span class="comment">// 最长保存30天</span></span><br><span class="line">	rotatelogs.WithRotationTime(time.Hour*<span class="number">24</span>), <span class="comment">// 24小时切割一次</span></span><br><span class="line">)</span><br><span class="line">zapcore.AddSync(l)</span><br></pre></td></tr></table></figure>

<h4 id="zap-logger中加入Lumberjack"><a href="#zap-logger中加入Lumberjack" class="headerlink" title="zap logger中加入Lumberjack"></a>zap logger中加入Lumberjack</h4><p>要在zap中加入Lumberjack支持，需要修改<code>WriteSyncer</code>代码我们将按照下面的代码修改<code>getLogWriter()</code>函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLogWriter</span><span class="params">()</span></span> zapcore.WriteSyncer &#123;</span><br><span class="line">	lumberJackLogger := &amp;lumberjack.Logger&#123;</span><br><span class="line">		Filename:   <span class="string">&quot;./test.log&quot;</span>,</span><br><span class="line">		MaxSize:    <span class="number">10</span>,</span><br><span class="line">		MaxBackups: <span class="number">5</span>,</span><br><span class="line">		MaxAge:     <span class="number">30</span>,</span><br><span class="line">		Compress:   <span class="literal">false</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> zapcore.AddSync(lumberJackLogger)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lumberjack Logger采用一下属性作为输入</p>
<ul>
<li>Filename: 日志文件的位置</li>
<li>MaxSize：在进行切割之前，日志文件的最大大小（以MB为单位）</li>
<li>MaxBackups：保留旧文件的最大个数</li>
<li>MaxAges：保留旧文件的最大天数</li>
<li>Compress：是否压缩&#x2F;归档旧文件</li>
</ul>
<p>最后成果如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;gopkg.in/natefinch/lumberjack.v2&quot;</span></span><br><span class="line">	<span class="string">&quot;go.uber.org/zap&quot;</span></span><br><span class="line">	<span class="string">&quot;go.uber.org/zap/zapcore&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sugarLogger *zap.SugaredLogger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	InitLogger()</span><br><span class="line">	<span class="keyword">defer</span> sugarLogger.Sync()</span><br><span class="line">	simpleHttpGet(<span class="string">&quot;www.sogo.com&quot;</span>)</span><br><span class="line">	simpleHttpGet(<span class="string">&quot;http://www.sogo.com&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">	writeSyncer := getLogWriter()</span><br><span class="line">	encoder := getEncoder()</span><br><span class="line">	core := zapcore.NewCore(encoder, writeSyncer, zapcore.DebugLevel)</span><br><span class="line"></span><br><span class="line">	logger := zap.New(core, zap.AddCaller())</span><br><span class="line">	sugarLogger = logger.Sugar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getEncoder</span><span class="params">()</span></span> zapcore.Encoder &#123;</span><br><span class="line">	encoderConfig := zap.NewProductionEncoderConfig()</span><br><span class="line">	encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder</span><br><span class="line">	encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder</span><br><span class="line">	<span class="keyword">return</span> zapcore.NewConsoleEncoder(encoderConfig)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLogWriter</span><span class="params">()</span></span> zapcore.WriteSyncer &#123;</span><br><span class="line">	lumberJackLogger := &amp;lumberjack.Logger&#123;</span><br><span class="line">		Filename:   <span class="string">&quot;./test.log&quot;</span>,</span><br><span class="line">		MaxSize:    <span class="number">1</span>,</span><br><span class="line">		MaxBackups: <span class="number">5</span>,</span><br><span class="line">		MaxAge:     <span class="number">30</span>,</span><br><span class="line">		Compress:   <span class="literal">false</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> zapcore.AddSync(lumberJackLogger)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simpleHttpGet</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	sugarLogger.Debugf(<span class="string">&quot;Trying to hit GET request for %s&quot;</span>, url)</span><br><span class="line">	resp, err := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		sugarLogger.Errorf(<span class="string">&quot;Error fetching URL %s : Error = %s&quot;</span>, url, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		sugarLogger.Infof(<span class="string">&quot;Success! statusCode = %s for URL %s&quot;</span>, resp.Status, url)</span><br><span class="line">		resp.Body.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span><span class="number">-10</span><span class="number">-27</span>T15:<span class="number">50</span>:<span class="number">32.944</span>+<span class="number">0800</span>	DEBUG	logic/temp2.<span class="keyword">go</span>:<span class="number">48</span>	Trying to hit GET request <span class="keyword">for</span> www.sogo.com</span><br><span class="line"><span class="number">2019</span><span class="number">-10</span><span class="number">-27</span>T15:<span class="number">50</span>:<span class="number">32.944</span>+<span class="number">0800</span>	ERROR	logic/temp2.<span class="keyword">go</span>:<span class="number">51</span>	Error fetching URL www.sogo.com : Error = Get www.sogo.com: unsupported protocol scheme <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="number">2019</span><span class="number">-10</span><span class="number">-27</span>T15:<span class="number">50</span>:<span class="number">32.944</span>+<span class="number">0800</span>	DEBUG	logic/temp2.<span class="keyword">go</span>:<span class="number">48</span>	Trying to hit GET request <span class="keyword">for</span> http:<span class="comment">//www.sogo.com</span></span><br><span class="line"><span class="number">2019</span><span class="number">-10</span><span class="number">-27</span>T15:<span class="number">50</span>:<span class="number">33.165</span>+<span class="number">0800</span>	INFO	logic/temp2.<span class="keyword">go</span>:<span class="number">53</span>	Success! statusCode = <span class="number">200</span> OK <span class="keyword">for</span> URL http:<span class="comment">//www.sogo.com</span></span><br></pre></td></tr></table></figure>

<h3 id="使用zap的一般步骤"><a href="#使用zap的一般步骤" class="headerlink" title="使用zap的一般步骤"></a>使用zap的一般步骤</h3><ol>
<li>生成编码器,通过函数<code>getEncoder()zapcore.Encoder</code>配置时间编码，设置logger level大写等</li>
<li>通过函数<code>getLogWriter()zapcore.WriterSyncer</code>指定日志写入位置（使用Lumberjack)</li>
<li>通过函数<code>InitLogger()</code>生成<code>Logger</code>,函数内部调用<code>getEncoder()</code>和   <code>getLogWriter</code>，获得<code>zapcore.Encoder</code>和<code>zapcore.WriterSyncer</code>，然后调用方法<code>zap.New()</code>(可设置添加调用者信息）生成logger,在调用<code>logger.Sugar()</code>获得<code>sugaredLogger</code></li>
<li>在main函数中调用<code>InitLogger()</code>并<code>defer sugarLogger.Sync()</code>将缓存中的log<code>flush</code>进输出中</li>
</ol>
<h2 id="Viper"><a href="#Viper" class="headerlink" title="Viper"></a>Viper</h2><p><strong>viper支持以下特性:</strong></p>
<ul>
<li>设置默认值</li>
<li>从<code>JSON</code>、<code>TOML</code>、<code>YAML</code>、<code>HCL</code>、<code>envfile</code>和<code>Java properties</code>格式的配置文件读取配置信息(一般go常用<code>YAML</code>)</li>
<li>实时监控和重新读取配置文件(可选)</li>
<li>从环境变量读取</li>
<li>从远程配置系统（etcd或Consul）读取并监控配置变化</li>
<li>从命令行参数读取配置</li>
<li>从buffer读取配置</li>
<li>显式配置值</li>
</ul>
<h3 id="把值存入Viper"><a href="#把值存入Viper" class="headerlink" title="把值存入Viper"></a>把值存入Viper</h3><h4 id="建立默认值"><a href="#建立默认值" class="headerlink" title="建立默认值"></a>建立默认值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">viper.SetDefault(<span class="string">&quot;ContentDir&quot;</span>, <span class="string">&quot;content&quot;</span>)</span><br><span class="line">viper.SetDefault(<span class="string">&quot;LayoutDir&quot;</span>, <span class="string">&quot;layouts&quot;</span>)</span><br><span class="line">viper.SetDefault(<span class="string">&quot;Taxonomies&quot;</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;tag&quot;</span>: <span class="string">&quot;tags&quot;</span>, <span class="string">&quot;category&quot;</span>: <span class="string">&quot;categories&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h4><p>下面是一个如何使用Viper搜索和读取配置文件的示例。不需要任何特定的路径，但是至少应该提供一个配置文件预期出现的路径。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">viper.SetConfigFile(<span class="string">&quot;./config.yaml&quot;</span>) <span class="comment">// 指定配置文件路径</span></span><br><span class="line">viper.SetConfigName(<span class="string">&quot;config&quot;</span>) <span class="comment">// 配置文件名称(无扩展名)</span></span><br><span class="line">viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>) <span class="comment">// 如果配置文件的名称中没有扩展名，则需要配置此项</span></span><br><span class="line">viper.AddConfigPath(<span class="string">&quot;/etc/appname/&quot;</span>)   <span class="comment">// 查找配置文件所在的路径</span></span><br><span class="line">viper.AddConfigPath(<span class="string">&quot;$HOME/.appname&quot;</span>)  <span class="comment">// 多次调用以添加多个搜索路径</span></span><br><span class="line">viper.AddConfigPath(<span class="string">&quot;.&quot;</span>)               <span class="comment">// 还可以在工作目录中查找配置</span></span><br><span class="line">err := viper.ReadInConfig() <span class="comment">// 查找并读取配置文件</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">// 处理读取配置文件的错误</span></span><br><span class="line">	<span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;Fatal error config file: %s \n&quot;</span>, err))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载配置文件出错时，可以这样处理找不到配置文件的特定情况</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := viper.ReadInConfig(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := err.(viper.ConfigFileNotFoundError); ok &#123;</span><br><span class="line">        <span class="comment">// 配置文件未找到错误；如果需要可以忽略</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 配置文件被找到，但产生了另外的错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置文件找到并成功解析</span></span><br></pre></td></tr></table></figure>

<h4 id="写入配置文件"><a href="#写入配置文件" class="headerlink" title="写入配置文件"></a>写入配置文件</h4><p><strong>一般来说标记为<code>safe</code>的所有方法都不会覆盖任何文件，而是直接创建（如果不存在），而默认行为是创建或截断</strong></p>
<ul>
<li>WriteConfig - 将当前的<code>viper</code>配置写入预定义的路径并覆盖（如果存在的话）。如果没有预定义的路径，则报错。</li>
<li>SafeWriteConfig - 将当前的<code>viper</code>配置写入预定义的路径。如果没有预定义的路径，则报错。如果存在，将不会覆盖当前的配置文件。</li>
<li>WriteConfigAs - 将当前的<code>viper</code>配置写入给定的文件路径。将覆盖给定的文件(如果它存在的话)。</li>
<li>SafeWriteConfigAs - 将当前的<code>viper</code>配置写入给定的文件路径。不会覆盖给定的文件(如果它存在的话)。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">viper.WriteConfig() <span class="comment">// 将当前配置写入“viper.AddConfigPath()”和“viper.SetConfigName”设置的预定义路径</span></span><br><span class="line">viper.SafeWriteConfig()</span><br><span class="line">viper.WriteConfigAs(<span class="string">&quot;/path/to/my/.config&quot;</span>)</span><br><span class="line">viper.SafeWriteConfigAs(<span class="string">&quot;/path/to/my/.config&quot;</span>) <span class="comment">// 因为该配置文件写入过，所以会报错</span></span><br><span class="line">viper.SafeWriteConfigAs(<span class="string">&quot;/path/to/my/.other_config&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="监控并重新读取配置文件"><a href="#监控并重新读取配置文件" class="headerlink" title="监控并重新读取配置文件"></a>监控并重新读取配置文件</h4><p>Viper支持在运行时实时读取配置文件的功能，只需告诉viper实例watchConfig。可选地，你可以为Viper提供一个回调函数，以便在每次发生更改时运行。<strong>确保在调用<code>WatchConfig()</code>前添加了所有的配置路径</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">viper.WatchConfig()</span><br><span class="line">viper.OnConfigChange(<span class="function"><span class="keyword">func</span><span class="params">(e fsnotify.Event)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 配置文件发生变更之后会调用的回调函数</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Config file changed:&quot;</span>, e.Name)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="从io-Reader读取配置"><a href="#从io-Reader读取配置" class="headerlink" title="从io.Reader读取配置"></a>从io.Reader读取配置</h4><p>可以实现自己所需的配置源并将其提供给viper</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>) <span class="comment">// 或者 viper.SetConfigType(&quot;YAML&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任何需要将此配置添加到程序中的方法。</span></span><br><span class="line"><span class="keyword">var</span> yamlExample = []<span class="type">byte</span>(<span class="string">`</span></span><br><span class="line"><span class="string">Hacker: true</span></span><br><span class="line"><span class="string">name: steve</span></span><br><span class="line"><span class="string">hobbies:</span></span><br><span class="line"><span class="string">- skateboarding</span></span><br><span class="line"><span class="string">- snowboarding</span></span><br><span class="line"><span class="string">- go</span></span><br><span class="line"><span class="string">clothing:</span></span><br><span class="line"><span class="string">  jacket: leather</span></span><br><span class="line"><span class="string">  trousers: denim</span></span><br><span class="line"><span class="string">age: 35</span></span><br><span class="line"><span class="string">eyes : brown</span></span><br><span class="line"><span class="string">beard: true</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line"></span><br><span class="line">viper.ReadConfig(bytes.NewBuffer(yamlExample))</span><br><span class="line"></span><br><span class="line">viper.Get(<span class="string">&quot;name&quot;</span>) <span class="comment">// 这里会得到 &quot;steve&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="覆盖设置"><a href="#覆盖设置" class="headerlink" title="覆盖设置"></a>覆盖设置</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">viper.Set(<span class="string">&quot;Verbose&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">viper.Set(<span class="string">&quot;LogFile&quot;</span>, LogFile)</span><br></pre></td></tr></table></figure>

<h4 id="注册和使用别名"><a href="#注册和使用别名" class="headerlink" title="注册和使用别名"></a>注册和使用别名</h4><p>别名允许多个键引用单个值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">viper.RegisterAlias(<span class="string">&quot;loud&quot;</span>, <span class="string">&quot;Verbose&quot;</span>)  <span class="comment">// 注册别名（此处loud和Verbose建立了别名）</span></span><br><span class="line"></span><br><span class="line">viper.Set(<span class="string">&quot;verbose&quot;</span>, <span class="literal">true</span>) <span class="comment">// 结果与下一行相同</span></span><br><span class="line">viper.Set(<span class="string">&quot;loud&quot;</span>, <span class="literal">true</span>)   <span class="comment">// 结果与前一行相同</span></span><br><span class="line"></span><br><span class="line">viper.GetBool(<span class="string">&quot;loud&quot;</span>) <span class="comment">// true</span></span><br><span class="line">viper.GetBool(<span class="string">&quot;verbose&quot;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="使用环境变量"><a href="#使用环境变量" class="headerlink" title="使用环境变量"></a><del>使用环境变量</del></h4><p>Viper完全支持环境变量。有五种方法可以帮助ENV协作：</p>
<ul>
<li><code>AutomaticEnv()</code></li>
<li><code>BinEnv(string...):error</code></li>
<li><code>SetEnvPrefix(string)</code></li>
<li><code>SetEnvKeyReplacer(string...) *strings.Replacer</code></li>
<li><code>AllowEmptyEnv(bool)</code></li>
</ul>
<p>使用ENV变量时要注意Viper将ENV变量视为区分大小写</p>
<h4 id="使用Flags"><a href="#使用Flags" class="headerlink" title="使用Flags"></a><del>使用Flags</del></h4><h4 id="远程Key-x2F-Value存储支持"><a href="#远程Key-x2F-Value存储支持" class="headerlink" title="远程Key&#x2F;Value存储支持"></a><del>远程Key&#x2F;Value存储支持</del></h4><h3 id="从Viper获取值"><a href="#从Viper获取值" class="headerlink" title="从Viper获取值"></a>从Viper获取值</h3><p>在Viper中，有几种方法可以根据值的类型获取值。</p>
<ul>
<li><code>Get(key string) : interface&#123;&#125;</code></li>
<li><code>GetBool(key string) : bool</code></li>
<li><code>GetFloat64(key string) : float64</code></li>
<li><code>GetInt(key string) : int</code></li>
<li><code>GetIntSlice(key string) : []int</code></li>
<li><code>GetString(key string) : string</code></li>
<li><code>GetStringMap(key string) : map[string]interface&#123;&#125;</code></li>
<li><code>GetStringMapString(key string) : map[string]string</code></li>
<li><code>GetStringSlice(key string) : []string</code></li>
<li><code>GetTime(key string) : time.Time</code></li>
<li><code>GetDuration(key string) : time.Duration</code></li>
</ul>
<p>每一个Get方法在找不到值的时候都会返回零值，为了检查给定的键是否存在，可以使用<code>IsSet(key string) : bool</code></p>
<h4 id="访问嵌套的键"><a href="#访问嵌套的键" class="headerlink" title="访问嵌套的键"></a>访问嵌套的键</h4><p>访问器方法也接受深度嵌套键的格式化路径</p>
<p>例如，加载下面的JSON文件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;host&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;address&quot;</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">        <span class="string">&quot;port&quot;</span>: <span class="number">5799</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;datastore&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;metric&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;host&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;port&quot;</span>: <span class="number">3099</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;warehouse&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;host&quot;</span>: <span class="string">&quot;198.0.0.1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;port&quot;</span>: <span class="number">2112</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Viper可以通过传入<code>.</code>的路径访问嵌套字段</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetString(<span class="string">&quot;datastore.metric.host&quot;</span>) <span class="comment">// (返回 &quot;127.0.0.1&quot;)</span></span><br></pre></td></tr></table></figure>

<p>​        Viper访问配置问价中的字段遵循一定的优先规则，因为Viper支持从多种配置来源，例如磁盘上的配置文件&gt;命令行标志位&gt;环境变量&gt;远程Key&#x2F;Value存储&gt;默认值，我们在查找一个配置的时候如果在当前配置源中没找到，就会继续从后续的配置源查找，直到找到为止。</p>
<p>​       如果父键被直接复制覆盖，那么其子键都将变成未定义状态，们被高优先级配置级别<strong>“遮蔽”</strong>（shadowed）了。</p>
<p>​       最后，如果存在与分隔的键路径匹配的键，则返回其值。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;datastore.metric.host&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;host&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;address&quot;</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">        <span class="string">&quot;port&quot;</span>: <span class="number">5799</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;datastore&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;metric&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;host&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;port&quot;</span>: <span class="number">3099</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;warehouse&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;host&quot;</span>: <span class="string">&quot;198.0.0.1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;port&quot;</span>: <span class="number">2112</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GetString(<span class="string">&quot;datastore.metric.host&quot;</span>) <span class="comment">// 返回 &quot;0.0.0.0&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="提取子树"><a href="#提取子树" class="headerlink" title="提取子树"></a>提取子树</h4><p>例如,<code>viper</code>实例现在代表了以下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app:</span></span><br><span class="line">  <span class="attr">cache1:</span></span><br><span class="line">    <span class="attr">max-items:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">item-size:</span> <span class="number">64</span></span><br><span class="line">  <span class="attr">cache2:</span></span><br><span class="line">    <span class="attr">max-items:</span> <span class="number">200</span></span><br><span class="line">    <span class="attr">item-size:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>调用<code>sub()</code>从Viper中提取子树</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subv := viper.Sub(<span class="string">&quot;app.cache1&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>此时<code>subv</code>代表以下配置</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">max-items:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">item-size:</span> <span class="number">64</span></span><br></pre></td></tr></table></figure>

<h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>可以将所有或特定值解析到结构体、map等，默认情况下使用<code>mapstructure</code>tag</p>
<ul>
<li><code>Unmarshal(rawval interface&#123;&#125;)error</code></li>
<li><code>Unmarshal(key string ,rawVal interface&#123;&#125;)error</code></li>
</ul>
<p>例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line">	Port <span class="type">int</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	PathMap <span class="type">string</span> <span class="string">`mapstructure:&quot;path_map&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> C config</span><br><span class="line"></span><br><span class="line">err := viper.Unmarshal(&amp;C)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	t.Fatalf(<span class="string">&quot;unable to decode into struct, %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要解析的键本身包含<code>.</code>的配置，需要修改分割符：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">v := viper.NewWithOptions(viper.KeyDelimiter(<span class="string">&quot;::&quot;</span>))</span><br><span class="line"></span><br><span class="line">v.SetDefault(<span class="string">&quot;chart::values&quot;</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">    <span class="string">&quot;ingress&quot;</span>: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">        <span class="string">&quot;annotations&quot;</span>: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">            <span class="string">&quot;traefik.frontend.rule.type&quot;</span>:                 <span class="string">&quot;PathPrefix&quot;</span>,</span><br><span class="line">            <span class="string">&quot;traefik.ingress.kubernetes.io/ssl-redirect&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line">	Chart <span class="keyword">struct</span>&#123;</span><br><span class="line">        Values <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> C config</span><br><span class="line"></span><br><span class="line">v.Unmarshal(&amp;C)</span><br></pre></td></tr></table></figure>

<p>viper还支持解析到嵌入的结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Example config:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">module:</span></span><br><span class="line"><span class="comment">    enabled: true</span></span><br><span class="line"><span class="comment">    token: 89h3f98hbwf987h3f98wenf89ehf</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line">	Module <span class="keyword">struct</span> &#123;</span><br><span class="line">		Enabled <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">		moduleConfig <span class="string">`mapstructure:&quot;,squash&quot;`</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// moduleConfig could be in a module specific package</span></span><br><span class="line"><span class="keyword">type</span> moduleConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	Token <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> C config</span><br><span class="line"></span><br><span class="line">err := viper.Unmarshal(&amp;C)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	t.Fatalf(<span class="string">&quot;unable to decode into struct, %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="序列化成字符串"><a href="#序列化成字符串" class="headerlink" title="序列化成字符串"></a>序列化成字符串</h4><p>你可以将自己喜欢的格式的序列化器与<code>AllSettings()</code>返回的配置一起使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    yaml <span class="string">&quot;gopkg.in/yaml.v2&quot;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">yamlStringSettings</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    c := viper.AllSettings()</span><br><span class="line">    bs, err := yaml.Marshal(c)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;unable to marshal config to YAML: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(bs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><p>go语言内置的<code>flag</code>包实现了命令行参数的解析</p>
<h3 id="os-Args"><a href="#os-Args" class="headerlink" title="os.Args"></a>os.Args</h3><p><code>os.Args</code>也可以获取命令行参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//os.Args demo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//os.Args是一个[]string</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> index, arg := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;args[%d]=%v\n&quot;</span>, index, arg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>os.Args</code>是一个存储命令函参数的字符串切片，它的第一个元素是执行文件的名称</p>
<h3 id="flag包基本使用"><a href="#flag包基本使用" class="headerlink" title="flag包基本使用"></a>flag包基本使用</h3><h3 id="flag参数类型"><a href="#flag参数类型" class="headerlink" title="flag参数类型"></a>flag参数类型</h3><p>flag包支持的命令行参数类型有<code>bool</code>、<code>int</code>、<code>int64</code>、<code>uint</code>、<code>uint64</code>、<code>float</code>、<code>float64</code>、<code>string</code>、<code>duration</code>。</p>
<table>
<thead>
<tr>
<th>flag参数</th>
<th>有效值</th>
</tr>
</thead>
<tbody><tr>
<td>字符串flag</td>
<td>合法字符串</td>
</tr>
<tr>
<td>整数flag</td>
<td>1234、0664、0x1234等类型，也可以是负数</td>
</tr>
<tr>
<td>浮点数flag</td>
<td>合法浮点数</td>
</tr>
<tr>
<td>布尔flag</td>
<td>1,0,t,g,T,F,true,false,TRUE,FALSE,True,False</td>
</tr>
<tr>
<td>时间段flag</td>
<td>任何合法的时间段字符串。如”300ms”、”-1.5h”、”2h45m”。合法的单位有”ns”、”us&#x2F;µs”、”ms”、”s”、”m”、”h”。</td>
</tr>
</tbody></table>
<h3 id="定义命令行参数"><a href="#定义命令行参数" class="headerlink" title="定义命令行参数"></a>定义命令行参数</h3><h4 id="flag-Type"><a href="#flag-Type" class="headerlink" title="flag.Type()"></a>flag.Type()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//flag.Tpye(flag名，默认值，帮助信息)*Type</span></span><br><span class="line">name :=flag.String(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;姓名&quot;</span>)</span><br><span class="line">age:=flag.Int(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>,<span class="string">&quot;年龄&quot;</span>)</span><br><span class="line">married:=flag.Bool(<span class="string">&quot;married&quot;</span>,<span class="literal">false</span>,<span class="string">&quot;婚否&quot;</span>)</span><br><span class="line">delay:=flag.Duration(<span class="string">&quot;d&quot;</span>,<span class="number">0</span>,<span class="string">&quot;时间间隔&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>需要注意的是此时<code>name</code>、<code>age</code>、<code>married</code>、<code>delay</code>均为对应类型的指针</p>
<h4 id="flag-TypeVar"><a href="#flag-TypeVar" class="headerlink" title="flag.TypeVar()"></a>flag.TypeVar()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//flag.TypeVar(Type指针,flag名,默认值,帮助信息)</span></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> married <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> delay time.Duration</span><br><span class="line">flag.StringVar (&amp;name,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;姓名&quot;</span>)</span><br><span class="line">flag.IntVar(&amp;age,<span class="string">&quot;age&quot;</span>,<span class="number">18</span>,<span class="string">&quot;年龄&quot;</span>)</span><br><span class="line">flag.BoolVar(&amp;married,<span class="string">&quot;married&quot;</span>,<span class="literal">false</span>,<span class="string">&quot;婚否&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="flage-Parse"><a href="#flage-Parse" class="headerlink" title="flage.Parse()"></a>flage.Parse()</h3><p>通过以上两种方法定义好命令行flag参数后，需要调用<code>flag.Parse()</code>来对命令行参数进行解析</p>
<p><strong>支持的命令行参数格式有以下几种：</strong></p>
<ul>
<li><code>-flag xxx</code>（使用空格，一个<code>-</code>符号）</li>
<li><code>--flag xxx</code>（使用空格，两个<code>-</code>符号</li>
<li><code>-flag=xxx</code>(使用等号，一个<code>-</code>符号)</li>
<li><code>--flag=xxx</code>（使用等号，两个<code>-</code>符号）</li>
</ul>
<p><strong>其中，布尔类型的参数必须使用等号的方式指定。</strong></p>
<p>flag解析在第一个非flag参数（单个<code>-</code>不是flag参数）之前停止，或者在终止符”-“之后停止</p>
<h3 id="flag其他函数"><a href="#flag其他函数" class="headerlink" title="flag其他函数"></a>flag其他函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag.Args()  <span class="comment">//返回命令行参数后的其他参数，以[]string类型</span></span><br><span class="line">flag.NArg()  <span class="comment">//返回命令行参数的其他参数个数</span></span><br><span class="line">flag.NFlag() <span class="comment">//返回使用的命令行参数个数</span></span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="命令行使用提示"><a href="#命令行使用提示" class="headerlink" title="命令行使用提示"></a>命令行使用提示</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./flag_demo -<span class="built_in">help</span></span></span><br><span class="line">Usage of ./flag_demo:</span><br><span class="line">  -age int</span><br><span class="line">        年龄 (default 18)</span><br><span class="line">  -d duration</span><br><span class="line">        时间间隔</span><br><span class="line">  -married</span><br><span class="line">        婚否</span><br><span class="line">  -name string</span><br><span class="line">        姓名 (default &quot;张三&quot;)</span><br></pre></td></tr></table></figure>

<p>正常使用命令行flag参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./flag_demo -name 沙河娜扎 --age 28 -married=<span class="literal">false</span> -d=1h30m</span></span><br><span class="line">沙河娜扎 28 false 1h30m0s</span><br><span class="line">[]</span><br><span class="line">0</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>使用非flag命令行参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./flag_demo a b c</span></span><br><span class="line">张三 18 false 0s</span><br><span class="line">[a b c]</span><br><span class="line">3</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><h3 id="和数组对比"><a href="#和数组对比" class="headerlink" title="和数组对比"></a>和数组对比</h3><ul>
<li>在go中，数组是<strong>值类型</strong>，赋值和函数传参都会复制整个数组数据。在数据量大的时候，如果每次传参都用数组，那么每次数组都要被复制一次，这样会消耗大量的内存。所以函数传参改为使用数组的指针。</li>
<li>但是传递指针有一个弊端。如果原数组的指针指向更改了，那么函数里面的指针指向都会跟着更改。</li>
<li>切片是一个<strong>引用类型</strong>。切片是一个拥有相同类型元素的<strong>可变长度</strong>的序列，是基于数组类型做的一层封装，能够自动扩容。</li>
</ul>
<h3 id="切片的数据结构"><a href="#切片的数据结构" class="headerlink" title="切片的数据结构"></a>切片的数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span>&#123;</span><br><span class="line">     array unsafe.Pointer</span><br><span class="line">     <span class="built_in">len</span> <span class="type">int</span> </span><br><span class="line">     <span class="built_in">cap</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>切片的结构体由3部分构成，Pointer是指向它底层数组的指针,len 是当前切片的长度,cap是当前切片的容量。cap&gt;&#x3D;len。</li>
<li>slice本身不是动态数组或者数组指针，它的内部实现是通过引用底层数组，设置相关的属性，将数据的读写读写操作限定在指定的区域。</li>
<li>对slice的修改实际上是修改slice的底层数组，而不是slice本身。</li>
</ol>
<h3 id="切片的扩容策略"><a href="#切片的扩容策略" class="headerlink" title="切片的扩容策略"></a>切片的扩容策略</h3><table>
<thead>
<tr>
<th>切片的容量</th>
<th>扩容策略</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;1024个元素</td>
<td>翻倍增加容量</td>
</tr>
<tr>
<td>&gt;1024个元素</td>
<td>每次增加原来的1&#x2F;4</td>
</tr>
</tbody></table>
<p>扩大的容量都是针对原来的容量而言，不是针对原来数组的长度而言的。</p>
<h3 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line"><span class="comment">//声明一个int类型的切片</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s =[]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">//声明一个int类型的切片并初始化</span></span><br></pre></td></tr></table></figure>

<h4 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h4><p>可以用<code>len()</code>函数求长度，用<code>cap()</code>函数求容量</p>
<h4 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h4><p>切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。</p>
<p>有两种形式：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式。</p>
<h5 id="简单切片表达式"><a href="#简单切片表达式" class="headerlink" title="简单切片表达式"></a><strong>简单切片表达式</strong></h5><p>切片的底层就是数组，所以可以基于数组通过切片表达式得到切片。切片表达式中的high和low表示一个索引的范围(左闭右开)长度len&#x3D;high-low，容量cap&#x3D;切片底层数组的容量-low。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:=[<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">s:=a[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment">//s=2,3 len(s)=2 cap(s)=4</span></span><br></pre></td></tr></table></figure>

<p>也可省略索引</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">2</span>:]  <span class="comment">// 等同于 a[2:len(a)]</span></span><br><span class="line">a[:<span class="number">3</span>]  <span class="comment">// 等同于 a[0:3]</span></span><br><span class="line">a[:]   <span class="comment">// 等同于 a[0:len(a)]</span></span><br></pre></td></tr></table></figure>

<ol>
<li>切片再切片的时候，high&lt;&#x3D;切片的容量cap(s)，而不是长度</li>
<li>low和high的值必须是非负的，可以用int类型的值表示</li>
<li>对数组或者字符串进行切片时，high&lt;&#x3D;len(a)</li>
<li>不满足上面三种条件的切片表达式都发生<code>panic</code></li>
</ol>
<h5 id="完整切片表达式"><a href="#完整切片表达式" class="headerlink" title="完整切片表达式"></a><strong>完整切片表达式</strong></h5><p>对于数组，指向数组的指针，或切片a支持（注意不能是字符串）完整切片表达式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[low:high:max]</span><br></pre></td></tr></table></figure>

<p>得到一个与a[low:high]相同类型、相同长度和元素的切片。还会将切片的容量设置为max-low。在完整切片表达式中只有low可以省略。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:=[<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">t:=a[<span class="number">1</span>:<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment">//t=2,3 len(t)=2 cap(t)=4</span></span><br></pre></td></tr></table></figure>

<p>完整切片需要满足<code>0&lt;=low&lt;=high&lt;=max&lt;=cap(a)</code>,其他条件和简单切片表达式相同</p>
<h4 id="使用make函数构造切片"><a href="#使用make函数构造切片" class="headerlink" title="使用make函数构造切片"></a>使用make函数构造切片</h4><p>我们可以根据已有的数组，字符串和切片得到一个新的切片，也可以用make函数凭空创造一个切片</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a:=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">2</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment">//创建int类型的切片 len(a)=2 cap(a)=10</span></span><br></pre></td></tr></table></figure>

<p>上面的代码给a分配了10个存储空间，但实际上只用了两个，所以len&#x3D;2，cap&#x3D;10。</p>
<h3 id="切片不能直接比较"><a href="#切片不能直接比较" class="headerlink" title="切片不能直接比较"></a>切片不能直接比较</h3><p>不能直接用<code>==</code>操作符来判断两个切片时候含有全部相同元素。切片只能和nil比较，nil的切片没有底层数组，长度和容量都是0。但长度和容量都是0的切片未必是nil</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="type">int</span>         <span class="comment">//len(s1)=0;cap(s1)=0;s1==nil</span></span><br><span class="line">s2 := []<span class="type">int</span>&#123;&#125;        <span class="comment">//len(s2)=0;cap(s2)=0;s2!=nil</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>) <span class="comment">//len(s3)=0;cap(s3)=0;s3!=nil</span></span><br></pre></td></tr></table></figure>

<p>所以要检查一个切片是否为空，要用len(s)&#x3D;&#x3D;0来判断，而不能用s&#x3D;&#x3D;nil来判断</p>
<h3 id="切片的赋值拷贝"><a href="#切片的赋值拷贝" class="headerlink" title="切片的赋值拷贝"></a>切片的赋值拷贝</h3><p>拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>) <span class="comment">//[0 0 0]</span></span><br><span class="line">	s2 := s1             <span class="comment">//将s1直接赋值给s2，s1和s2共用一个底层数组</span></span><br><span class="line">	s2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">	fmt.Println(s1) <span class="comment">//[100 0 0]</span></span><br><span class="line">	fmt.Println(s2) <span class="comment">//[100 0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="append添加元素"><a href="#append添加元素" class="headerlink" title="append添加元素"></a>append添加元素</h3><p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。</p>
<p><strong>append函数签名</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(slice []Type, elems ...Type)</span></span> []Type</span><br></pre></td></tr></table></figure>

<p> 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…用于把切片打散成一个个元素）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">1</span>)        <span class="comment">// [1]</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// [1 2 3 4]</span></span><br><span class="line">	s2 := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;  </span><br><span class="line">	s = <span class="built_in">append</span>(s, s2...)    <span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>var声明的零值切片可以直接在append中使用，无需初始化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>没有必要像下面的代码一样初始化一个切片再传入<code>append()</code>函数使用，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;&#125;  <span class="comment">// 没有必要初始化</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">make</span>([]<span class="type">int</span>)  <span class="comment">// 没有必要初始化</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>每个切片都指向一个底层数组，这个数组的容量够用就添加新元素。当底层数组不够用时，切片就会自动扩容，此时切片指向的底层数组就会更换，所以通常需要用原变量接收append函数的返回值。</p>
<h3 id="copy函数复制切片"><a href="#copy函数复制切片" class="headerlink" title="copy函数复制切片"></a>copy函数复制切片</h3><p>由于切片是引用类型，当使用赋值拷贝时，原切片和新切片都指向一个底层数组</p>
<p>go内置一个copy函数可以迅速将一个切片的数复制到另一个切片中，这两个切片指向不同的底层数组</p>
<p>copy函数签名</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copy</span><span class="params">(dst, src []Type)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>举个例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// copy()复制切片</span></span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">	<span class="built_in">copy</span>(c, a)     <span class="comment">//使用copy()函数将切片a中的元素复制到切片c</span></span><br><span class="line">	fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">	fmt.Println(c) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">	c[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">	fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">	fmt.Println(c) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到修改新切片的值，不会影响到原切片</p>
<h3 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h3><p>go语言中没有删除切片元素的专用方法，可以使用切片的特性来删除元素</p>
<p>如要从切片a中删除索引为index的元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="built_in">append</span>(a[:index],a[index+<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>



<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组从声明时就确定，可以修改数组成员，但不能修改数组的大小</p>
<h3 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名[元素数量]T</span><br></pre></td></tr></table></figure>

<h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3><h4 id="初始化列表设置数组元素"><a href="#初始化列表设置数组元素" class="headerlink" title="初始化列表设置数组元素"></a>初始化列表设置数组元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="type">int</span>                        <span class="comment">//数组会初始化为int类型的零值</span></span><br><span class="line">	<span class="keyword">var</span> numArray = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;                 <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line">	<span class="keyword">var</span> cityArray = [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125; <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line">	fmt.Println(testArray)                      <span class="comment">//[0 0 0]</span></span><br><span class="line">	fmt.Println(numArray)                       <span class="comment">//[1 2 0]</span></span><br><span class="line">	fmt.Println(cityArray)                      <span class="comment">//[北京 上海 深圳]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="让编译器自行推断数组长度"><a href="#让编译器自行推断数组长度" class="headerlink" title="让编译器自行推断数组长度"></a>让编译器自行推断数组长度</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> numArray = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> cityArray = [...]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;</span><br><span class="line">	fmt.Println(testArray)                          <span class="comment">//[0 0 0]</span></span><br><span class="line">	fmt.Println(numArray)                           <span class="comment">//[1 2]</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;type of numArray:%T\n&quot;</span>, numArray)   <span class="comment">//type of numArray:[2]int</span></span><br><span class="line">	fmt.Println(cityArray)                          <span class="comment">//[北京 上海 深圳]</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;type of cityArray:%T\n&quot;</span>, cityArray) <span class="comment">//type of cityArray:[3]string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用索引值初始化数组"><a href="#使用索引值初始化数组" class="headerlink" title="使用索引值初始化数组"></a>使用索引值初始化数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := [...]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">5</span>&#125;</span><br><span class="line">	fmt.Println(a)                  <span class="comment">// [0 1 0 5]</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, a) <span class="comment">//type of a:[4]int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>go语言支持多维数组</p>
<h3 id="多维数组的定义"><a href="#多维数组的定义" class="headerlink" title="多维数组的定义"></a>多维数组的定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := [<span class="number">3</span>][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">		&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(a) <span class="comment">//[[北京 上海] [广州 深圳] [成都 重庆]]</span></span><br><span class="line">	fmt.Println(a[<span class="number">2</span>][<span class="number">1</span>]) <span class="comment">//支持索引取值:重庆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意多维数组只有第一层可以用<code>...</code>来让编译器推到数组长度</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支持的写法</span></span><br><span class="line">a := [...][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">	&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不支持多维数组的内层使用...</span></span><br><span class="line">b := [<span class="number">3</span>][...]<span class="type">string</span>&#123;</span><br><span class="line">	&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Go的类型转换"><a href="#Go的类型转换" class="headerlink" title="Go的类型转换"></a>Go的类型转换</h2><h3 id="Go语言中类型推断的特性"><a href="#Go语言中类型推断的特性" class="headerlink" title="Go语言中类型推断的特性"></a>Go语言中类型推断的特性</h3><p>go是强类型语言，对变量使用简单的类型推断</p>
<p><strong>go语言还进禁用了不同类型的之间的转换（常量除外）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">a:=<span class="number">333</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int64</span></span><br><span class="line">b=a   <span class="comment">//会发生错误，因为a已经被推断为int类型，所以不能赋值给int64类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译器不会对变量标识符引用的值进行强制类型转换</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a:=<span class="number">1.1</span></span><br><span class="line">b:=a+<span class="number">1</span>    <span class="comment">//代码正确a被推断为浮点数，1会被转换为浮点数和a的值相加</span></span><br><span class="line"></span><br><span class="line">a:=<span class="number">1</span></span><br><span class="line">b:=a+<span class="number">1.1</span> <span class="comment">//代码错误，a已经被推断为整数，不能将a转化成浮点数，相加失败，编译器报错，constant 1.1 truncated to integer</span></span><br><span class="line"></span><br><span class="line">a:=<span class="number">1</span></span><br><span class="line">b:=<span class="number">1.1</span></span><br><span class="line">c:=a+b <span class="comment">//与上面的例子犯了相同的错误</span></span><br></pre></td></tr></table></figure>



<h1 id="Effective-Go"><a href="#Effective-Go" class="headerlink" title="Effective Go"></a>Effective Go</h1><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><h3 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h3><p><strong>getter 是一种获得属性值的方法，setter是一种设置属性值的方法</strong></p>
<p>Go 并不对获取器（getter）和设置器（setter）提供自动支持。应当自己提供获取器和设置器。但把 Get 放到获取器的名字中，既不复合习惯，也没有必要。假设有一个 owner （小写，未导出）的字段，其获取器的名字应该为 Owner（大写，可导出）而非 GetOwner。</p>
<p>若要提供设置器的方法，SetOwner 是个不错的选择。两个命名都看起来很合理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">owner := obj.Owner()</span><br><span class="line"><span class="keyword">if</span> owner!=user&#123;</span><br><span class="line"> 	obj.SetOwner(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口名"><a href="#接口名" class="headerlink" title="接口名"></a>接口名</h3><p>按照约定，只包含一个方法的接口应当以该方法的名称加上 <code>-er</code> 后缀来命名，如 Reader、Writer、Formatter、CloseNotifier 等。</p>
<p>Read、Write、Close、Flush、 String 等都具有典型的签名和意义。为避免冲突，请不要用这些名称为你的方法命名， 除非你明确知道它们的签名和意义相同。反之，若你的类型实现了的方法， 与一个众所周知的类型的方法拥有相同的含义，那就使用相同的命名。 例如将字符串转换方法命名为 String 而非 ToString。</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>可以使用 range 子句实现数组、切片、字符串或者映射的遍历，或从 channel 中读取消息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key,value := <span class="keyword">range</span> oldMap&#123;</span><br><span class="line">	newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若只需要遍历键或者下标</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> m &#123;</span><br><span class="line">	<span class="keyword">if</span> key.expired()&#123;</span><br><span class="line">		<span class="built_in">delete</span>(m,key)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若只需要遍历第二个值，需要使用空白标识符</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> array &#123;</span><br><span class="line">		sum += value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于字符串，range 能提供更多遍历。它能够通过解析 UTF-8，将每个独立的 Unicode 码点分离出来。错误的编码将占用一个rune，并用  <code>U+FFFD</code> 替代。（rune是 Go 对单个 Unicode 码点的称谓）。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> pos, char := <span class="keyword">range</span> <span class="string">&quot;日本 \ x80 語&quot;</span> &#123; <span class="comment">// \x80 is an illegal UTF-8 encoding</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;character %#U starts at byte position %d\n&quot;</span>, char, pos)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">character U+65E5 &#x27;日&#x27; starts at byte position 0</span><br><span class="line">character U+672C &#x27;本&#x27; starts at byte position 3</span><br><span class="line">character U+FFFD &#x27;�&#x27; starts at byte position 6</span><br><span class="line">character U+8A9E &#x27;語&#x27; starts at byte position 7</span><br></pre></td></tr></table></figure>

<p>最后，Go没有逗号操作符，++和–为语句而非表达式。因此，如果想要在 for 中使用多个变量，应采用平行赋值的方式（因为它会拒绝 ++ 和 –）。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reverse a</span></span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(a)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">	a[i], a[j] = a[j], a[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p>switch 并不会自动下溯，但 case 可以通过逗号分割来列举相同的处理条件</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shouldEscape</span><span class="params">(c <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> c &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;&amp;&#x27;</span>, <span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch 可用于判断接口变量的动态类型。如 类型选择 通过圆括号中的关键字 <code>type</code> 使用类型断言语法。若 switch 在表达式中声明了一个变量，那么该变量的每个子句中都将有该变量对应的类型。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span>&#123;&#125; </span><br><span class="line">t = functionOfSomeType()   <span class="comment">//声明了新变量 t ， 作用域仅限于 switch 语句块内部</span></span><br><span class="line"><span class="keyword">switch</span> t := t.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	fmt.Printf(<span class="string">&quot;unexpected type %T&quot;</span>, t)       <span class="comment">// %T 输出 t 是什么类型</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">	fmt.Printf(<span class="string">&quot;boolean %t\n&quot;</span>, t)             <span class="comment">// t 是 bool 类型</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">	fmt.Printf(<span class="string">&quot;integer %d\n&quot;</span>, t)             <span class="comment">// t 是 int 类型</span></span><br><span class="line"><span class="keyword">case</span> *<span class="type">bool</span>:</span><br><span class="line">	fmt.Printf(<span class="string">&quot;pointer to boolean %t\n&quot;</span>, *t) <span class="comment">// t 是 *bool 类型</span></span><br><span class="line"><span class="keyword">case</span> *<span class="type">int</span>:</span><br><span class="line">	fmt.Printf(<span class="string">&quot;pointer to integer %d\n&quot;</span>, *t) <span class="comment">// t 是 *int 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="可命名结果形参"><a href="#可命名结果形参" class="headerlink" title="可命名结果形参"></a>可命名结果形参</h3><p>Go 函数的返回值或结果“形参”可被命名，并作为常规变量使用，就像传入的形参一样。命名后，一旦该函数开始执行，它们就会被初始化为与其类型响应的<strong>零值</strong>；<strong>若该函数执行了一条不带实参的 return 语句，则结果形参的当前值将被返回。</strong></p>
<p>此名称不是强制性的，但是能让代码更加简短清晰。可以把它们看作文档的一部分，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextInt</span><span class="params">(b []<span class="type">byte</span>, pos <span class="type">int</span>)</span></span> (value, nextPos <span class="type">int</span>) </span><br></pre></td></tr></table></figure>

<p>命名了 nextInt 的结果，那么它返回的 int 就值如其意了</p>
<p>由于被命名的结果已经初始化，且已经关联至无参数的返回，它们就能让代码简单而清晰。 下面的 io.ReadFull 就是个很好的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFull</span><span class="params">(r Reader, buf []<span class="type">byte</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(buf) &gt; <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> nr <span class="type">int</span></span><br><span class="line">		nr, err = r.Read(buf)</span><br><span class="line">		n += nr</span><br><span class="line">		buf = buf[nr:]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>被推迟函数的实参（如果该函数为方法则还包括接收者）在推迟执行时就会被求值，而不是在调用执行时才求值。这样不仅无需担心变量值在函数执行时被改变，同时还意味着单个被推迟的调用可推迟多个函数的执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被推迟的函数按后进先出（LIFO）的顺序执行，因此以上代码在函数返回时会打印 4 3 2 1 0。</p>
<p>进：0 1 2 3 4 </p>
<p>出：4 3 2 1 0</p>
<p><strong>用程序跟踪函数的执行</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;entering:&quot;</span>, s)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">un</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;leaving:&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> un(trace(<span class="string">&quot;a&quot;</span>)) <span class="comment">//函数执行到这一步时, trace(&quot;a&quot;)就已经被执行了</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;in a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> un(trace(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;in b&quot;</span>)</span><br><span class="line">	a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">entering: b</span><br><span class="line">in b</span><br><span class="line">entering: a</span><br><span class="line">in a</span><br><span class="line">leaving: a</span><br><span class="line">leaving: b</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="new-分配"><a href="#new-分配" class="headerlink" title="new 分配"></a>new 分配</h3><p>Go 提供了两种分配原语，即内建函数 <code>new</code> 和 <code>make</code> 。它们所做的事情不同，所应用的类型也不同。</p>
<p>先看 <code>new</code> 。这是个用来分配内存的内建函数，但与其他语言中的同名函数不同，它不会<strong>初始化内存</strong>，只会<strong>将内存置零</strong>。也就是说，<code>new(T)</code> 会为类型 <code>T</code> 的的新项分配已置零的内存空间，并返回它的地址，也就是一个类型为 <code>*T</code> 的值。用 Go 的术语来说，它返回一个指针，该指针指向新分配的，类型为 <code>T</code> 的零值。</p>
<p>既然 <code>new</code> 返回的内存已置零，那么设计数据结构时，每种类型的零值就不必进一步初始化了，这意味着该数据结构的使用者只需使用 <code>new</code> 创建一个新的对象就能使用了。</p>
<p> 例如，<code>bytes.Buffer</code> 的文档中提到的“零值的 Buffer 就是已准备就绪的缓冲区。”同样，<code>sync.Mutex</code> 并没有显式的构造函数或 init 方法，而是零值的 <code>sync.Mutex</code> 就已经被定义为已解锁的互斥锁。</p>
<p>“零值属性”是传递性的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SyncedBuffer strcut&#123;</span><br><span class="line">	lock sync.Mutex</span><br><span class="line">	buffer bytes.Buffer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SyncedBuffer 类型的值也是在声明时就分配好内存就绪了。后续代码中， p 和 v 无需进一步处理即可正常使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(SyncedBuffer)  <span class="comment">// type *SyncedBuffer</span></span><br><span class="line"><span class="keyword">var</span> v SyncedBuffer      <span class="comment">// type  SyncedBuffer</span></span><br></pre></td></tr></table></figure>

<h3 id="构造函数与复合字面量"><a href="#构造函数与复合字面量" class="headerlink" title="构造函数与复合字面量"></a>构造函数与复合字面量</h3><p>有时候置零还不够好，这时候就需要一个构造函数，如来自 os 包中的这段代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="type">int</span>, name <span class="type">string</span>)</span></span> *File &#123;</span><br><span class="line">	<span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	f := <span class="built_in">new</span>(File)</span><br><span class="line">	f.fd = fd</span><br><span class="line">	f.name = name</span><br><span class="line">	f.dirinfo = <span class="literal">nil</span></span><br><span class="line">	f.nepipe = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这段代码过于冗长，可以通过复合字面量来简化它</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="type">int</span>, name <span class="type">string</span>)</span></span> *File &#123;</span><br><span class="line">	<span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	f := File&#123;fd, name, <span class="literal">nil</span>, <span class="number">0</span>&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意返回一个局部变量的地址完全没有问题。该局部变量对应的数据在函数返回后依然有效。实际上每当获取一个复合字面量的地址时，都将为一个新的实例分配内存，一次可以将上面的最后两行代码合并：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;File&#123;fd, name, <span class="literal">nil</span>, <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<p>复合字面量的字段必须按照顺序全部列出。但如果以 kv 对的形式显示地标出元素，初始化字段是就可以按任何顺序出现，未给出地字段值将被赋予零值。因此可以用如下形式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;File&#123;fd: fd, name: name&#125;</span><br></pre></td></tr></table></figure>

<p> 若复合字面量不包括任何字段，它将创建该类型的零值。即 <code>new(File)</code> 和 <code>&amp;File&#123;&#125;</code> 是等价的。</p>
<p>复合字面量同样可以用于创建数组、切片以及映射，字段标签是索引还是键则视情况而定。</p>
<p> 在下例初始化过程中，无论 Enone、Eio 和 Einval 的值是什么，只要它们的标签不同就行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Enone  = <span class="number">0</span></span><br><span class="line">	Eio    = <span class="number">1</span></span><br><span class="line">	Einval = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := [...]<span class="type">string</span>&#123;Enone: <span class="string">&quot;no error&quot;</span>, Eio: <span class="string">&quot;Eio&quot;</span>, Einval: <span class="string">&quot;invalid argument&quot;</span>&#125;</span><br><span class="line">	s := []<span class="type">string</span>&#123;Enone: <span class="string">&quot;no error&quot;</span>, Eio: <span class="string">&quot;Eio&quot;</span>, Einval: <span class="string">&quot;invalid argument&quot;</span>&#125;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;Enone: <span class="string">&quot;no error&quot;</span>, Eio: <span class="string">&quot;Eio&quot;</span>, Einval: <span class="string">&quot;invalid argument&quot;</span>&#125;</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">	fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="make分配"><a href="#make分配" class="headerlink" title="make分配"></a>make分配</h3><p>内建函数 <code>make(T, args)</code> 的目的不同于 <code>new(T)</code> 。它只会用于<strong>创建切片、映射和channel</strong>，并返回类型为T（而非*T）的一个已初始化（而非置零的值）。出现这种差异的原因在于，这三种类型本质上 为引用数据类型，它们在使用前必须初始化。例如，切片是一个具有三项内容的描述符，包含一个指向（数组内部）数据的指针、长度以及容量，在这三项被初始化之前，该切片为nil。对于切片、映射和信道，make用于初始化其内部的数据结构并准备好将要使用的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>会分配一个具有100个int的数组空间，接着创建一个长度为10，容量为100并指向该数组中前十个元素的切片结构。（生成切片时，其容量可以省略）。与此相反，new([]int)会返回一个指向新分配的，已置零的切片结构，即一个指向 <code>nil</code> 切片值得指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *[]<span class="type">int</span> = <span class="built_in">new</span>([]<span class="type">int</span>)       <span class="comment">// allocates slice structure; *p == nil; rarely useful</span></span><br><span class="line"><span class="keyword">var</span> v  []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">100</span>) <span class="comment">// the slice v now refers to a new array of 100 ints</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unnecessarily complex:</span></span><br><span class="line"><span class="keyword">var</span> p *[]<span class="type">int</span> = <span class="built_in">new</span>([]<span class="type">int</span>)</span><br><span class="line">*p = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Idiomatic:</span></span><br><span class="line">v := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>make只适用于映射、切片和channel且不返回指针。若要获取明确的指针，需使用 new 分配内存或显示地获取一个变量的地址。</p>
<ul>
<li>make创建的映射、切片和channel是可以直接使用的</li>
<li>new创建的映射、切片和channel需要进一步分配和初始化底层数组</li>
</ul>
<h3 id="二维切片"><a href="#二维切片" class="headerlink" title="二维切片"></a>二维切片</h3><p>有时候必须分配一个二维数组，例如在处理像素的扫描行时，就会发生这种情况。有两种方式来达到这个目的。一种就是独立地分配每一个切片；另一种就是只分配一个数组，将各个切片都指向它。</p>
<p>若切片会增长或收缩，就应该通过独立分配来避免覆盖下一行；若不会，用单次分配来构造对象会更高效。</p>
<ul>
<li><p>方式一</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配顶层切片。</span></span><br><span class="line">picture := <span class="built_in">make</span>([][]<span class="type">uint8</span>, YSize) <span class="comment">// 每 y 个单元一行。</span></span><br><span class="line"><span class="comment">// 遍历行，为每一行都分配切片</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> picture &#123;</span><br><span class="line">	picture[i] = <span class="built_in">make</span>([]<span class="type">uint8</span>, XSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配顶层切片，和前面一样。</span></span><br><span class="line">picture := <span class="built_in">make</span>([][]<span class="type">uint8</span>, YSize) <span class="comment">// 每 y 个单元一行。</span></span><br><span class="line"><span class="comment">// 分配一个大的切片来保存所有像素</span></span><br><span class="line">pixels := <span class="built_in">make</span>([]<span class="type">uint8</span>, XSize*YSize) <span class="comment">// 拥有类型 []uint8，尽管图片是 [][]uint8.</span></span><br><span class="line"><span class="comment">// 遍历行，从剩余像素切片的前面切出每行来。</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> picture &#123;</span><br><span class="line">	picture[i], pixels = pixels[:XSize], pixels[XSize:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>map</p>
<p>如果尝试通过映射中不存在的键来取值，就会返回该映射中项的类型对应的零值。有时候需要区分某项是不存在还是其值为零值。如对一个值本应为零的条目，也可能是由于不存在该想而得到零值。可以使用螽赋值的形式来分辨这种情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> seconds <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> ok <span class="type">bool</span> </span><br><span class="line">seconds, ok = timeZone[tz]</span><br></pre></td></tr></table></figure>

<p>若 tz 存在， seconds 就会被赋予适当的值，且 ok 会被置为 true； 若不存在，seconds 则会被置为零，而 ok 会被置为 false。</p>
<p>若仅需判断映射中是否存在某项而不关心实际的值，可使用空白标识符 （_）来代替该值的一般变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, present := timeZone[tz]</span><br></pre></td></tr></table></figure>

<h3 id="Print"><a href="#Print" class="headerlink" title="Print"></a>Print</h3><p>像 %d 这样的数值格式并不接受表示符号或大小的标记， 打印例程会根据实参的类型来决定这些属性。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">uint64</span> = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d %x; %d %x\n&quot;</span>, x, x, <span class="type">int64</span>(x), <span class="type">int64</span>(x))</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18446744073709551615 ffffffffffffffff; -1 -1</span><br></pre></td></tr></table></figure>

<p>如果只想要默认的转换，如使用十进制的整数，可以使用通用的格式 %v （对应“值”）；其结果与 Print 和 Println 的输出完全相同。此外这种格式还能打印任意值，包括数据、结构体和映射。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, timeZone)  <span class="comment">// or just fmt.Println(timeZone)</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[CST:-21600 PST:-28800 EST:-18000 UTC:0 MST:-25200]</span><br></pre></td></tr></table></figure>

<p>映射中的键可能按任意顺序输出。当打印结构体是，改进的格式 <code>%+v</code> 会为结构体的每个字段添上字段名，另一种格式 <code>%#v</code> 将顽强按照 Go 的语法打印值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="type">int</span></span><br><span class="line">	b <span class="type">float64</span></span><br><span class="line">	c <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">t := &amp;T&#123; <span class="number">7</span>, <span class="number">-2.35</span>, <span class="string">&quot;abc\tdef&quot;</span> &#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, t)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, t)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, t)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, timeZone)</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;&#123;<span class="number">7</span> <span class="number">-2.35</span> abc   def&#125;</span><br><span class="line">&amp;&#123;a:<span class="number">7</span> b:<span class="number">-2.35</span> c:abc     def&#125;</span><br><span class="line">&amp;main.T&#123;a:<span class="number">7</span>, b:<span class="number">-2.35</span>, c:<span class="string">&quot;abc\tdef&quot;</span>&#125;</span><br><span class="line"><span class="keyword">map</span>[<span class="type">string</span>] <span class="type">int</span>&#123;<span class="string">&quot;CST&quot;</span>:<span class="number">-21600</span>, <span class="string">&quot;PST&quot;</span>:<span class="number">-28800</span>, <span class="string">&quot;EST&quot;</span>:<span class="number">-18000</span>, <span class="string">&quot;UTC&quot;</span>:<span class="number">0</span>, <span class="string">&quot;MST&quot;</span>:<span class="number">-25200</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果想控制自定义类型的默认格式，只需要为该类型定义一个具有 String()string 签名的方法。例如下面的类型 T 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d/%g/%q&quot;</span>, t.a, t.b, t.c)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, t)</span><br></pre></td></tr></table></figure>

<p>输出 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7/-2.35/&quot;abc\tdef&quot;</span><br></pre></td></tr></table></figure>

<p>如果需要向指向 T 的指针那样打印类型 T 的值， String 的接收者就必须是值类型的；上面的例子中接收者是一个指针，因为这对于结构来说更高效而通用。</p>
<p>这是 String 方法也可以调用 Sprintf 。注意不要通过调用 Sprintf 来构造 String 方法，因为这样会无限递归 String 方法。当 Sprintf 试图将一个接收者以字符串形式打印输出，而在此过程中反过来又调用了 Sprintf 时，这种情况就会出现，这是一个很常见的错误。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyString)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;MyString=%s&quot;</span>, m) <span class="comment">// Error: will recur forever.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fmt.Sprintf</code> 中使用 <code>%s</code> 格式化一个自定义类型时，会调用该类型的 <code>String()</code> 方法。这个例子中 <code>String </code>方法内部又调用了 <code>fmt.Sprintf</code> ，这样就导致了无限递归的错误。</p>
<p>要解决这个问题也很简单：将该实参转换为基本的字符串类型，这时候调用的是内建函数<code>string</code>，一次不会发生无限递归。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyString)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;MyString=%s&quot;</span>, <span class="type">string</span>(m)) <span class="comment">// OK: note conversion.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>Go 中的常量就是不变量。它们在编译时创建，即便它们可能是函数中定义的局部变量。 常量只能是数字、字符（符文）、字符串或布尔值。由于编译时的限制， 定义它们的表达式必须也是可被编译器求值的常量表达式。例如 1&lt;&lt;3 就是一个常量表达式，而 math.Sin(math.Pi&#x2F;4) 则不是，因为对 math.Sin 的函数调用在运行时才会发生。</p>
<p>在 Go 中，枚举常量使用枚举器 iota 创建。由于 iota 可为表达式的一部分，而表达式可以被隐式地重复，这样也就更容易构建复杂的值的集合了。</p>
<p>例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteSize <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// 通过赋予空白标识符来忽略第一个值</span></span><br><span class="line">    _           = <span class="literal">iota</span> <span class="comment">// ignore first value by assigning to blank identifier</span></span><br><span class="line">    KB ByteSize = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    MB</span><br><span class="line">    GB</span><br><span class="line">    TB</span><br><span class="line">    PB</span><br><span class="line">    EB</span><br><span class="line">    ZB</span><br><span class="line">    YB</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>可以这样使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b ByteSize)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> b &gt;= YB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fYB&quot;</span>, b/YB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= ZB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fZB&quot;</span>, b/ZB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= EB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fEB&quot;</span>, b/EB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= PB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fPB&quot;</span>, b/PB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= TB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fTB&quot;</span>, b/TB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= GB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fGB&quot;</span>, b/GB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= MB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fMB&quot;</span>, b/MB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= KB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fKB&quot;</span>, b/KB)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fB&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表达式 YB 会打印出 1.00YB，而 ByteSize(1e13) 则会打印出 9.09TB。</p>
<p>在这里用 Sprintf 实现 ByteSize 的 String 方法很安全（不会无限递归），它以 %f 调用了 Sprintf，它并不是一种字符串格式：Sprintf 只会在它需要字符串时才调用 String 方法，而 %f 需要一个浮点数值。</p>
<h3 id="init-函数"><a href="#init-函数" class="headerlink" title="init 函数"></a>init 函数</h3><p>每个源文件都可以通过当以自己的无参数 init 函数来设置一些必要的状态。一个包可以有多个 init 函数。一个源文件可以有多个 init 函数。它的结束就意味着初始化结束，只有该包中的所有变量都通过它们的初始化器求值后 init 才会被调用，</p>
<p>除了那些不能被表示成声明的初始化外，init 函数还常被用在程序真正开始执行前，检验或校正程序的状态。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> user == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;$USER not set&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> home == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		home = <span class="string">&quot;/home/&quot;</span> + user</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gopath == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		gopath = home + <span class="string">&quot;/go&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// gopath may be overridden by --gopath flag on command line.</span></span><br><span class="line">	flag.StringVar(&amp;gopath, <span class="string">&quot;gopath&quot;</span>, gopath, <span class="string">&quot;override default GOPATH&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行顺序</strong></p>
<ul>
<li>一个文件中的多个 init 函数执行顺序与其<strong>定义顺序</strong>一致</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;init a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;init b&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;init c&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">init a</span><br><span class="line">init b</span><br><span class="line">init c</span><br><span class="line">main</span><br></pre></td></tr></table></figure>

<ul>
<li>一个包中的多个 init 函数的执行顺序根据<strong>文件名的字典序</strong>来确定</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;init a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;init b&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;init c&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;init main&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go build &amp;&amp; ./main</span><br><span class="line">init a</span><br><span class="line">init b</span><br><span class="line">init c</span><br><span class="line">init main</span><br><span class="line">main</span><br></pre></td></tr></table></figure>

<ul>
<li>不同的包，不相互依赖，按照 main 包中导入顺序调用包的 init 函数，最后再调用 main 包的 init 函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a 包</span></span><br><span class="line"><span class="comment">// a.go</span></span><br><span class="line"><span class="keyword">package</span> a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;init a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b 包</span></span><br><span class="line"><span class="comment">// b.go</span></span><br><span class="line"><span class="keyword">package</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;init b&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 包</span></span><br><span class="line"><span class="comment">// c.go</span></span><br><span class="line"><span class="keyword">package</span> c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;init c&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 包</span></span><br><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	_ <span class="string">&quot;main/a&quot;</span></span><br><span class="line">	_ <span class="string">&quot;main/b&quot;</span></span><br><span class="line">	_ <span class="string">&quot;main/c&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;init main&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go build &amp;&amp; ./main</span><br><span class="line">init a</span><br><span class="line">init b</span><br><span class="line">init c</span><br><span class="line">init main</span><br><span class="line">main</span><br></pre></td></tr></table></figure>

<ul>
<li>不同的包，存在相互依赖</li>
</ul>
<p>假设有包 a，b 和 c，main 包，main import a ，a import b，b import c，即依赖关系为 main &gt; a &gt; b &gt; c，按照包导入的依赖关系决定执行顺序。 调用顺序为最后被依赖的最先被初始化，如导入顺序 main &gt; a &gt; b &gt; c，则初始化顺序为 c &gt; b &gt; a &gt; main，依次执行对应的 init 方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.go</span></span><br><span class="line"><span class="keyword">package</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;main/b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;init a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.go</span></span><br><span class="line"><span class="keyword">package</span> b</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;main/c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;init b&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c.go</span></span><br><span class="line"><span class="keyword">package</span> c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;init c&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	_ <span class="string">&quot;main/a&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;init main&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go build &amp;&amp; ./main</span><br><span class="line">init c</span><br><span class="line">init b</span><br><span class="line">init a</span><br><span class="line">init main</span><br><span class="line">main</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>指针 vs. 值</p>
<p>如 <code>Bytesize</code>我们可以为任何已命名的类型（除了指针或接口）定义方法；接收者不一定为结构体。</p>
<p>将函数修改为与标准 Write 类似的方法，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ByteSlice)</span></span> Write(data []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	slice := *p</span><br><span class="line">	<span class="comment">// Again as above.</span></span><br><span class="line">	*p = slice</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(data), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么类型 <code>*ByteSlice</code> 就满足了标准的 <code>io.Writer</code> 接口，这将非常使用。例如，可以通过打印将内容写入：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b ByteSlice</span><br><span class="line">fmt.Fprintf(&amp;b, <span class="string">&quot;This hour has %d days\n&quot;</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<p>以指针或值为接收者的区别在于：值方法可通过指针和值调用， 而指针方法只能通过指针来调用。</p>
<p>之所以有这条规则是因为指针方法可以修改接收者；通过值调用它们会导致方法接收到该值的副本，因此任何修改都将被丢弃，因此该语言不允许这种错误。</p>
<p>注意有一个例外：当这个值是可寻址的，那么该语言就会自动插入取值操作符来对付一般的通过值调用的指针方法。在我们的例子中，变量b是可寻址的，因此只需要通过 <code>b.Write</code> 来调用它的 <code>Write</code> 方法，编译器会将它重写为 <code>(&amp;b).Write</code></p>
<h2 id="接口和其他类型"><a href="#接口和其他类型" class="headerlink" title="接口和其他类型"></a>接口和其他类型</h2><p>Go 中的接口为指定对象的行为提供了一种方法：如果某样东西能做这个，那么他就可以被用在这里。</p>
<p>有很多这样简单的例子：通过实现 String 方法，可以自定义打印函数；通过实现 Write 方法，Fprint 能对任何对象产生输出。在 Go 代码中，仅包含一两种方法的接口很常见，且其名称通常来自于实现它的方法，例如 <code>io.Writer</code> 就是实现了 Write 的一类对象。</p>
<p>每种类型都能实现多个接口。例如一个实现了 sort.Interface 接口的集合就可通过 sort 包中的函数进行排序。该接口包括 <code>Len()</code> 、<code>Less(i,j int)bool</code> 、<code>Swap(i,j int)</code> 方法。另外该集合还可以有一个自定义的格式化器。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Sequence []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Methods required by sort.Interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s[i] &lt; s[j]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">    s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Method for printing - sorts the elements before printing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    sort.Sort(s)</span><br><span class="line">    str := <span class="string">&quot;[&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i, elem := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">            str += <span class="string">&quot; &quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        str += fmt.Sprint(elem)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str + <span class="string">&quot;]&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>Sequence 的 String 方法重新实现了 Sprint 为切片实现的功能。若我们在调用 Sprint 之前将 Sequence 转换为的 []int ，就能共享已经实现的功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	sort.Sort(s)</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprint([]<span class="type">int</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法时通过类型转换技术，在 String 方法中安全调用 Sprintf 的另一个例子。若我们忽略类型名的话，这两种类型（Sequence和[]int）其实是相同的，因此在二者之间进行转换是合法的。转换过程并不会创建新值，只是暂时让现有的值看起来有个新类型而已。（有些合法转换会创建新值，如从整型转换为浮点型等）</p>
<p>在 Go 程序中，为访问不同的方法集而进行类型转换的情况非常常见。例如，可以使用现有的 sort.IntSlice 类型来简化上面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Sequence []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Method for printing - sorts the elements before printing</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	sort.IntSlice(s).Sort()</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprint([]<span class="type">int</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，不必让 Sequence 实现多个接口（排序和打印），我们可以通过将数据条目转换为多种类型（Sequence、sort.IntSlice 和 []int）来使用相应的功能，每次转换都完成一部分工作。</p>
<h3 id="接口转换与类型断言"><a href="#接口转换与类型断言" class="headerlink" title="接口转换与类型断言"></a>接口转换与类型断言</h3><p>类型选择 是类型转换的一种形式：它接受一个接口，在选择（swtich）中根据判断选择对应的情况（case），并在某种意义上将其转换为该种类型。以下代码为 <code>fmt.Printf</code> 通过类型选择将值转换为字符串的简化版。若它已经为字符串，我们需要该接口中实际的字符串值；若它有 String 方法，我们则需要调用该方法所得的结果</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">	String() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 调用者提供的值。</span></span><br><span class="line"><span class="keyword">switch</span> str := value.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line"><span class="keyword">case</span> Stringer:</span><br><span class="line">	<span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种情况获取具体的值，第二种将接口转换为另一个接口。这种方式对于混合类型来说非常完美。</p>
<p>如果我们只关心一种类型呢？如果我们知道该值拥有一个 string 而想要提取它呢？只需要一种情况的了类型选择就行，但它需要类型断言。类型断言接受一个接口值，并从中提取指定的明确类型的值。其语法借鉴自类型选择开口的子句，但它需要一个具体的类型，而非 <code>type</code> 关键字：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value.(typeName)</span><br></pre></td></tr></table></figure>

<p>其结果是拥有静态类型 <code>typeName</code> 的新值。该类型必须为该接口所拥有的具体类型，或者该值可转换成的第二种接口类型，要提取我们知道在该值中的字符串，可以这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str := value.(<span class="type">string</span>)</span><br></pre></td></tr></table></figure>

<p>但若他所转换的值中不包含字符串，该程序就会以运行时错误崩溃，为避免这种情况，需要使用”, ok“ 来安全地测试它是不是字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str, ok := value.(<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串值为 %q\n&quot;</span>, str)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;该值非字符串\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若类型断言失败，str 将继续存在且为字符串类型，但它将拥有零值，即空字符串。</p>
<p>作为对这种能力的说明，这里有个 if-else 语句，它等价于本节开头的类型选择。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> str, ok := value.(<span class="type">string</span>); ok &#123;</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> str, ok := value.(Stringer); ok &#123;</span><br><span class="line">	<span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通用性"><a href="#通用性" class="headerlink" title="通用性"></a>通用性</h3><p>若某种现有的类型实现了一个接口，且除此之外并无可导出的方法，则该类型本身就无需导出。仅导出接口能让我们更专注于其行为而非实现，其他属性不同的实现则能反映该原始类型的行为。这也能避免为每个通用接口的实例重复编写文档。</p>
<p>在这种情况下，构造函数应当返回一个接口值而非实现的类型。例如在 <code>hash</code> 库中， <code>rs32.NewIEEE</code> 和 <code>adler32.New</code> 都返回接口类型 <code>hash.Hash32</code> 。要在 Go 程序中使用 Adler-32 算法替代 CRC-32，只需修改构造函数调用即可，其余代码则不受算法改变的影响。</p>
<p>同样的方式能将 crypto 包中多种联系在一起的流密码算法与块密码算法分开。 crypto&#x2F;cipher 包中的 Block 接口指定了块密码算法的行为， 它为单独的数据块提供加密。接着，和 bufio 包类似，任何实现了该接口的密码包都能被用于构造以 Stream 为接口表示的流密码，而无需知道块加密的细节。</p>
<p><code>crypto/cipher</code> 接口看起来就像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">interface</span> &#123;</span><br><span class="line">	BlockSize() <span class="type">int</span></span><br><span class="line">	Encrypt(src, dst []<span class="type">byte</span>)</span><br><span class="line">	Decrypt(src, dst []<span class="type">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stream <span class="keyword">interface</span> &#123;</span><br><span class="line">	XORKeyStream(dst, src []<span class="type">byte</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是计数器模式 （CTR ）流的定义，它将块加密改为流加密，注意块加密的细节已被抽象化了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewCTR 返回一个 Stream，其加密 / 解密使用计数器模式中给定的 Block 进行。</span></span><br><span class="line"><span class="comment">// iv 的长度必须与 Block 的块大小相同。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCTR</span><span class="params">(block Block, iv []<span class="type">byte</span>)</span></span> Stream</span><br></pre></td></tr></table></figure>

<p>NewCTR 的应用并不仅限于特定的加密算法和数据源，它适用于任何对 Block 接口和 Stream 的实现。因为它们返回接口值， 所以用其它加密模式来代替 CTR 只需做局部的更改。构造函数的调用过程必须被修改， 但由于其周围的代码只能将它看做 Stream，因此它们不会注意到其中的区别。</p>
<h3 id="接口和方法"><a href="#接口和方法" class="headerlink" title="接口和方法"></a>接口和方法</h3><p>由于几乎任何类型都能添加方法，因此几乎所有任何类型都能满足一个接口。</p>
<p>一个很直观的例子就是 http 包中定义的 Handler 接口。任何实现 Handler 的对象都能够处理 http 请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span>&#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ResponseWriter 接口提供了对方法的访问，这些方法需要响应客户端的请求。 由于这些方法包含了标准的 Write 方法，因此 http.ResponseWriter 可用于任何 io.Writer 适用的场景。Request 是一个包含已解析的客户端请求的结构体。</p>
<p><strong>为简单起见，这里假设所有的 HTTP 请求都是 GET 方法。下面有一个简短的处理程序实现，用于记录某个页面被访问的次数。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Simple counter server.</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">	n <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctr *Counter)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">	ctr.n++</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;counter = %d\n&quot;</span>, ctr.n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面将这样一个服务器添加到 URL 树的一个节点上</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br><span class="line">...</span><br><span class="line">ctr := <span class="built_in">new</span>(Counter)</span><br><span class="line">http.Handle(<span class="string">&quot;/counter&quot;</span>, ctr)</span><br></pre></td></tr></table></figure>

<p>事实上这里 Counter 不一定要是一个结构体，一个整数就够了</p>
<p>如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Simple counter server.</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctr *Counter)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request)&#123;</span><br><span class="line">	*ctr++</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;counter = %d\n&quot;</span>,*ctr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>页面被访问时，可以通过绑定一个 channel  通知程序</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A channel that sends a notification on each visit.</span></span><br><span class="line"><span class="comment">// (Probably want the channel to be buffered.)</span></span><br><span class="line"><span class="keyword">type</span> Chan <span class="keyword">chan</span> *http.Request</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ch Chan)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">	ch &lt;- req</span><br><span class="line">	fmt.Fprint(w, <span class="string">&quot;notification sent&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后假设需要输出调用服务器二进制程序时使用的实参 <code>args</code> 。如下：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArgServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(os.Args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何将它转换为 HTTP 服务器？既然可以为除了指针和接口以为的任何类型定义方法，同样也能为函数写一个方法。http 包包含以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The HandlerFunc type is an adapter to allow the use of</span></span><br><span class="line"><span class="comment">// ordinary functions as HTTP handlers.  If f is a function</span></span><br><span class="line"><span class="comment">// with the appropriate signature, HandlerFunc(f) is a</span></span><br><span class="line"><span class="comment">// Handler object that calls f.</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(c, req).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, req *Request) &#123;</span><br><span class="line">	f(w, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HandlerFunc 是一个具有 ServerHTTP 方法的类型，因此该类型的值就能处理 HTTP 请求。</p>
<p>为了将 ArgsServer 实现成 HTTP 服务器，首先得有合适的签名</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Argument server.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArgServer</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintln(w, os.Args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArgServer 和 HandlerFunc 现在拥有了相同的签名， 因此我们可将其转换为这种类型以访问它的方法，就像我们将 Sequence 转换为 IntSlice 以访问 IntSlice.Sort 那样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.Handle(<span class="string">&quot;/args&quot;</span>, http.HandlerFunc(ArgServer))</span><br></pre></td></tr></table></figure>

<p>当访问 &#x2F;args 页面时，该页面的处理程序就有了值 ArgServer 和类型 HandlerFunc。 HTTP 服务器会以 ArgServer 为接收者，调用该类型的 ServeHTTP 方法，它会反过来调用 ArgServer（通过 f(c, req)），接着实参就会被显示出来。</p>
<h2 id="空白表示符"><a href="#空白表示符" class="headerlink" title="空白表示符"></a>空白表示符</h2><p>空白标识符可被赋予或声明为任何类型的任何值，其值会被无害地丢弃。有点像 Unix 中的 &#x2F;dev&#x2F;null 文件：它表示只写的值，在需要变量但不需要实际值的地方用作占位符。</p>
<h3 id="多重赋值中的空白表示符"><a href="#多重赋值中的空白表示符" class="headerlink" title="多重赋值中的空白表示符"></a>多重赋值中的空白表示符</h3><p>for range 循环中对空白标识符的用法是一种具体情况，更一般的情况即为多重赋值。</p>
<p>若某次赋值需要匹配多个左值，但其中某个变量不会被程序使用， 那么用空白标识符来代替该变量可避免创建无用的变量，并能清楚地表明该值将被丢弃。 例如，当调用某个函数时，它会返回一个值和一个错误，但只有错误很重要， 那么可使用空白标识符来丢弃无关的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err := os.Stat(path); os.IsNotExist(err) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s does not exist\n&quot;</span>, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="未使用的导入和变量"><a href="#未使用的导入和变量" class="headerlink" title="未使用的导入和变量"></a>未使用的导入和变量</h3><p>若导入某个包或某个变量而不使用它就会产生错误。未使用的包会让程序膨胀并拖慢编译速度，而已初始化但未使用的变量不仅会浪费计算能力，还可能暗藏更大的 bug 。然而在程序开发过程中，经常会产生为使用的导入和变量，虽然以后会用到它们，但是为了完成编译又不得不删除它们才行，空白标识符能提供一个临时解决方案。</p>
<p>下面有一个写了一半的程序有两个个未使用的导入（<code>fmt</code> 和 <code>io</code>）以及一个未使用的变量 <code>fd</code>，因此它不能编译。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fd, err := os.Open(<span class="string">&quot;test.go&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> use fd.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要让编译停止关于未使用导入的报错，需要空白标识符来引用已导入包中的符号。同样，将未使用的变量 fd 赋予空白标识符来关闭未使用变量的报错。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = fmt.Printf <span class="comment">// For debugging; delete when done. </span></span><br><span class="line"><span class="keyword">var</span> _ io.Reader    <span class="comment">// For debugging; delete when done. </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fd, err := os.Open(<span class="string">&quot;test.go&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> use fd.</span></span><br><span class="line">    _ = fd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照惯例，我们应在导入并加以注释后，再使全局声明导入错误静默，这样可以让它们更易找到， 并作为以后清理它的提醒。</p>
<h3 id="空白导入"><a href="#空白导入" class="headerlink" title="空白导入"></a>空白导入</h3><p>又叫匿名导入</p>
<p>像前面 fmt 或 io 这种未使用的导入最后都要被处理。但有时导入某个包只是为了其副作用，而没有任何明确的使用。例如在 net&#x2F;http&#x2F;pprof 包中的 <strong>init</strong> 函数中记录了 HTTP 处理程序的调试信息。它有个可导出的 API ，但大部分客户端只需要该处理程序的记录和通过 Web 页面访问数据。欲导入一个只使用其副作用的包只需要将该包重命名为空白表示符</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;net/http/pprof&quot;</span></span><br></pre></td></tr></table></figure>

<p>这种导入格式能明确表示该包是为其副作用而导入的，因为没有其它使用该包的可能： 在此文件中，它没有名字。</p>
<p>空白导入或匿名导入在以下几种情况下可能会被使用：</p>
<ol>
<li>执行包的<code>init</code>函数：有些包在导入时需要执行一些初始化逻辑，但在代码中并不直接使用该包的功能。此时，可以使用空白导入来确保执行包的<code>init</code>函数。</li>
<li>注册驱动或插件：某些驱动或插件需要在导入时注册自己，以便在后续的程序执行中被正确地识别和使用。通过空白导入，可以让驱动或插件的<code>init</code>函数得到执行，从而进行注册。</li>
<li>副作用操作：一些包可能会在导入时产生副作用，例如修改程序状态、注册全局变量等。通过空白导入，可以触发这些副作用操作。</li>
<li>触发编译器插件：有些包是为了触发编译器插件而导入的。这些插件在编译过程中会检查代码，并可能进行一些额外的代码转换或优化。通过空白导入，可以让编译器插件感知到需要处理的代码。</li>
</ol>
<h3 id="接口检查"><a href="#接口检查" class="headerlink" title="接口检查"></a>接口检查</h3><h4 id="类型一"><a href="#类型一" class="headerlink" title="类型一"></a>类型一</h4><p>一个类型无需显式地声明它实现了某个接口。取而代之，该类型只要实现了某个接口的方法，其实就实现了该接口。在实践中，大部分接口转换都是静态，因此会在编译时检测。例如，将一个 <code>*os.File</code> 传入一个接收 <code>io.Reader</code> 函数将不会被编译，除非 <code>*os.File</code>  实现了 <code>io.Reader</code>  接口。</p>
<p>尽管如此，有些接口检查会在运行时进行。例如, <code>encoding/json</code> 包定义了一个 <code>Marshaler</code> 接口。当 JSON 编码器接收到了一个实现该接口的值，那么该编码器就会调用该值的编组方法，将其转换为 JSON，而非进行标准的转换。编码器在运行时通过类型断言检查其属性：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m, ok := val.(json.Marshaler)</span><br></pre></td></tr></table></figure>

<p>若只需要判断某个类型是否实现了某个接口，而不需要实际使用接口本身，就是用空白标识符来忽略类型断言的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _, ok := val.(json.Marshaler);ok&#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;value %v of type %T implements json.Marshaler\n&quot;</span>,val,val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类型二"><a href="#类型二" class="headerlink" title="类型二"></a>类型二</h4><p>若某个类型（例如 json.RawMessage）需要一种定制的 JSON 表现时，它应当实现 json.Marshaler，<strong>不过现在没有静态转换可以让编译器自动验证它</strong>。又或者该类型通过忽略转换失败来满足该接口，那么 JSON 编码器仍可工作，但它不会使用自定义的实现。为确保其实现正确，可在该包中用空白标识符声明一个全局变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ json.Marshaler = (*RawMessage)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>此声明中，调用了一个 <code>*RawMessage </code>转换并将其赋予了 Marshaler，以此来要求<code>*RawMessage</code> 实现 Marshaler，这时其属性就会在编译时被检测。若 json.Marshaler 接口被更改，此包将无法通过编译，这样就能注意到它需要更新。</p>
<p>这种结构中出现空白表示符，即表示该声明的存在只是为了类型检查。</p>
<p>不要为了实现接口对任何类型都使用这种方法，作为约定，仅当代码中不存在静态类型转换时才使用这种声明。</p>
<h2 id="内嵌"><a href="#内嵌" class="headerlink" title="内嵌"></a>内嵌</h2><p>Go 并不提供典型的，类型驱动的子类化概念，但通过将类型内嵌到结构体或接口中，就能使用部分实现。</p>
<h3 id="接口内嵌"><a href="#接口内嵌" class="headerlink" title="接口内嵌"></a>接口内嵌</h3><p>接口内嵌非常简单，例如 <code>io.Reader</code> 和 <code>io.Writer</code> 接口，下面是它的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">	Read(p []<span class="type">byte</span>)(n <span class="type">int</span>,err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Write(p []<span class="type">byte</span>)(n <span class="type">int</span>,err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>io 包也导出了一些其它接口，以此来阐明对象所需要实现的方法。例如 io.ReadWriter 就是个包含 Read 和 Write 的接口。我们可以通过显式的列出这两个方法来指明 io.ReadWriter，但通过这两个接口内嵌到新的接口中显然更容易且更具启发性：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadWriter is the interface that combines the Reader and Writer interfaces.</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span>&#123;</span><br><span class="line">	Reader</span><br><span class="line">	Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReadWriter 能够做任何 Reader 和 Writer 可以做到的事情，它是内嵌了接口的联合体。<strong>只有接口能被内嵌到接口中。</strong></p>
<h3 id="结构体内嵌"><a href="#结构体内嵌" class="headerlink" title="结构体内嵌"></a>结构体内嵌</h3><p>同样的思想可以应用在结构体中，但意义更深远。bufio 包中有 bufio.Reader 和 bufio.Writer 这两个结构体类型，它们每一个都实现了与 io 包中相同意义的接口。此外，bufio 还通过结合 reader&#x2F;writer 并将其内嵌到结构体中，实现了带缓冲的 reader&#x2F;writer：它在结构体中列出了这些类型，但是匿名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadWriter stores pointers to a Reader and a Writer.</span></span><br><span class="line"><span class="comment">// It implements io.ReadWriter.</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	reader *Reader</span><br><span class="line">	writer *Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内嵌的元素为指向结构体的指针，<strong>在使用前必须被初始化为指向有效结构体的指针</strong>。但为了提升该字段的方法并满足 io 接口，同样需要提供转发的方法，就像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *ReadWriter)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> rw.reader.Read(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者显示地指定字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rw ReadWriter</span><br><span class="line">rw.reader.Read()</span><br></pre></td></tr></table></figure>

<p>而通过直接内嵌结构体（匿名），就能避免这样的繁琐。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	 *Reader</span><br><span class="line">	 *Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候内嵌类型的方法可以直接引用，当匿名内嵌的类型中有同名的方法时，尝试直接调用这个方法时编译器会报错，解决办法是指定类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rw ReadWriter</span><br><span class="line">rw.Reader.Read()</span><br></pre></td></tr></table></figure>

<p>现在的嵌套关系是：<code>bufio.ReadWriter</code> &gt;&gt; <code>bufio.Reader/bufio.Writer</code> &gt;&gt; <code>io.Reader/io.Writer</code> 这意味着 bufio.ReadWriter 不仅包括 bufio.Reader 和 bufio.Writer 的方法，它还同时满足下列三个接口： io.Reader、io.Writer 以及 io.ReadWriter。</p>
<p>当内嵌一个类型时，该类型的方法会成为外部类型的方法，但当它们被调用时，该方法的接收者是内部类型，而非外部的。在上面的例子中，当 bufio.ReadWriter 的 Read 方法被调用时，接收者是 ReadWriter 的 reader 字段，而非 ReadWriter 本身。</p>
<h3 id="另一个例子"><a href="#另一个例子" class="headerlink" title="另一个例子"></a>另一个例子</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">	Command <span class="type">string</span></span><br><span class="line">	*log.Logger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若我们需要直接引用内嵌字段，<strong>可以忽略包限定名</strong>，直接将该字段的类型名作为字段名。例如，我们需要访问 Job 类型的变量 job 的 <code>*log.Logger</code>， 可以直接写作 job.Logger。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(job *Job)</span></span> Logf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	job.Logger.Logf(<span class="string">&quot;%q: %s&quot;</span>, job.Command, fmt.Sprintf(format, args...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内嵌类型会引入命名冲突的问题，但解决方法却很简单。首先，字段或方法 X 会隐藏该类型中更深层嵌套的其他项 X。例如，若 log.Logger 包含一个名为 Logf 的方法，Job 的 Logf 方法会覆盖它。</p>
<p>其次，若相同的嵌套层级上出现同名冲突，通常会产生一个错误。若 Job 结构体中包含名为 Logger 的字段或方法，再将 log.Logger 内嵌到其中的话就会产生错误。然而，若重名的字段或方法不在该类型定义之外的程序中使用，那就不会报错。  因此，就算添加的字段或方法与另一个中的字段或方法相冲突，只要不使用就没问题。</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
<p>不要通过共享内存来通信，而应通过通信来共享内存。</p>
</blockquote>
<h3 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h3><p>之所以称之为 <code>Goroutine</code> 是因为现有的术语：线程、协程、进程……都无法准确传达它的含义。Goroutine 是轻量级的，所有消耗几乎就只有栈空间的分配，而且栈最开始是非常小的，所以 Goroutine 很廉价，仅在需要时才会随着堆空间的分配（和释放）而变化。</p>
<p>Goroutine 在多线程操作系统上可实现多路复用，因此若一个线程阻塞，比如说等待 I&#x2F;O，那么其它的线程就会运行。Goroutine 的设计隐藏了线程创建和管理的诸多复杂性。</p>
<p>在函数或方法前添加 go 关键字能够在新的 goroutine 中调用它。当调用完成后，该 goroutine 也会安静地退出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> list.Sort()  <span class="comment">// run list.Sort concurrently; don&#x27;t wait for it.</span></span><br></pre></td></tr></table></figure>

<p>在 Go 中，函数字面都是闭包：其实现在保证了函数内引用变量的生命周期与函数的活动时间相同。</p>
<h3 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h3><p>Channels 和 map 一样，也需要 make 来分配内存，其结果值充当了对底层数据结构的引用。若提供了一个可选的整数形参，就会为 channel 设置缓冲区大小。默认值时零，表示不带缓冲或同步的 channel。</p>
<p>无缓冲信道在通信时会同步交换数据，它能确保（两个 goroutine）计算处于确定状态。</p>
<p>接收者在收到数据前会一直阻塞。若信道是不带缓冲的，那么在接收者收到值前， 发送者会一直阻塞；若信道是带缓冲的，则发送者直到值被复制到缓冲区才开始阻塞； 若缓冲区已满，发送者会一直等待直到某个接收者取出一个值为止。</p>
<p>带缓冲的信道可被用作信号量，例如限制吞吐量。在此例中，进入的请求会被传递给 handle，它从信道中接收值，处理请求后将值发回该信道中，以便让该 “信号量” 准备迎接下一次请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sem = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, MaxOutstanding)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(r *Request)</span></span> &#123;</span><br><span class="line">	sem &lt;- <span class="number">1</span> <span class="comment">// 等待活动队列清空。</span></span><br><span class="line">	process(r)  <span class="comment">// 可能需要很长时间。</span></span><br><span class="line">	&lt;-sem    <span class="comment">// 完成；使下一个请求可以运行。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		req := &lt;-queue</span><br><span class="line">		<span class="keyword">go</span> handle(req)  <span class="comment">// 无需等待 handle 结束。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦有 MaxOutstanding 个 handlers  进入运行状态，其他的所有 handler 都会在试图发送值到信道缓冲区的时候阻塞，直到某个 handler 完成处理并从缓冲区取回一个值为止。</p>
<p>但是存在一个问题：尽管只有 MaxOutstanding 个 goroutine 能同时运行，但 Serve 还是为每个进入的请求都创建了新的 goroutine 。其结果就是，若请求来得很快，该程序就会无限地消耗资源。为了弥补这种不足，我们可以通过修改 Serve  来限制创建 Goroutine。</p>
<p><strong>！！！要注意这里出现的一个常见的 bug ！！！</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> req:=<span class="keyword">range</span> queue &#123;</span><br><span class="line">		sem &lt;- <span class="number">1</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">			process(req)   <span class="comment">// Bug !!!!</span></span><br><span class="line">			&lt;-sem</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bug 出现在 Go 的 for 循环中，该循环变量在每次迭代时会被重用，因此 req 变量会在所有的 goroutine 间共享，这不是我们想要的。我们需要确保 req 对于每个 goroutine 来说都是唯一的。有一种方法能够做到，就是将 req 的值作为实参传入到该 goroutine 的闭包中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> req := <span class="keyword">range</span> queue &#123;</span><br><span class="line">		sem &lt;- <span class="number">1</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(req *Request)</span></span> &#123;</span><br><span class="line">			process(req)</span><br><span class="line">			&lt;-sem</span><br><span class="line">		&#125;(req)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种解决方案就是一相同的名字创建新的变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> req := <span class="keyword">range</span> queue &#123;</span><br><span class="line">		req := req <span class="comment">// Create new instance of req for the goroutine.</span></span><br><span class="line">		sem &lt;- <span class="number">1</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			process(req)</span><br><span class="line">			&lt;-sem</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的写法看起来很奇怪</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req := req</span><br></pre></td></tr></table></figure>

<p>但在 Go 中这样的做法是合法且管用的。这里使用了相同的名字获得了这个变量的一个新的版本，以此来屏蔽循环变量，使 req 对每个 goroutine 唯一。</p>
<p>回到编写服务器的一般问题上。另一种管理资源的好方法就是启动固定数量的 hanlde goroutine，一起从请求信道中读取数据。Goroutine 的数量限制了同时调用 process 的数量。Serve 同样会收到一个通知退出的信道，在启动所有 goroutine 后，它将阻塞并暂时停止从信道中接收消息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> r := <span class="keyword">range</span> queue &#123;</span><br><span class="line">		process(r)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(clientRequests <span class="keyword">chan</span> *Request, quit <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 启动处理程序</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; MaxOutstanding; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> handle(clientRequests)</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;-quit  <span class="comment">// 等待通知退出。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信道的信道"><a href="#信道的信道" class="headerlink" title="信道的信道"></a>信道的信道</h3><p>Go 最重要的特性就是 channel 是一等值，它可以被分配并像其它值到处传递。这种特性通常被用来实现安全、并行的多路分解。</p>
<p>在上面的例子中，handle 是个非常理想化的请求处理程序，没有定义它所处理的请求类型。若该类型包含一个可用于回复的信道，那么每一个客户端都能为其响应提供自己的路径。以下为 Request  类的大概定义。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">	args        []<span class="type">int</span></span><br><span class="line">	f           <span class="function"><span class="keyword">func</span><span class="params">([]<span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line">	resultChan  <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端提供一个函数及其实参，在请求对象中还有一个接收响应的信道</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a []<span class="type">int</span>)</span></span> (s <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">		s += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request := &amp;Request&#123;[]<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, sum, <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)&#125;</span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">clientRequests &lt;- request</span><br><span class="line"><span class="comment">// 等待回应</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;answer: %d\n&quot;</span>, &lt;-request.resultChan)</span><br></pre></td></tr></table></figure>

<p>在服务端，只需改动 handle 函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> req := <span class="keyword">range</span> queue &#123;</span><br><span class="line">		req.resultChan &lt;- req.f(req.args)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并行化"><a href="#并行化" class="headerlink" title="并行化"></a>并行化</h3><p>这些设计的另一个应用是在多 CPU 核心上实现并行计算。如果计算过程能够被分为几块可独立执行的过程，它就可以在每块计算结束时向信道发送信号，从而实现并行处理。</p>
<p>举一个理想化的例子。下面的代码在对一系列向量项进行极耗资源的操作， 而每个项的值计算是完全独立的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vector []<span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将此操应用至 v[i], v[i+1] ... 直到 v[n-1]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vector)</span></span> DoSome(i, n <span class="type">int</span>, u Vector, c <span class="keyword">chan</span> <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> ; i &lt; n; i++ &#123;</span><br><span class="line">		v[i] += u.Op(v[i])</span><br><span class="line">	&#125;</span><br><span class="line">	c &lt;- <span class="number">1</span>    <span class="comment">// 发信号表示这一块计算完成。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在循环中启动了独立的处理块，每个 CPU 将执行一个处理。 它们有可能以乱序的形式完成并结束，但这没有关系； 我们只需在所有 goroutine 开始后接收，并统计信道中的完成信号即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NCPU = <span class="number">4</span>  <span class="comment">// CPU 核心数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vector)</span></span> DoAll(u Vector) &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, NCPU)  <span class="comment">// 缓冲区是可选的，但明显用上更好</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NCPU; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> v.DoSome(i*<span class="built_in">len</span>(v)/NCPU, (i+<span class="number">1</span>)*<span class="built_in">len</span>(v)/NCPU, u, c)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 排空信道。</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NCPU; i++ &#123;</span><br><span class="line">		&lt;-c    <span class="comment">// 等待任务完成</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 一切完成。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可溢出的缓冲区"><a href="#可溢出的缓冲区" class="headerlink" title="可溢出的缓冲区"></a>可溢出的缓冲区</h3><p>并发编程的工具甚至能很容易地表达出非并发的思想。下面有一个提取自 RPC 包的例子。客户端 Goroutine 从某些来源，可能是网络手机数据。为了避免你分配和释放缓冲区，它维持一个空列表，使用一个带缓冲 channel 表示。若信道为空，就会分配新的缓冲区。一旦消息缓冲区就绪，将通过 serverChan 被发送到服务器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> freeList = <span class="built_in">make</span>(<span class="keyword">chan</span> *Buffer, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> serverChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *Buffer)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">client</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> b *Buffer</span><br><span class="line">		<span class="comment">// 若缓冲区可用就用它，不可用就分配个新的。</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> b = &lt;-freeList:</span><br><span class="line">			<span class="comment">// 获取一个，不做别的。</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// 非空闲，因此分配一个新的。</span></span><br><span class="line">			b = <span class="built_in">new</span>(Buffer)</span><br><span class="line">		&#125;</span><br><span class="line">		load(b)              <span class="comment">// 从网络中读取下一条消息。</span></span><br><span class="line">		serverChan &lt;- b   <span class="comment">// 发送至服务器。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端从客服端循环接收消息，并进行处理，再将缓冲区返回给空闲列表。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		b := &lt;-serverChan    <span class="comment">// 等待工作。</span></span><br><span class="line">		process(b)</span><br><span class="line">		<span class="comment">// 若缓冲区有空间就重用它。</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> freeList &lt;- b:</span><br><span class="line">			<span class="comment">// 将缓冲区放大空闲列表中，不做别的。</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// 空闲列表已满，保持就好。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端试图从 freeList 中获取缓冲区，若没有缓冲区可用，它将分配一个新的缓冲区。服务器及那个缓冲区 放回 freeList 直到列表已满。此时缓冲区将被丢弃，并被 gc 回收。（select 语句中的 default 子句在没有条件复合时执行，也就意味着 selects 永远不会被阻塞）依靠带缓冲的 channel 和 gc ，构建了一个可溢出的缓冲区的空闲列表。</p>
<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>错误的类型通常为 error ，这是一个简单的内建接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> interfact&#123;</span><br><span class="line">	Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过更丰富的底层模型实现这个接口，这样不但能看见错误，还能提供一些上下文。例如，<code>os.Open</code> 除了返回一个 <code>*os.File</code> 返回值，<code>os.Open</code> 还返回一个 error 值。若该文件被成功打开，error 值就是 nil ，如果除了问题，这个值就是一个 <code>os.PathError</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PathError 记录一个错误以及产生该错误的路径和操作。</span></span><br><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">	Op <span class="type">string</span>    <span class="comment">// &quot;open&quot;、&quot;unlink&quot; 等等。</span></span><br><span class="line">	Path <span class="type">string</span>  <span class="comment">// 相关联的文件。</span></span><br><span class="line">	Err <span class="type">error</span>    <span class="comment">// 由系统调用返回。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.Op + <span class="string">&quot; &quot;</span> + e.Path + <span class="string">&quot;: &quot;</span> + e.Err.Error()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PathError 的 Error 会生成如下错误信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open /etc/passwx: no such file or directory</span><br></pre></td></tr></table></figure>

<p>这种错误包含了出错的文件名、操作和触发的操作系统错误。</p>
<p>错误字符串应尽可能地指名它们的来源，例如产生该错误的包名前缀。例如在 image 包中，由于位置格式导致解码错误的字符串为”image：unknown format“</p>
<p>若调用者关心错误的完整细节，可使用类型选择或者类型断言来查看特定错误，并抽取其细节。 对于 PathErrors，它应该还包含检查内部的 Err 字段以进行可能的错误恢复。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> try := <span class="number">0</span>; try &lt; <span class="number">2</span>; try++ &#123;</span><br><span class="line">	file, err = os.Create(filename)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> e, ok := err.(*os.PathError); ok &amp;&amp; e.Err == syscall.ENOSPC &#123;</span><br><span class="line">		deleteTempFiles()  <span class="comment">// Recover some space.</span></span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的第二条 if 是另一种类型断言。若它失败， ok 将为 false，而 e 则为 nil. 若它成功，ok 将为 true，这意味着该错误属于 <code>*os.PathError</code> 类型，而 e 能够检测关于该错误的更多信息。</p>
<h3 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a>Panic</h3><p>Go 提供了内建的 panic 函数，它会产生一个运行时错误并终止程序。该函数接受一个任意类型的实参（一般为字符串），并在程序终止时打印。 它还能表明发生了意料之外的事情，比如从无限循环中退出了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A toy implementation of cube root using Newton&#x27;s method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CubeRoot</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	z := x/<span class="number">3</span>   <span class="comment">// Arbitrary initial value</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1e6</span>; i++ &#123;</span><br><span class="line">		prevz := z</span><br><span class="line">		z -= (z*z*z-x) / (<span class="number">3</span>*z*z)</span><br><span class="line">		<span class="keyword">if</span> veryClose(z, prevz) &#123;</span><br><span class="line">			<span class="keyword">return</span> z</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// A million iterations has not converged; something is wrong.</span></span><br><span class="line">	<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;CubeRoot(%g) did not converge&quot;</span>, x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际的库函数应该避免 panic 。如果问题可以被忽略或解决，最好就是让程序继续运行而不是终止整个程序。</p>
<h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>当 panic 被调用后（包括不明确的运行时错误，例如切片检索越界或类型断言失败），程序将立即终止当前函数的执行，并开始回溯 goroutine 的栈，运行任何 defer 的函数。若回溯到达 goroutine 栈的顶端，程序就会终止。不过我们可以用内建的 recover 函数来重新取回 goroutine 的控制权限并使其恢复正常执行。</p>
<p>调用 recover 将停止回溯过程，并返回传入 panic 的实参。<strong>由于在回溯时只有被推迟函数中的代码在运行，因此 recover 只能在被推迟的函数中才有效。</strong></p>
<p>recover 的一个应用就是在服务器中终止失败的 goroutine 而无需杀死其它正在执行 goroutine 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">(workChan &lt;-<span class="keyword">chan</span> *Work)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> work := <span class="keyword">range</span> workChan &#123;</span><br><span class="line">		<span class="keyword">go</span> safelyDo(work)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safelyDo</span><span class="params">(work *Work)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(<span class="string">&quot;work failed:&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	do(work)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，若 <code>do(work)</code> 触发了 panic ，其结果就会被日志记录，而该 goroutine 会被结束而不会干扰到其他的 goroutine 。 我们无需在 defer 的闭包函数中做任何事情， 一切交给 recover 处理。</p>
<p>由于直接从 defer 函数中调用 recover 时不会返回 nil，因此被推迟的代码能够调用本身使用了 panic 和 recover 的库函数而不会失败。例如在 safelyDo 中，被推迟的函数可能在调用 recover 前先调用日志记录，而日志函数应当不受 panic 状态的代码的影响。</p>
<p>通过恰当地使用恢复模式，do 函数（及其调用的任何代码）可通过调用 panic 来避免更坏的结果。我们可以利用这种思想来简化复杂软件中的错误处理。下面是简化版的 regexp 包的理想化版本，它会以局部的错误类型调用 panic 来报告解析错误。以下是一个 error 类型的 Error 方法和一个 Compile 函数的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error 是解析错误的类型，它满足 error 接口。</span></span><br><span class="line"><span class="keyword">type</span> Error <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Error)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error 是 *Regexp 的方法，它通过用一个 Error 触发 Panic 来报告解析错误。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(regexp *Regexp)</span></span> <span class="type">error</span>(err <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="built_in">panic</span>(Error(err))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile 返回该正则表达式解析后的表示。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compile</span><span class="params">(str <span class="type">string</span>)</span></span> (regexp *Regexp, err <span class="type">error</span>) &#123;</span><br><span class="line">	regexp = <span class="built_in">new</span>(Regexp)</span><br><span class="line">	<span class="comment">// doParse will panic if there is a parse error.</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">			regexp = <span class="literal">nil</span>    <span class="comment">// 清理返回值。</span></span><br><span class="line">			err = e.(Error) <span class="comment">// 若它不是解析错误，将重新触发 Panic。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> regexp.doParse(str), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 若 doParse 触发了 panic  ，recover 块会将返回值设为 nil（defer 的函数能够修改已命名的返回值）。在 err 赋值过程中，通过断言它是否拥有局部类型 Error 。若它没有，类型断言将会失败，此时将会产生运行时的错误，并继续栈的回溯，就像没有被 recover 中断过一样。该检查意味着若发生了一些像索引越界之类的意外，那么即使使用了 panic 和 recover 来处理解析错误，代码仍然会崩溃。</p>
<p>通过适当的错误处理，error 方法（由于它是个绑定到具体类型的方法，因此即使与内建的 error 类型名字相同也没关系）能让报错解析报告变得更容易，而无需手动处理回溯的栈：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pos == <span class="number">0</span> &#123;</span><br><span class="line">	re.<span class="type">error</span>(<span class="string">&quot;&#x27;*&#x27; illegal at start of expression&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管这种模式很有用，但它应当仅在包内使用。Parse 会将其内部的 panic 调用转为 error 值，它并不会向调用者暴露出 panic。这是个值得遵守的良好规则。</p>
<p>顺便一提，这种重新触发Panic的惯用法会在产生实际错误时改变Panic的值。 然而，不管是原始的还是新的错误都会在崩溃报告中显示，因此问题的根源仍然是可见的。 这种简单的重新触发Panic的模型已经够用了，毕竟只是一次崩溃。 但是如果只想显示原始的值，也可以多写一点代码来进行过滤，然后用原来的 error 再次触发 Panic。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">GDshenqingNo1</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/05/27/Golang%20Note/">http://example.com/2023/05/27/Golang%20Note/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">梁伟健的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/lucy.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/27/flag&amp;&amp;args/"><img class="prev-cover" src="/img/lucy.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">flag &amp; args</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/09/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81CDN/"><img class="next-cover" src="/img/lucy.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">正向代理、反向代理、CDN</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">GDshenqingNo1</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/GDshenqingNo1"><i class="fab fa-github"></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/GDshenqingNo1" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:liangweijian666@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Golang-Note-Fundamental"><span class="toc-number">1.</span> <span class="toc-text">Golang Note Fundamental</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E9%9D%A2%E5%86%99%E7%9A%84%E6%B2%A1%E5%95%A5%E7%94%A8%E7%9A%84%E4%B8%9C%E8%A5%BF"><span class="toc-number">1.1.</span> <span class="toc-text">前面写的没啥用的东西</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#json"><span class="toc-number">1.1.1.</span> <span class="toc-text">json</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-number">1.1.2.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.3.</span> <span class="toc-text">hash函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HMAC-Hash-based-Message-Authentication-Code"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">HMAC(Hash-based Message Authentication Code)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JWT%EF%BC%88-Json-web-token%EF%BC%89"><span class="toc-number">1.1.4.</span> <span class="toc-text">JWT（ Json web token）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">1.1.5.</span> <span class="toc-text">中间件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Golang%E4%B8%AD%E8%9B%8B%E7%96%BC%E7%9A%84%E4%B8%89%E4%B8%AA%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">Golang中蛋疼的三个点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%8D%E5%AE%9A%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">函数的不定参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E6%89%93%E6%95%A3"><span class="toc-number">1.2.2.</span> <span class="toc-text">切片的打散</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%87%AA%E8%A1%8C%E6%8E%A8%E6%96%AD%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">1.2.3.</span> <span class="toc-text">数组自行推断数组的长度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Context%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.3.</span> <span class="toc-text">Context上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Context%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.1.</span> <span class="toc-text">Context概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Context%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.2.</span> <span class="toc-text">Context接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Background-%E5%92%8CTODO"><span class="toc-number">1.3.3.</span> <span class="toc-text">Background()和TODO()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#With%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.4.</span> <span class="toc-text">With系列函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WithCancel"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">WithCancel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WithDeadline"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">WithDeadline</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WithTimeout"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">WithTimeout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WithValue"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">WithValue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">1.4.</span> <span class="toc-text">类型断言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">一般格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">特殊用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-switch"><span class="toc-number">1.4.3.</span> <span class="toc-text">type-switch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#net-x2F-http"><span class="toc-number">1.5.</span> <span class="toc-text">net&#x2F;http</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#net-x2F-http%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">net&#x2F;http介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.5.0.2.</span> <span class="toc-text">HTTP客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84http-x2F-https%E8%AF%B7%E6%B1%82"><span class="toc-number">1.5.0.2.0.1.</span> <span class="toc-text">基本的http&#x2F;https请求</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%8D%E5%B8%A6%E5%8F%82%E6%95%B0Get%E8%AF%B7%E6%B1%82%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.5.0.2.0.2.</span> <span class="toc-text">不带参数Get请求示例</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84GET%E8%AF%B7%E6%B1%82%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.5.0.2.0.3.</span> <span class="toc-text">带参数的GET请求示例</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#POST%E8%AF%B7%E6%B1%82%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.5.0.2.0.4.</span> <span class="toc-text">POST请求示例</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8Go%E4%B8%AD%E4%BD%BF%E7%94%A8MySQL"><span class="toc-number">1.6.</span> <span class="toc-text">在Go中使用MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.6.1.</span> <span class="toc-text">连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">访问数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">初始化连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SetMaxOpenConns"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">SetMaxOpenConns</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SetMaxIdleConns"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">SetMaxIdleConns</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5"><span class="toc-number">1.6.2.</span> <span class="toc-text">查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E-x2F-%E6%94%B9-x2F-%E5%88%A0"><span class="toc-number">1.6.3.</span> <span class="toc-text">增&#x2F;改&#x2F;删</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.6.4.</span> <span class="toc-text">预处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.</span> <span class="toc-text">文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="toc-number">1.7.1.</span> <span class="toc-text">创建文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-number">1.7.2.</span> <span class="toc-text">打开文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io%E6%B5%81"><span class="toc-number">1.7.3.</span> <span class="toc-text">io流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Reader%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">Reader接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Writer%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">Writer接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">1.7.4.</span> <span class="toc-text">读文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E8%AF%BB"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">普通读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bufio%E8%AF%BB"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">bufio读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">1.7.5.</span> <span class="toc-text">写文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%86%99"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">普通写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bufio%E5%86%99"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">bufio写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Gorm"><span class="toc-number">1.8.</span> <span class="toc-text">Gorm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.8.1.</span> <span class="toc-text">连接数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89GORM-Model"><span class="toc-number">1.8.2.</span> <span class="toc-text">定义GORM Model</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gorm-Model"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">gorm.Model</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%A0%87%E8%AE%B0"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">结构体标记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E3%80%81%E8%A1%A8%E5%90%8D%E3%80%81%E5%88%97%E5%90%8D%E7%9A%84%E7%BA%A6%E5%AE%9A"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">主键、表名、列名的约定</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE"><span class="toc-number">1.8.2.3.1.</span> <span class="toc-text">主键</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E5%90%8D"><span class="toc-number">1.8.2.3.2.</span> <span class="toc-text">表名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%97%E5%90%8D"><span class="toc-number">1.8.2.3.3.</span> <span class="toc-text">列名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CRUD"><span class="toc-number">1.8.3.</span> <span class="toc-text">CRUD</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">创建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%AE%B0%E5%BD%95"><span class="toc-number">1.8.3.1.1.</span> <span class="toc-text">创建记录</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E5%88%9B%E5%BB%BA%E8%AE%B0%E5%BD%95"><span class="toc-number">1.8.3.1.2.</span> <span class="toc-text">用指定字段创建记录</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5"><span class="toc-number">1.8.3.1.3.</span> <span class="toc-text">批量插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%92%A9%E5%AD%90-hook"><span class="toc-number">1.8.3.1.4.</span> <span class="toc-text">创建钩子(hook)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AEMap%E5%88%9B%E5%BB%BA"><span class="toc-number">1.8.3.1.5.</span> <span class="toc-text">根据Map创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8SQL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%9B%E5%BB%BA"><span class="toc-number">1.8.3.1.6.</span> <span class="toc-text">使用SQL表达式创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-SQL-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81Context-Valuer-%E5%88%9B%E5%BB%BA%E8%AE%B0%E5%BD%95-x2F-x2F-%E6%96%BD%E5%B7%A5%E4%B8%AD-x2F-x2F"><span class="toc-number">1.8.3.1.7.</span> <span class="toc-text">使用 SQL 表达式、Context Valuer 创建记录&#x2F;&#x2F;施工中&#x2F;&#x2F;</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">查询</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E7%B4%A2%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.8.3.2.1.</span> <span class="toc-text">检索单个对象</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E4%B8%BB%E9%94%AE%E6%A3%80%E7%B4%A2"><span class="toc-number">1.8.3.2.1.1.</span> <span class="toc-text">根据主键检索</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E7%B4%A2%E5%85%A8%E9%83%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.8.3.2.2.</span> <span class="toc-text">检索全部对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.8.3.2.3.</span> <span class="toc-text">条件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#string"><span class="toc-number">1.8.3.2.3.1.</span> <span class="toc-text">string</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8Go%E4%B8%AD%E4%BD%BF%E7%94%A8redis"><span class="toc-number">1.9.</span> <span class="toc-text">在Go中使用redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">1.9.1.</span> <span class="toc-text">链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">1.9.2.</span> <span class="toc-text">一般写操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zap"><span class="toc-number">1.10.</span> <span class="toc-text">Zap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E5%99%A8"><span class="toc-number">1.10.1.</span> <span class="toc-text">配置日志记录器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Logger"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">Logger</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sugared-Logger"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">Sugared Logger</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6logger"><span class="toc-number">1.10.2.</span> <span class="toc-text">定制logger</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E8%80%8C%E4%B8%8D%E6%98%AF%E8%BE%93%E5%87%BA%E7%BB%88%E7%AB%AF"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">将日志写入文件而不是输出终端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86JSON-Encoder%E6%9B%B4%E6%94%B9%E4%B8%BA%E6%99%AE%E9%80%9A%E7%9A%84Log-Encoder"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">将JSON Encoder更改为普通的Log Encoder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E6%97%B6%E9%97%B4%E7%BC%96%E7%A0%81%E5%B9%B6%E6%B7%BB%E5%8A%A0%E8%B0%83%E7%94%A8%E8%80%85%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF"><span class="toc-number">1.10.2.3.</span> <span class="toc-text">更改时间编码并添加调用者详细信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AddCallerSkip"><span class="toc-number">1.10.2.4.</span> <span class="toc-text">AddCallerSkip</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%E5%88%B0%E5%A4%9A%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.10.2.5.</span> <span class="toc-text">将日志输出到多个位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86err%E6%97%A5%E5%BF%97%E5%8D%95%E7%8B%AC%E8%BE%93%E5%87%BA%E5%88%B0%E6%96%87%E4%BB%B6"><span class="toc-number">1.10.2.6.</span> <span class="toc-text">将err日志单独输出到文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Lumberjack%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%E5%BD%92%E6%A1%A3"><span class="toc-number">1.10.3.</span> <span class="toc-text">使用Lumberjack进行日志切割归档</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#zap-logger%E4%B8%AD%E5%8A%A0%E5%85%A5Lumberjack"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">zap logger中加入Lumberjack</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8zap%E7%9A%84%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.10.4.</span> <span class="toc-text">使用zap的一般步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Viper"><span class="toc-number">1.11.</span> <span class="toc-text">Viper</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E5%80%BC%E5%AD%98%E5%85%A5Viper"><span class="toc-number">1.11.1.</span> <span class="toc-text">把值存入Viper</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">1.11.1.1.</span> <span class="toc-text">建立默认值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.11.1.2.</span> <span class="toc-text">读取配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.11.1.3.</span> <span class="toc-text">写入配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E5%B9%B6%E9%87%8D%E6%96%B0%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.11.1.4.</span> <span class="toc-text">监控并重新读取配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8Eio-Reader%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE"><span class="toc-number">1.11.1.5.</span> <span class="toc-text">从io.Reader读取配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.11.1.6.</span> <span class="toc-text">覆盖设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E5%92%8C%E4%BD%BF%E7%94%A8%E5%88%AB%E5%90%8D"><span class="toc-number">1.11.1.7.</span> <span class="toc-text">注册和使用别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">1.11.1.8.</span> <span class="toc-text">使用环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Flags"><span class="toc-number">1.11.1.9.</span> <span class="toc-text">使用Flags</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8BKey-x2F-Value%E5%AD%98%E5%82%A8%E6%94%AF%E6%8C%81"><span class="toc-number">1.11.1.10.</span> <span class="toc-text">远程Key&#x2F;Value存储支持</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8EViper%E8%8E%B7%E5%8F%96%E5%80%BC"><span class="toc-number">1.11.2.</span> <span class="toc-text">从Viper获取值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%B5%8C%E5%A5%97%E7%9A%84%E9%94%AE"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">访问嵌套的键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E5%AD%90%E6%A0%91"><span class="toc-number">1.11.2.2.</span> <span class="toc-text">提取子树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.11.2.3.</span> <span class="toc-text">反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.11.2.4.</span> <span class="toc-text">序列化成字符串</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flag"><span class="toc-number">1.12.</span> <span class="toc-text">flag</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#os-Args"><span class="toc-number">1.12.1.</span> <span class="toc-text">os.Args</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flag%E5%8C%85%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.12.2.</span> <span class="toc-text">flag包基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flag%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.12.3.</span> <span class="toc-text">flag参数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">1.12.4.</span> <span class="toc-text">定义命令行参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#flag-Type"><span class="toc-number">1.12.4.1.</span> <span class="toc-text">flag.Type()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flag-TypeVar"><span class="toc-number">1.12.4.2.</span> <span class="toc-text">flag.TypeVar()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flage-Parse"><span class="toc-number">1.12.5.</span> <span class="toc-text">flage.Parse()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flag%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.6.</span> <span class="toc-text">flag其他函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">1.12.7.</span> <span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E6%8F%90%E7%A4%BA"><span class="toc-number">1.12.7.1.</span> <span class="toc-text">命令行使用提示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E7%89%87"><span class="toc-number">1.13.</span> <span class="toc-text">切片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E6%95%B0%E7%BB%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.13.1.</span> <span class="toc-text">和数组对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.13.2.</span> <span class="toc-text">切片的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E6%89%A9%E5%AE%B9%E7%AD%96%E7%95%A5"><span class="toc-number">1.13.3.</span> <span class="toc-text">切片的扩容策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.13.4.</span> <span class="toc-text">切片的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E9%95%BF%E5%BA%A6%E5%92%8C%E5%AE%B9%E9%87%8F"><span class="toc-number">1.13.4.1.</span> <span class="toc-text">切片的长度和容量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.13.4.2.</span> <span class="toc-text">切片表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%88%87%E7%89%87%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.13.4.2.1.</span> <span class="toc-text">简单切片表达式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E5%88%87%E7%89%87%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.13.4.2.2.</span> <span class="toc-text">完整切片表达式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8make%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E5%88%87%E7%89%87"><span class="toc-number">1.13.4.3.</span> <span class="toc-text">使用make函数构造切片</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E6%AF%94%E8%BE%83"><span class="toc-number">1.13.5.</span> <span class="toc-text">切片不能直接比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E8%B5%8B%E5%80%BC%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.13.6.</span> <span class="toc-text">切片的赋值拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#append%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">1.13.7.</span> <span class="toc-text">append添加元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copy%E5%87%BD%E6%95%B0%E5%A4%8D%E5%88%B6%E5%88%87%E7%89%87"><span class="toc-number">1.13.8.</span> <span class="toc-text">copy函数复制切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%88%87%E7%89%87%E4%B8%AD%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.13.9.</span> <span class="toc-text">从切片中删除元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.14.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.14.1.</span> <span class="toc-text">数组定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.14.2.</span> <span class="toc-text">数组的初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E8%AE%BE%E7%BD%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.14.2.1.</span> <span class="toc-text">初始化列表设置数组元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A9%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E8%A1%8C%E6%8E%A8%E6%96%AD%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6"><span class="toc-number">1.14.3.</span> <span class="toc-text">让编译器自行推断数组长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84"><span class="toc-number">1.14.4.</span> <span class="toc-text">使用索引值初始化数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.15.</span> <span class="toc-text">多维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.15.1.</span> <span class="toc-text">多维数组的定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.16.</span> <span class="toc-text">Go的类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.16.1.</span> <span class="toc-text">Go语言中类型推断的特性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Effective-Go"><span class="toc-number">2.</span> <span class="toc-text">Effective Go</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D"><span class="toc-number">2.1.</span> <span class="toc-text">命名</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Getters"><span class="toc-number">2.1.1.</span> <span class="toc-text">Getters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%90%8D"><span class="toc-number">2.1.2.</span> <span class="toc-text">接口名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">2.2.</span> <span class="toc-text">遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Switch"><span class="toc-number">2.3.</span> <span class="toc-text">Switch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%91%BD%E5%90%8D%E7%BB%93%E6%9E%9C%E5%BD%A2%E5%8F%82"><span class="toc-number">2.4.1.</span> <span class="toc-text">可命名结果形参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defer"><span class="toc-number">2.4.2.</span> <span class="toc-text">defer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">2.5.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new-%E5%88%86%E9%85%8D"><span class="toc-number">2.5.1.</span> <span class="toc-text">new 分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%8D%E5%90%88%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">2.5.2.</span> <span class="toc-text">构造函数与复合字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#make%E5%88%86%E9%85%8D"><span class="toc-number">2.5.3.</span> <span class="toc-text">make分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E5%88%87%E7%89%87"><span class="toc-number">2.5.4.</span> <span class="toc-text">二维切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84"><span class="toc-number">2.5.5.</span> <span class="toc-text">映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Print"><span class="toc-number">2.5.6.</span> <span class="toc-text">Print</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.6.</span> <span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">2.6.1.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#init-%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.2.</span> <span class="toc-text">init 函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">2.7.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.8.</span> <span class="toc-text">接口和其他类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.8.1.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%BD%AC%E6%8D%A2%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">2.8.2.</span> <span class="toc-text">接口转换与类型断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%80%A7"><span class="toc-number">2.8.3.</span> <span class="toc-text">通用性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">2.8.4.</span> <span class="toc-text">接口和方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E7%99%BD%E8%A1%A8%E7%A4%BA%E7%AC%A6"><span class="toc-number">2.9.</span> <span class="toc-text">空白表示符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%B5%8B%E5%80%BC%E4%B8%AD%E7%9A%84%E7%A9%BA%E7%99%BD%E8%A1%A8%E7%A4%BA%E7%AC%A6"><span class="toc-number">2.9.1.</span> <span class="toc-text">多重赋值中的空白表示符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AF%BC%E5%85%A5%E5%92%8C%E5%8F%98%E9%87%8F"><span class="toc-number">2.9.2.</span> <span class="toc-text">未使用的导入和变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E7%99%BD%E5%AF%BC%E5%85%A5"><span class="toc-number">2.9.3.</span> <span class="toc-text">空白导入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%A3%80%E6%9F%A5"><span class="toc-number">2.9.4.</span> <span class="toc-text">接口检查</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%80"><span class="toc-number">2.9.4.1.</span> <span class="toc-text">类型一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%BA%8C"><span class="toc-number">2.9.4.2.</span> <span class="toc-text">类型二</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%B5%8C"><span class="toc-number">2.10.</span> <span class="toc-text">内嵌</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%86%85%E5%B5%8C"><span class="toc-number">2.10.1.</span> <span class="toc-text">接口内嵌</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%B5%8C"><span class="toc-number">2.10.2.</span> <span class="toc-text">结构体内嵌</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A6%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">2.10.3.</span> <span class="toc-text">另一个例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">2.11.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Goroutines"><span class="toc-number">2.11.1.</span> <span class="toc-text">Goroutines</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Channels"><span class="toc-number">2.11.2.</span> <span class="toc-text">Channels</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E9%81%93%E7%9A%84%E4%BF%A1%E9%81%93"><span class="toc-number">2.11.3.</span> <span class="toc-text">信道的信道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%8C%96"><span class="toc-number">2.11.4.</span> <span class="toc-text">并行化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%BA%A2%E5%87%BA%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">2.11.5.</span> <span class="toc-text">可溢出的缓冲区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF"><span class="toc-number">2.12.</span> <span class="toc-text">错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Panic"><span class="toc-number">2.12.1.</span> <span class="toc-text">Panic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D"><span class="toc-number">2.12.2.</span> <span class="toc-text">恢复</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/27/go-Makefile/" title="Makefile">Makefile</a><time datetime="2023-05-27T10:34:23.147Z" title="发表于 2023-05-27 18:34:23">2023-05-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/27/flag&amp;&amp;args/" title="flag &amp; args">flag &amp; args</a><time datetime="2023-05-27T10:33:15.051Z" title="发表于 2023-05-27 18:33:15">2023-05-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/27/Golang%20Note/" title="goland note">goland note</a><time datetime="2023-05-27T10:32:12.127Z" title="发表于 2023-05-27 18:32:12">2023-05-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/09/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81CDN/" title="正向代理、反向代理、CDN">正向代理、反向代理、CDN</a><time datetime="2023-05-09T15:33:35.034Z" title="发表于 2023-05-09 23:33:35">2023-05-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/09/sentinel/" title="Sentinel限流、熔断、降级">Sentinel限流、熔断、降级</a><time datetime="2023-05-09T15:33:24.742Z" title="发表于 2023-05-09 23:33:24">2023-05-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By GDshenqingNo1</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>