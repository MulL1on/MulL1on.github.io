<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Makefile</title>
      <link href="/2023/05/27/go-Makefile/"/>
      <url>/2023/05/27/go-Makefile/</url>
      
        <content type="html"><![CDATA[<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><h2 id="make介绍"><a href="#make介绍" class="headerlink" title="make介绍"></a>make介绍</h2><p><code>make</code>是一个构建自动化工具，会在当前目录下寻找<code>Makefile</code>或<code>makefile</code>文件。如果存在相应的文件，它就会依据其中定义好的规则完成构建任务。</p><h2 id="Makefile介绍"><a href="#Makefile介绍" class="headerlink" title="Makefile介绍"></a>Makefile介绍</h2><p>可以把<code>Makefile</code>简单理解为定义了一个项目文件的编译规则。借助<code>Makefile</code>我们可以在编译过程中不在需要每次手动输入编译的命令和编译的参数，可以极大简化项目编译过程。同时使用<code>Makefile</code>文件，也可以在项目中确定具体的编译规则和流程，很多开源项目中都会定义<code>Makefile</code>文件。</p><h3 id="规则概述"><a href="#规则概述" class="headerlink" title="规则概述"></a>规则概述</h3><p><code>Makefile</code>由多条规则组成，每条规则主要由两个部分组成，分别是依赖的关系和执行的命令。</p><p>其结构如下所示：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[target] ... : [prerequisites]</span><br><span class="line">&lt;tab&gt;[command]</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>targets：规则的目标</li><li>prerequistites：可选的要生成targets需要的文件或是目标</li><li>command：<code>make</code>需要执行的命令（任意的shell命令)。可以有多条命令，每一条命令占一行</li></ul><p>例如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">build:</span></span><br><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o xx</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all build run gotool clean help</span></span><br><span class="line"></span><br><span class="line">BINARY=<span class="string">&quot;bluebell&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: gotool build</span></span><br><span class="line"></span><br><span class="line"><span class="section">build: </span></span><br><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o $&#123;BINARY&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">run:</span></span><br><span class="line">@go run ./</span><br><span class="line"></span><br><span class="line">go tool:</span><br><span class="line">go fmt ./</span><br><span class="line">go vet ./</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">@if [ -f $&#123;BINARY&#125;] ; then rm $&#123;BINARY&#125; ; fi</span><br><span class="line"></span><br><span class="line"><span class="section">help:</span></span><br><span class="line">@echo <span class="string">&quot;make -格式化 Go 代码, 并编译生成二进制文件&quot;</span></span><br><span class="line">@echo <span class="string">&quot;make build -编译 Go 代码, 生成二进制文件&quot;</span></span><br><span class="line">@echo <span class="string">&quot;make run -直接运行 Go 代码&quot;</span></span><br><span class="line">@echo <span class="string">&quot;make clean - 移除二进制文件和 vim swap files&quot;</span></span><br><span class="line">@echo <span class="string">&quot;make gotool - 运行 Go 工具 &#x27;fmt&#x27; and &#x27;vet&#x27;&quot;</span><span class="string">&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>flag &amp; args</title>
      <link href="/2023/05/27/flag&amp;&amp;args/"/>
      <url>/2023/05/27/flag&amp;&amp;args/</url>
      
        <content type="html"><![CDATA[<h1 id="flag-amp-amp-arg"><a href="#flag-amp-amp-arg" class="headerlink" title="flag&amp;&amp;arg"></a>flag&amp;&amp;arg</h1><p>falg.Parse()解析命令行参数时是从程序名后的第一个参数开始的，如果这个参数不是合法的flag的形式（例如，不是’-flag’或者’–flag’的形式），则会停止解析，将剩余参数作为位置参数（即os.Args)处理</p><p>例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go baidu.com -l 64</span><br></pre></td></tr></table></figure><p>main.go是程序名，也是os.Args的第一个参数即os.Args[0]</p><p>随后baidu.com作为flag的一个参数，但不符合flag的形式，于是flag.Parse()终止了</p><p>baidu.com随后作为os.Args的第二个参数，即os.Args[1]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>goland note</title>
      <link href="/2023/05/27/Golang%20Note/"/>
      <url>/2023/05/27/Golang%20Note/</url>
      
        <content type="html"><![CDATA[<h1 id="Golang-Note-Fundamental"><a href="#Golang-Note-Fundamental" class="headerlink" title="Golang Note Fundamental"></a>Golang Note Fundamental</h1><h2 id="前面写的没啥用的东西"><a href="#前面写的没啥用的东西" class="headerlink" title="前面写的没啥用的东西"></a>前面写的没啥用的东西</h2><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><p>1.json.Unmarshal 只能传指针</p><p>2.struct内的字段名要大写才能被json访问，如果要求转化为json后字段名为小写可以在字段明后加上</p><p><code>json:小写</code></p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>1.map必须初始化才能使用</p><h3 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h3><p>是把任意长度的<a href="https://baike.baidu.com/item/%E8%BE%93%E5%85%A5/5481954?fromModule=lemma_inlink">输入</a>（又叫做预映射pre-image）通过散列算法变换成固定长度的<a href="https://baike.baidu.com/item/%E8%BE%93%E5%87%BA/11056752?fromModule=lemma_inlink">输出</a>，该输出就是散列值。这种转换是一种<a href="https://baike.baidu.com/item/%E5%8E%8B%E7%BC%A9%E6%98%A0%E5%B0%84/5114126?fromModule=lemma_inlink">压缩映射</a>，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。</p><p>简单的说就是一种将任意长度的消息压缩到某一固定长度的<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81/4547744?fromModule=lemma_inlink">消息摘要</a>的函数。</p><h4 id="HMAC-Hash-based-Message-Authentication-Code"><a href="#HMAC-Hash-based-Message-Authentication-Code" class="headerlink" title="HMAC(Hash-based Message Authentication Code)"></a>HMAC(Hash-based Message Authentication Code)</h4><p>①消息完整性认证：能够证明消息内容在传送过程没有被修改。</p><p>②信源身份认证：因为通信双方共享了认证的密钥，接收方能够认证发送该数据的信源与所宣称的一致，即能够可靠地确认接收的消息与发送的一致。</p><p>HMAC运算利用hash算法，以一个消息M和一个密钥K作为输入，生成一个定长的消息摘要作为输出。HMAC算法利用已有的Hash函数，关键问题是如何使用密钥。</p><h3 id="JWT（-Json-web-token）"><a href="#JWT（-Json-web-token）" class="headerlink" title="JWT（ Json web token）"></a>JWT（ Json web token）</h3><ul><li>用户使用用户名密码来请求服务器</li><li>服务器进行验证用户的信息</li><li>服务器通过验证发送给用户一个token</li><li>客户端存储token，并在每次请求时附送上这个token值</li><li>服务端验证token值，并返回数据</li></ul><p>在gin框架下使用JWT</p><p>1.定义一个用于签名的字符串</p><p>2.创建一个claim （自定义Claim或者默认Claim)</p><p>3.生成token</p><p>4.客户端发送携带token的请求</p><p>5.解析token，获取token中的claim</p><p>6.将claim想要的信息保存在c上下文中，后续函数可以通过c.Get()获取这个信息，实现身份验证。</p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>Gin框架允许开发者在处理请求的过程中 ，加入用户自己的逻辑函数，这个逻辑函数就被成为中间键，中间间适合处理一些公共逻辑，比如登录认证、权限校验、记录日志、耗时统计等。</p><p>同时也可以通过<code>c.Next</code>和<code>c.Abort</code>决定是否请求走向下一个中间件</p><h2 id="Golang中蛋疼的三个点"><a href="#Golang中蛋疼的三个点" class="headerlink" title="Golang中蛋疼的三个点"></a>Golang中蛋疼的三个点</h2><p>”…“其实是golang的一种语法糖</p><h3 id="函数的不定参数"><a href="#函数的不定参数" class="headerlink" title="函数的不定参数"></a>函数的不定参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(args ...<span class="type">string</span>)</span></span>  &#123;  <span class="comment">//可以接收任意多个string参数，此时args是切片</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> args&#123;</span><br><span class="line">fmt.Println(index, <span class="string">&quot; : &quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := []<span class="type">string</span> &#123;</span><br><span class="line"><span class="string">&quot;ABC&quot;</span>,</span><br><span class="line"><span class="string">&quot;DEF&quot;</span>,</span><br><span class="line"><span class="string">&quot;GHI&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">test1(str...)  <span class="comment">//切片被打散传入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切片的打散"><a href="#切片的打散" class="headerlink" title="切片的打散"></a>切片的打散</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := []<span class="type">string</span> &#123;</span><br><span class="line"><span class="string">&quot;ABC&quot;</span>,</span><br><span class="line"><span class="string">&quot;DEF&quot;</span>,</span><br><span class="line"><span class="string">&quot;GHI&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(str)</span><br><span class="line">str = <span class="built_in">append</span>(str[<span class="number">0</span>:<span class="number">1</span>], str[<span class="number">2</span>:]...) <span class="comment">//将slice打散然后合并，否则需要传入元素而不能传入切片</span></span><br><span class="line">fmt.Println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组自行推断数组的长度"><a href="#数组自行推断数组的长度" class="headerlink" title="数组自行推断数组的长度"></a>数组自行推断数组的长度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var numArray = [...]int&#123;1, 2&#125;</span><br></pre></td></tr></table></figure><h2 id="Context上下文"><a href="#Context上下文" class="headerlink" title="Context上下文"></a>Context上下文</h2><h3 id="Context概念"><a href="#Context概念" class="headerlink" title="Context概念"></a>Context概念</h3><p>Go1.7加入了一个新的标准库<code>context</code>，它定义了<code>Context</code>类型，专门用来简化 对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。</p><p>对服务器传入的请求应该创建上下文，而对服务器的传出调用应该接受上下文。它们之间的函数调用链必须传递上下文，或者可以使用<code>WithCancel</code>、<code>WithDeadline</code>、<code>WithTimeout</code>或<code>WithValue</code>创建的派生上下文。当一个上下文被取消时，它派生的所有上下文也被取消。</p><p>&#x2F;&#x2F;context的功能也可以手搓（定义全局变量，channel等方法），<code>context</code>相当于官方提供的解决方案，建立的一种标准，方便程序员之间阅读。</p><h3 id="Context接口"><a href="#Context接口" class="headerlink" title="Context接口"></a>Context接口</h3><p><code>context.Context</code>是一个接口，该接口定义了四个需要实现的方法。具体签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.<code>Deadline</code>方法返回当前<code>Context</code>被取消的时间</p><p>2.<code>Done</code>方法返回一个<code>Channel</code>,这个<code>Channel</code>在当前工作完成或者上下文被取消后关闭，多次调用<code>Done</code>方法返回同一个<code>Channel</code></p><p>3.Err方法返回当前<code>Context</code>结束的原因，它只会在<code>Done</code>返回的<code>Channel</code>被关闭时才会返回非空的值</p><p>&#x2F;&#x2F;当前<code>Context</code>被取消就会返回<code>Canceled</code>错误；</p><p>&#x2F;&#x2F;当前<code>Context</code>超时就会返回<code>DeadlineExcceeded</code>错误；</p><p>4.<code>Value</code>方法会从<code>Context</code>中返回<code>Key</code>对应的值，对同一个上下文，多次调用<code>Value</code>并传入相同的</p><p><code>Key</code>会返回相同的结果，该方法仅用于传递跨API和进程间跟请求域的数据；</p><h3 id="Background-和TODO"><a href="#Background-和TODO" class="headerlink" title="Background()和TODO()"></a>Background()和TODO()</h3><p>两个函数分别返回一个实现了<code>Context</code>接口的<code>background</code>和<code>todo</code>。我们代码中最开始都是以这两个内置的上下文对象作为最顶层的<code>partent context</code>，衍生出更多的子上下文对象。</p><p><code>background</code>和<code>todo</code>本质上都是<code>emptyCtx</code>结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context。</p><h3 id="With系列函数"><a href="#With系列函数" class="headerlink" title="With系列函数"></a>With系列函数</h3><h4 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a>WithCancel</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)</span><br></pre></td></tr></table></figure><p><code>WithCancel</code>返回带有新<code>Done</code>通道的父节点的副本。当调用<code>cancel</code>方法或关闭父上下文的<code>Done</code>通道时，将关闭返回的上下文的<code>Done</code>通道。</p><p>调用<code>Cancel</code>方法会查找对应<code>context</code>的全部<code>Done</code>通道,并关闭从而实现关闭子Goroutine的功能。</p><h4 id="WithDeadline"><a href="#WithDeadline" class="headerlink" title="WithDeadline"></a>WithDeadline</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span></span> (Context, CancelFunc)</span><br></pre></td></tr></table></figure><p>返回父上下文的副本，并将deadline调整为不迟于d。如果父上下文的deadline已经早于d，则WithDeadline(parent, d)在语义上等同于父上下文。当截止日过期时，当调用返回的cancel函数时，或者当父上下文的Done通道关闭时，返回上下文的Done通道将被关闭，<strong>以最先发生的情况为准</strong>。</p><h4 id="WithTimeout"><a href="#WithTimeout" class="headerlink" title="WithTimeout"></a>WithTimeout</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br></pre></td></tr></table></figure><p>与<code>WithDeadline</code>类似，不同在于<code>WithTimeout</code>设置一段时间，而<code>WithDeaddline</code>设置一个时间点。</p><h4 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a>WithValue</h4><p><code>WithValue</code>函数能够将请求作用域的数据与 Context 对象建立关系。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context</span><br></pre></td></tr></table></figure><p>其中<code>key</code>不能是<code>string</code>或任何内置类型，以避免使用上下文在包之间发生冲突，要定义自己的类型。</p><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><h3 id="一般格式"><a href="#一般格式" class="headerlink" title="一般格式"></a>一般格式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x,err:=interfaceText.(T)</span><br></pre></td></tr></table></figure><p>如果转换合法，则<code>x</code>为<code>InterfaceText</code>转换为类型<code>T</code>值，<code>err</code>为<code>ture</code>，反之<code>err</code>为<code>false</code>。</p><h3 id="特殊用法"><a href="#特殊用法" class="headerlink" title="特殊用法"></a>特殊用法</h3><p>可以用于判断某个类型是否实现了某个接口。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ discovery.Resolver = (*consulResolver)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>这段代码中将一个<code>nil</code>指针转换成<code>*consulResolver</code>类型，并判断该类型是否实现了<code>discovery.Resolver</code>接口，如果实现了，则不会产生编译错误；如果没有实现，则会产生并编译错误。</p><p>在go语言中，我们经常需要判断某个类型是否实现了某个接口，可以通过这种方式进行静态检查，避免在运行时出现类型错误。</p><p>这种类型断言的写法，一般用于声明某个类型实现了某个接口，但是不需要使用该接口的任何方法。在这种情况下，我们使用一个空白标识符<code>_</code>来表示该接口，而不需要给它起一个变量名。</p><h3 id="type-switch"><a href="#type-switch" class="headerlink" title="type-switch"></a>type-switch</h3><p>和switch很相似,如果InterfaceText中有*Square,*Circle,nil三种类型，就会执行对应的代码，若都没有，便会执行default里的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> InterfaceText.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> *Square:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;text:%v&quot;</span>,i)</span><br><span class="line">    <span class="keyword">case</span> *Circle:</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    <span class="comment">//..and so forth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="net-x2F-http"><a href="#net-x2F-http" class="headerlink" title="net&#x2F;http"></a>net&#x2F;http</h2><h4 id="net-x2F-http介绍"><a href="#net-x2F-http介绍" class="headerlink" title="net&#x2F;http介绍"></a>net&#x2F;http介绍</h4><p><code>net/http</code>是Go内置的包，提供HTTP客户端和服务端的实现。</p><h4 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h4><p>我们的浏览器其实就是一个发送和接收HTTP协议数据的客户端，我们平时通过浏览器访问网页其实就是从网站的服务器接收HTTP数据，然后浏览器会按照HTML、CSS等规则将网页渲染展示出来</p><h6 id="基本的http-x2F-https请求"><a href="#基本的http-x2F-https请求" class="headerlink" title="基本的http&#x2F;https请求"></a>基本的http&#x2F;https请求</h6><p>Get、Head、Post和PostForm函数发出HTTP&#x2F;HTTPS请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">&quot;http://example.com/&quot;</span>)</span><br><span class="line">...</span><br><span class="line">resp, err := http.Post(<span class="string">&quot;http://example.com/upload&quot;</span>, <span class="string">&quot;image/jpeg&quot;</span>, &amp;buf)</span><br><span class="line">...</span><br><span class="line">resp, err := http.PostForm(<span class="string">&quot;http://example.com/form&quot;</span>,</span><br><span class="line">url.Values&#123;<span class="string">&quot;key&quot;</span>: &#123;<span class="string">&quot;Value&quot;</span>&#125;, <span class="string">&quot;id&quot;</span>: &#123;<span class="string">&quot;123&quot;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>程序在使用完response后必须关闭回复的<code>body</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">&quot;http://example.com/&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h6 id="不带参数Get请求示例"><a href="#不带参数Get请求示例" class="headerlink" title="不带参数Get请求示例"></a>不带参数Get请求示例</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">resp, err := http.Get(<span class="string">&quot;https://www.liwenzhou.com/&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;get failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;read from resp.Body failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="带参数的GET请求示例"><a href="#带参数的GET请求示例" class="headerlink" title="带参数的GET请求示例"></a>带参数的GET请求示例</h6><p>要使用<code>net/url</code>这个包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">apiUrl := <span class="string">&quot;http://127.0.0.1:9090/get&quot;</span></span><br><span class="line"><span class="comment">// URL param</span></span><br><span class="line">data := url.Values&#123;&#125;</span><br><span class="line">data.Set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小王子&quot;</span>)</span><br><span class="line">data.Set(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;18&quot;</span>)</span><br><span class="line">u, err := url.ParseRequestURI(apiUrl)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;parse url requestUrl failed, err:%v\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">u.RawQuery = data.Encode() <span class="comment">// URL encode</span></span><br><span class="line">fmt.Println(u.String())</span><br><span class="line">resp, err := http.Get(u.String())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;post failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">b, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;get resp failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="type">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应Server端HandlerFunc：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> r.Body.Close()</span><br><span class="line">data := r.URL.Query()</span><br><span class="line">fmt.Println(data.Get(<span class="string">&quot;name&quot;</span>))</span><br><span class="line">fmt.Println(data.Get(<span class="string">&quot;age&quot;</span>))</span><br><span class="line">answer := <span class="string">`&#123;&quot;status&quot;: &quot;ok&quot;&#125;`</span></span><br><span class="line">w.Write([]<span class="type">byte</span>(answer))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>URL类型代表一个解析后的URL（或者说，一个URL参照）。URL基本格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme://[userinfo@]host/path[?query][#fragment]</span><br></pre></td></tr></table></figure><h6 id="POST请求示例"><a href="#POST请求示例" class="headerlink" title="POST请求示例"></a>POST请求示例</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">apiUrl := <span class="string">&quot;http://127.0.0.1:9090/get&quot;</span></span><br><span class="line"><span class="comment">// URL param</span></span><br><span class="line">data := url.Values&#123;&#125;</span><br><span class="line">data.Set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小王子&quot;</span>)</span><br><span class="line">data.Set(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;18&quot;</span>)</span><br><span class="line">u, err := url.ParseRequestURI(apiUrl)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;parse url requestUrl failed, err:%v\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">u.RawQuery = data.Encode() <span class="comment">// URL encode</span></span><br><span class="line">fmt.Println(u.String())</span><br><span class="line">resp, err := http.Get(u.String())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;post failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">b, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;get resp failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="type">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;待完善&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p><h2 id="在Go中使用MySQL"><a href="#在Go中使用MySQL" class="headerlink" title="在Go中使用MySQL"></a>在Go中使用MySQL</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>Go语言中的<code>database/sql</code>包提供了保证SQL或类SQL数据库的泛用接口，并不提供具体的数据库驱动。使用<code>database/sql</code>包时必须注入（至少）一个数据库驱动。</p><h4 id="访问数据库"><a href="#访问数据库" class="headerlink" title="访问数据库"></a>访问数据库</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(driverName, dataSourceName <span class="type">string</span>)</span></span> (*DB, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;database/sql&quot;</span></span><br><span class="line"></span><br><span class="line">_ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// DSN:Data Source Name</span></span><br><span class="line">dsn := <span class="string">&quot;[用户名[:密码]@][协议[(地址:端口)]]/dbname[?param1=value1&amp;...&amp;paramN=valueN]&quot;</span></span><br><span class="line">db, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, dsn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> db.Close()  <span class="comment">// 注意这行代码要写在上面err判断的下面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化连接"><a href="#初始化连接" class="headerlink" title="初始化连接"></a>初始化连接</h4><p>Open函数可能只是验证其参数格式是否正确，实际上并不创建与数据库的连接。如果要检查数据源的名称是否真实有效，应该调用Ping方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">err = db.Ping()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个全局变量<code>db</code>保存数据库连接对象<code>var db *sql.DB</code></p><p>将上面的代码包装成一个<code>initDB</code>函数，只需在启动时调用一次函数完成全局变量<code>db</code>的初始化，其他函数就可以直接使用全局变量<code>db</code></p><h4 id="SetMaxOpenConns"><a href="#SetMaxOpenConns" class="headerlink" title="SetMaxOpenConns"></a><del>SetMaxOpenConns</del></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> SetMaxOpenConns(n <span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>设置与数据库<strong>建立连接的最大数目</strong>。</p><p>如果n大于0且小于<strong>最大闲置连接数</strong>，会将<strong>最大闲置连接数</strong>减小到匹配<strong>最大开启连接数</strong>的限制。 如果n&lt;&#x3D;0，不会限制最大开启连接数，默认为0（无限制）。</p><h4 id="SetMaxIdleConns"><a href="#SetMaxIdleConns" class="headerlink" title="SetMaxIdleConns"></a><del>SetMaxIdleConns</del></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> SetMaxIdleConns(n <span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>设置连接池中的<strong>最大闲置连接数</strong>。</p><p>如果n大于<strong>最大开启连接数</strong>，则新的<strong>最大闲置连接数</strong>会减小到匹配<strong>最大开启连接数</strong>的限制。 如果n&lt;&#x3D;0，不会保留闲置连接。</p><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p><strong>多行检索</strong></p><p><code>db.Query()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">rows, err := db.Query(<span class="string">&quot;select * from stu where id= ?&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  延迟调用关闭rows释放持有的数据库链接</span></span><br><span class="line">    <span class="keyword">defer</span> rows.Close()</span><br><span class="line">    <span class="keyword">var</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">        name    <span class="type">string</span></span><br><span class="line">        id      <span class="type">int</span></span><br><span class="line">        math    <span class="type">int</span></span><br><span class="line">        english <span class="type">int</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  迭代查询获取数据</span></span><br><span class="line">    <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">        err := rows.Scan(&amp;user.id, &amp;user.name, &amp;user.math, &amp;user.english)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(user)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​<strong>单行检索</strong></p><p><code>db.QueryRow()</code> QueryRow总是返回非nil的值，知道返回值的Scan方法被调用时，才会返回被延迟的错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">row := db.QueryRow(<span class="string">&quot;select * from stu where id=?&quot;</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">var</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">        name    <span class="type">string</span></span><br><span class="line">        id      <span class="type">int</span></span><br><span class="line">        math    <span class="type">int</span></span><br><span class="line">        english <span class="type">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    err = row.Scan(&amp;user.id, &amp;user.name, &amp;user.math, &amp;user.english)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(user)</span><br></pre></td></tr></table></figure><h3 id="增-x2F-改-x2F-删"><a href="#增-x2F-改-x2F-删" class="headerlink" title="增&#x2F;改&#x2F;删"></a>增&#x2F;改&#x2F;删</h3><p>GO中使用<code>Exec()</code>实现MySQL中的<code>insert</code> <code>update</code> <code>delete</code>操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Exec(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>​arg表示占位符中的任何参数，Result是对已执行的SQL命令的总结。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result, err := db.Exec(<span class="string">&quot;insert into stu (name ,math ,english) value (?,?,?)&quot;</span>, <span class="string">&quot;小j&quot;</span>, <span class="number">100</span>, <span class="number">120</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新插入数据的id</span></span><br><span class="line">    result.LastInsertId()</span><br><span class="line">    <span class="comment">// 返回影响的行数</span></span><br><span class="line">    result.RowsAffected()</span><br></pre></td></tr></table></figure><p><strong>删除数据</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result, err := db.Exec(<span class="string">&quot;delete from stu where id=?&quot;</span>, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新插入数据的id</span></span><br><span class="line">    result.LastInsertId()</span><br><span class="line">    <span class="comment">// 返回影响的行数</span></span><br><span class="line">    result.RowsAffected()</span><br></pre></td></tr></table></figure><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>预处理是 MySQL 为了防止客户端频繁请求的一种技术，是对相同处理语句进行预先加载在 MySQL 中，将操作变量数据用占位符来代替，减少对 MySQL 的频繁请求，使得服务器高效运行。</p><p><code>Prepare</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Prepare(query <span class="type">string</span>) (*Stmt, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>Prepare</code>方法会先将sql语句发送给MySQL服务端，返回一个准备好的状态<code>*Stmt</code>用于之后的查询和命令。返回值可以同时执行多个查询和命令。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stmt, err := db.Prepare(<span class="string">&quot;select * from stu where id= ?&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;prepare failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> stmt.Close()<span class="comment">//记得关闭状态连接</span></span><br></pre></td></tr></table></figure><p>此时查询写为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rows, err := stmt.Query(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>其他删除 更新 插入操作类似</p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p><strong><code>os.Create（）</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="type">string</span>)</span></span> (file *File, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>Create采用模式0666（任何人都可读写，不可执行）创建一个名为name的文件，如果文件已存在会截断它（为空文件）。如果成功，返回的文件对象可用于I&#x2F;O；对应的文件描述符具有O_RDWR模式。</p><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p><strong><code>os.Open()</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="type">string</span>)</span></span> (file *File, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>打开的文件只能用于读操作</p><p><strong><code>os.OpenFile()</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (file *File, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><strong>flag表示指定的选项&#x2F;&#x2F;&#x2F;&#x2F;<em>&#x2F;异或操作</em></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    O_RDONLY <span class="type">int</span> = syscall.O_RDONLY <span class="comment">// 只读模式打开文件</span></span><br><span class="line">    O_WRONLY <span class="type">int</span> = syscall.O_WRONLY <span class="comment">// 只写模式打开文件</span></span><br><span class="line">    O_RDWR   <span class="type">int</span> = syscall.O_RDWR   <span class="comment">// 读写模式打开文件</span></span><br><span class="line">    O_APPEND <span class="type">int</span> = syscall.O_APPEND <span class="comment">// 写操作时将数据附加到文件尾部</span></span><br><span class="line">    O_CREATE <span class="type">int</span> = syscall.O_CREAT  <span class="comment">// 如果不存在将创建一个新文件</span></span><br><span class="line">    O_EXCL   <span class="type">int</span> = syscall.O_EXCL   <span class="comment">// 和O_CREATE配合使用，文件必须不存在</span></span><br><span class="line">    O_SYNC   <span class="type">int</span> = syscall.O_SYNC   <span class="comment">// 打开文件用于同步I/O</span></span><br><span class="line">    O_TRUNC  <span class="type">int</span> = syscall.O_TRUNC  <span class="comment">// 如果可能，打开时清空文件</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="io流"><a href="#io流" class="headerlink" title="io流"></a>io流</h3><h4 id="Reader接口"><a href="#Reader接口" class="headerlink" title="Reader接口"></a>Reader接口</h4><p><code>type Reader</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Writer接口"><a href="#Writer接口" class="headerlink" title="Writer接口"></a>Writer接口</h4><p><code>tpye Writer</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>os.File 同时实现了 io.Reader 和 io.Writer</li><li>strings.Reader 实现了 io.Reader</li><li>strings.Builder 实现了 io.Writer</li><li>bufio.Reader&#x2F;Writer 分别实现了 io.Reader 和 io.Writer</li><li>bytes.Buffer 同时实现了 io.Reader 和 io.Writer</li><li>bytes.Reader 实现了 io.Reader</li><li>compress&#x2F;gzip.Reader&#x2F;Writer 分别实现了 io.Reader 和 io.Writer</li><li>crypto&#x2F;cipher.StreamReader&#x2F;StreamWriter 分别实现了 io.Reader 和 io.Writer</li><li>crypto&#x2F;tls.Conn 同时实现了 io.Reader 和 io.Writer</li><li>encoding&#x2F;csv.Reader&#x2F;Writer 分别实现了 io.Reader 和 io.Writer</li><li>mime&#x2F;multipart.Part 实现了 io.Reader</li><li>net&#x2F;conn 分别实现了 io.Reader 和 io.Writer(Conn接口定义了Read&#x2F;Write</li></ul><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><h4 id="普通读"><a href="#普通读" class="headerlink" title="普通读"></a><strong>普通读</strong></h4><p><strong><code>Read</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) Read(p []byte) (n int, err error)</span><br></pre></td></tr></table></figure><p>Read读取数据写入p。本方法返回写入p的字节数。本方法一次调用最多会调用下层Reader接口一次Read方法，因此返回值n可能小于len(p)。读取到达结尾时，返回值n将为0而err将为io.EOF。</p><h4 id="bufio读"><a href="#bufio读" class="headerlink" title="bufio读"></a><strong>bufio读</strong></h4><p><strong><code>bufio.NewReader</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span></span> *bufio.Reader</span><br></pre></td></tr></table></figure><p><code>NewReader</code>创建一个具有默认大小缓冲，从rd读取的*bufio.Reader</p><p><strong><code>type bufio.Reader</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">   buf          []<span class="type">byte</span></span><br><span class="line">   rd           io.Reader <span class="comment">// reader provided by the client</span></span><br><span class="line">   r, w         <span class="type">int</span>       <span class="comment">// buf read and write positions</span></span><br><span class="line">   err          <span class="type">error</span></span><br><span class="line">   lastByte     <span class="type">int</span> <span class="comment">// last byte read for UnreadByte; -1 means invalid</span></span><br><span class="line">   lastRuneSize <span class="type">int</span> <span class="comment">// size of last rune read for UnreadRune; -1 means invalid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>(*Reader)ReadBytes</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> Read(delim <span class="type">byte</span>) (line []<span class="type">byte</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><strong><code>(*Reader)ReadString</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> ReadString(delim <span class="type">byte</span>) (line <span class="type">string</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>ReadBytes</code>和<code>ReaderString</code>分别返回一个包含已读取的数据和delim字节的<code>[]Byte</code>和<code>string</code></p><p>如果在读取到<code>delim</code>之前遇到了错误，它会返回在错误之前读取的数据以及该错误（一般是<code>io.EOF</code>）。当且仅当<code>ReadString</code>方法返回的切片不以<code>delim</code>结尾时，会返回一个非<code>nil</code>的错误。</p><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><h4 id="普通写"><a href="#普通写" class="headerlink" title="普通写"></a>普通写</h4><p><strong><code>(*Writer)Write</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> Write(p []<span class="type">byte</span>) (nn <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><h4 id="bufio写"><a href="#bufio写" class="headerlink" title="bufio写"></a>bufio写</h4><p><strong><code>bufio.NewWriter</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(w io.Writer)</span></span> *bufio.Writer</span><br></pre></td></tr></table></figure><p>因为用bufio写所以要调用Flush方法将缓冲中的数据写入下层的io.Writer接口</p><p><strong><code>(*Writer)WriteByte</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> WriteByte(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><strong><code>(*Writer)WriteString</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> WriteString(s <span class="type">string</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>WriteByte</code>和<code>WriteString</code>分别写入一个字节切片和一个字符串，返回写入的字节数。如果返回值小于<code>len(s)</code>，还会返回一个错误说明原因。</p><p><strong><code>(*Write)Flush</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> Flush() <span class="type">error</span></span><br></pre></td></tr></table></figure><h2 id="Gorm"><a href="#Gorm" class="headerlink" title="Gorm"></a>Gorm</h2><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>连接不同的数据库都需要导入对应数据的驱动程序，<code>GORM</code>已经贴心的为我们包装了一些驱动程序，只需要按如下方式导入需要的数据库驱动即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span></span><br><span class="line"><span class="comment">// import _ &quot;github.com/jinzhu/gorm/dialects/postgres&quot;</span></span><br><span class="line"><span class="comment">// import _ &quot;github.com/jinzhu/gorm/dialects/sqlite&quot;</span></span><br><span class="line"><span class="comment">// import _ &quot;github.com/jinzhu/gorm/dialects/mssql&quot;</span></span><br></pre></td></tr></table></figure><p><strong>连接<code>mysql</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">  _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db, err := gorm.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;user:password@(localhost)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义GORM-Model"><a href="#定义GORM-Model" class="headerlink" title="定义GORM Model"></a>定义GORM Model</h3><p>在使用ORM工具时，通常我们需要在代码中定义模型（Models）与数据库中的数据表进行映射，在GORM中模型（Models）通常是正常定义的结构体、基本的go类型或它们的指针。 <del>同时也支持<code>sql.Scanner</code>及<code>driver.Valuer</code>接口（interfaces）。</del></p><h4 id="gorm-Model"><a href="#gorm-Model" class="headerlink" title="gorm.Model"></a>gorm.Model</h4><p>gorm.Model是Gorm内置的一个结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gorm.Model定义</span></span><br><span class="line"><span class="keyword">type</span> Model <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">uint</span> <span class="string">`gorm:&quot;primary_key&quot;`</span></span><br><span class="line">  CreatedAt time.Time</span><br><span class="line">  UpdatedAt time.Time</span><br><span class="line">  DeletedAt *time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以内嵌到自己的model中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以完全自己定义模型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">int</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体标记"><a href="#结构体标记" class="headerlink" title="结构体标记"></a>结构体标记</h4><p>支持的结构体标记</p><table><thead><tr><th align="left">结构体标记</th><th>描述</th></tr></thead><tbody><tr><td align="left">column</td><td>指定列名</td></tr><tr><td align="left">type</td><td>指定数据类型</td></tr><tr><td align="left">size</td><td>指定列大小，默认值为255</td></tr><tr><td align="left">primary_key</td><td>将列指定为主键</td></tr><tr><td align="left">unique</td><td>将列指定为唯一</td></tr><tr><td align="left">default</td><td>指定列默认值</td></tr><tr><td align="left">precision</td><td>指定列精度</td></tr><tr><td align="left">not null</td><td>将列指定为非null</td></tr><tr><td align="left">auto_increment</td><td>指定列<strong>是否</strong>为自增类型</td></tr><tr><td align="left">index</td><td>创建具有或不带名称的索引, 如果多个索引同名则创建复合索引</td></tr><tr><td align="left">unique_index</td><td>和 <code>INDEX</code> 类似，只不过创建的是唯一索引</td></tr><tr><td align="left">embedded</td><td>将结构设置为嵌入</td></tr><tr><td align="left">embeddedPrefix</td><td>设置嵌入结构的前缀</td></tr><tr><td align="left">&lt;-&#x2F;-&gt;</td><td>设置字段写入的权限， &lt;-:create 只创建、&lt;-:update 只更新、&lt;-:false 无写入权限、&lt;- 创建和更新权限。设置字段读的权限，<code>-&gt;:false</code> 无读权限</td></tr><tr><td align="left">-</td><td>忽略该字段，<code>-</code> 表示无读写，<code>-:migration</code> 表示无迁移权限，<code>-:all</code> 表示无读写迁移权限</td></tr></tbody></table><p>关联相关标记&#x2F;&#x2F;施工中&#x2F;&#x2F;</p><table><thead><tr><th>结构体标记</th><th>描述</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="主键、表名、列名的约定"><a href="#主键、表名、列名的约定" class="headerlink" title="主键、表名、列名的约定"></a>主键、表名、列名的约定</h4><h5 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h5><p>gorm默认使用名为ID的字段作为表的主键，也可以使用tag将指定字段设置为主键</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">string</span> <span class="comment">// 名为`ID`的字段会默认作为表的主键</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用`AnimalID`作为主键</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">  AnimalID <span class="type">int64</span> <span class="string">`gorm:&quot;primary_key&quot;`</span></span><br><span class="line">  Name     <span class="type">string</span></span><br><span class="line">  Age      <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="表名"><a href="#表名" class="headerlink" title="表名"></a>表名</h5><p>表名默认是结构体名称的小写复数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;&#125; <span class="comment">// 默认表名是 `users`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 User 的表名设置为 `profiles`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(User)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;profiles&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> u.Role == <span class="string">&quot;admin&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;admin_users&quot;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;users&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>禁用默认表名的复数形式，如果置为 true，则 <code>User</code> 的默认表名是 <code>user</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.SingularTable(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>也可以通过<code>Table()</code>指定表名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用User结构体创建名为`deleted_users`的表</span></span><br><span class="line">db.Table(<span class="string">&quot;deleted_users&quot;</span>).CreateTable(&amp;User&#123;&#125;)</span><br></pre></td></tr></table></figure><h5 id="列名"><a href="#列名" class="headerlink" title="列名"></a>列名</h5><p>列名由字段名称进行下划线分割来生成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">uint</span>      <span class="comment">// column name is `id`</span></span><br><span class="line">  Name      <span class="type">string</span>    <span class="comment">// column name is `name`</span></span><br><span class="line">  Birthday  time.Time <span class="comment">// column name is `birthday`</span></span><br><span class="line">  CreatedAt time.Time <span class="comment">// column name is `created_at`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用tag指定列名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">  AnimalId    <span class="type">int64</span>     <span class="string">`gorm:&quot;column:beast_id&quot;`</span>         <span class="comment">// set column name to `beast_id`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><h5 id="创建记录"><a href="#创建记录" class="headerlink" title="创建记录"></a>创建记录</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>, Age: <span class="number">18</span>, Birthday: time.Now()&#125;</span><br><span class="line"></span><br><span class="line">result := db.Create(&amp;user) <span class="comment">// 通过数据的指针来创建</span></span><br><span class="line"></span><br><span class="line">user.ID             <span class="comment">// 返回插入数据的主键</span></span><br><span class="line">result.Error        <span class="comment">// 返回 error</span></span><br><span class="line">result.RowsAffected <span class="comment">// 返回插入记录的条数</span></span><br></pre></td></tr></table></figure><h5 id="用指定字段创建记录"><a href="#用指定字段创建记录" class="headerlink" title="用指定字段创建记录"></a>用指定字段创建记录</h5><p>创建记录并更新给出的字段<code>select</code><strong>传入的字段名应该是结构体的字段名而不是数据表的字段名</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;CreatedAt&quot;</span>).Create(&amp;user)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`,`age`,`created_at`) VALUES (&quot;jinzhu&quot;, 18, &quot;2020-07-04 11:05:21.775&quot;)</span></span><br></pre></td></tr></table></figure><p>创建记录切忽略传递给略去的字段<code>omit</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Omit(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;CreatedAt&quot;</span>).Create(&amp;user)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`birthday`,`updated_at`) VALUES (&quot;2020-01-01 00:00:00.000&quot;, &quot;2020-07-04 11:05:21.775&quot;)</span></span><br></pre></td></tr></table></figure><h5 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h5><p>可以将一个切片传递给Create方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;Name: <span class="string">&quot;jinzhu1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu2&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu3&quot;</span>&#125;&#125;</span><br><span class="line">db.Create(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> users &#123;</span><br><span class="line">  user.ID <span class="comment">// 1,2,3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建钩子-hook"><a href="#创建钩子-hook" class="headerlink" title="创建钩子(hook)"></a>创建钩子(hook)</h5><p>GORM 允许用户定义的钩子有 <code>BeforeSave</code>, <code>BeforeCreate</code>, <code>AfterSave</code>, <code>AfterCreate</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> BeforeCreate(tx *gorm.DB) (err <span class="type">error</span>) &#123;</span><br><span class="line">  u.UUID = uuid.New()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> u.Role == <span class="string">&quot;admin&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;invalid role&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="根据Map创建"><a href="#根据Map创建" class="headerlink" title="根据Map创建"></a>根据Map创建</h5><p>GORM 支持根据 <code>map[string]interface&#123;&#125;</code> 和 <code>[]map[string]interface&#123;&#125;&#123;&#125;</code> 创建记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据map创建</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Create(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//根据[]map创建</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Create([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu_1&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">18</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu_2&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">20</span>&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="使用SQL表达式创建"><a href="#使用SQL表达式创建" class="headerlink" title="使用SQL表达式创建"></a>使用SQL表达式创建</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.Model(&amp;user).Update(<span class="string">&quot;age&quot;</span>, gorm.Expr(<span class="string">&quot;age * ? + ?&quot;</span>, <span class="number">2</span>, <span class="number">100</span>))</span><br><span class="line"><span class="comment">//// UPDATE `users` SET `age` = age * 2 + 100, `updated_at` = &#x27;2020-02-16 13:10:20&#x27;  WHERE `users`.`id` = 1;</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;age&quot;</span>: gorm.Expr(<span class="string">&quot;age * ? + ?&quot;</span>, <span class="number">2</span>, <span class="number">100</span>)&#125;)</span><br><span class="line"><span class="comment">//// UPDATE &quot;users&quot; SET &quot;age&quot; = age * &#x27;2&#x27; + &#x27;100&#x27;, &quot;updated_at&quot; = &#x27;2020-02-16 13:05:51&#x27; WHERE `users`.`id` = 1;</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).UpdateColumn(<span class="string">&quot;age&quot;</span>, gorm.Expr(<span class="string">&quot;age - ?&quot;</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment">//// UPDATE &quot;users&quot; SET &quot;age&quot; = age - 1 WHERE &quot;id&quot; = &#x27;1&#x27;;</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).Where(<span class="string">&quot;age &gt; 10&quot;</span>).UpdateColumn(<span class="string">&quot;age&quot;</span>, gorm.Expr(<span class="string">&quot;age - ?&quot;</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment">//// UPDATE &quot;users&quot; SET &quot;age&quot; = age - 1 WHERE &quot;id&quot; = &#x27;1&#x27; AND quantity &gt; 10;</span></span><br></pre></td></tr></table></figure><h5 id="使用-SQL-表达式、Context-Valuer-创建记录-x2F-x2F-施工中-x2F-x2F"><a href="#使用-SQL-表达式、Context-Valuer-创建记录-x2F-x2F-施工中-x2F-x2F" class="headerlink" title="使用 SQL 表达式、Context Valuer 创建记录&#x2F;&#x2F;施工中&#x2F;&#x2F;"></a>使用 SQL 表达式、Context Valuer 创建记录&#x2F;&#x2F;施工中&#x2F;&#x2F;</h5><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><h5 id="检索单个对象"><a href="#检索单个对象" class="headerlink" title="检索单个对象"></a>检索单个对象</h5><p><code>First</code> <code>Take</code> <code>Last</code>方法，查询数据库时添加了<code>limit 1</code>条件，当没有找到记录时，他会返回<code>ErrRecordNotFound</code>错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取第一条记录（主键升序）</span></span><br><span class="line">db.First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一条记录，没有指定排序字段</span></span><br><span class="line">db.Take(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最后一条记录（主键降序）</span></span><br><span class="line">db.Last(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY id DESC LIMIT 1;</span></span><br><span class="line"></span><br><span class="line">result := db.First(&amp;user)</span><br><span class="line">result.RowsAffected <span class="comment">// 返回找到的记录数</span></span><br><span class="line">result.Error        <span class="comment">// returns error or nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 ErrRecordNotFound 错误</span></span><br><span class="line">errors.Is(result.Error, gorm.ErrRecordNotFound)</span><br></pre></td></tr></table></figure><h6 id="根据主键检索"><a href="#根据主键检索" class="headerlink" title="根据主键检索"></a>根据主键检索</h6><p>如果主键是数字类型，可以使用内联条件来检索对象。<strong>注意sql注入问题。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.First(&amp;user, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.First(&amp;user, <span class="string">&quot;10&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Find(&amp;users, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id IN (1,2,3);</span></span><br></pre></td></tr></table></figure><p>如果主键是字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.First(&amp;user, <span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = &quot;string&quot;;</span></span><br></pre></td></tr></table></figure><p>当目标对象有一个主要值时，使用主键构建条件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = User&#123;ID: <span class="number">10</span>&#125;</span><br><span class="line">db.First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result User</span><br><span class="line">db.Model(User&#123;ID: <span class="number">10</span>&#125;).First(&amp;result)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br></pre></td></tr></table></figure><h5 id="检索全部对象"><a href="#检索全部对象" class="headerlink" title="检索全部对象"></a>检索全部对象</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">result := db.Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users;</span></span><br><span class="line"></span><br><span class="line">result.RowsAffected</span><br><span class="line"><span class="comment">// returns found records count, equals `len(users)`</span></span><br><span class="line"></span><br><span class="line">result.Error</span><br><span class="line"><span class="comment">// returns error</span></span><br></pre></td></tr></table></figure><h5 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h5><h6 id="string"><a href="#string" class="headerlink" title="string"></a>string</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get first matched record</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get all matched records</span></span><br><span class="line">db.Where(<span class="string">&quot;name &lt;&gt; ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name &lt;&gt; &#x27;jinzhu&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IN</span></span><br><span class="line">db.Where(<span class="string">&quot;name IN ?&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name IN (&#x27;jinzhu&#x27;,&#x27;jinzhu 2&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LIKE</span></span><br><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jin%&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name LIKE &#x27;%jin%&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AND</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ? AND age &gt;= ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;22&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; AND age &gt;= 22;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Time</span></span><br><span class="line">db.Where(<span class="string">&quot;updated_at &gt; ?&quot;</span>, lastWeek).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE updated_at &gt; &#x27;2000-01-01 00:00:00&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BETWEEN</span></span><br><span class="line">db.Where(<span class="string">&quot;created_at BETWEEN ? AND ?&quot;</span>, lastWeek, today).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE created_at BETWEEN &#x27;2000-01-01 00:00:00&#x27; AND &#x27;2000-01-08 00:00:00&#x27;;</span></span><br></pre></td></tr></table></figure><h2 id="在Go中使用redis"><a href="#在Go中使用redis" class="headerlink" title="在Go中使用redis"></a>在Go中使用redis</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>连接池以及链接设置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Rdb *redis.Client</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitRedis</span><span class="params">()</span></span> &#123;</span><br><span class="line">Rdb = redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line"><span class="comment">//连接信息</span></span><br><span class="line">Network:  <span class="string">&quot;tcp&quot;</span>,            <span class="comment">//网络类型，tcp or unix，默认tcp</span></span><br><span class="line">Addr:     <span class="string">&quot;127.0.0.1:6379&quot;</span>, <span class="comment">//主机名+冒号+端口，默认localhost:6379</span></span><br><span class="line">Password: <span class="string">&quot;123456&quot;</span>,         <span class="comment">//密码</span></span><br><span class="line">DB:       <span class="number">0</span>,                <span class="comment">// redis数据库index</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//连接池容量及闲置连接数量</span></span><br><span class="line">PoolSize:     <span class="number">15</span>, <span class="comment">// 连接池最大socket连接数，默认为4倍CPU数， 4 * runtime.NumCPU</span></span><br><span class="line">MinIdleConns: <span class="number">10</span>, <span class="comment">//在启动阶段创建指定数量的Idle连接，并长期维持idle状态的连接数不少于指定数量；。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//超时</span></span><br><span class="line">DialTimeout:  <span class="number">5</span> * time.Second, <span class="comment">//连接建立超时时间，默认5秒。</span></span><br><span class="line">ReadTimeout:  <span class="number">3</span> * time.Second, <span class="comment">//读超时，默认3秒， -1表示取消读超时</span></span><br><span class="line">WriteTimeout: <span class="number">3</span> * time.Second, <span class="comment">//写超时，默认等于读超时</span></span><br><span class="line">PoolTimeout:  <span class="number">4</span> * time.Second, <span class="comment">//当所有连接都处在繁忙状态时，客户端等待可用连接的最大等待时长，默认为读超时+1秒。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//闲置连接检查包括IdleTimeout，MaxConnAge</span></span><br><span class="line">IdleCheckFrequency: <span class="number">60</span> * time.Second, <span class="comment">//闲置连接检查的周期，默认为1分钟，-1表示不做周期性检查，只在客户端获取连接时对闲置连接进行处理。</span></span><br><span class="line">IdleTimeout:        <span class="number">5</span> * time.Minute,  <span class="comment">//闲置超时，默认5分钟，-1表示取消闲置超时检查</span></span><br><span class="line">MaxConnAge:         <span class="number">0</span> * time.Second,  <span class="comment">//连接存活时长，从创建开始计时，超过指定时长则关闭连接，默认为0，即不关闭存活时长较长的连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//命令执行失败时的重试策略</span></span><br><span class="line">MaxRetries:      <span class="number">0</span>,                      <span class="comment">// 命令执行失败时，最多重试多少次，默认为0即不重试</span></span><br><span class="line">MinRetryBackoff: <span class="number">8</span> * time.Millisecond,   <span class="comment">//每次计算重试间隔时间的下限，默认8毫秒，-1表示取消间隔</span></span><br><span class="line">MaxRetryBackoff: <span class="number">512</span> * time.Millisecond, <span class="comment">//每次计算重试间隔时间的上限，默认512毫秒，-1表示取消间隔</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可自定义连接函数</span></span><br><span class="line">Dialer: <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">netDialer := &amp;net.Dialer&#123;</span><br><span class="line">Timeout:   <span class="number">5</span> * time.Second,</span><br><span class="line">KeepAlive: <span class="number">5</span> * time.Minute,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> netDialer.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:6379&quot;</span>)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">//钩子函数</span></span><br><span class="line">OnConnect: <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, conn *redis.Conn)</span></span> <span class="type">error</span> &#123; <span class="comment">//仅当客户端执行命令时需要从连接池获取连接时，如果连接池需要新建连接时则会调用此钩子函数</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;conn=%v\n&quot;</span>, conn)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">_, err := Rdb.Ping(context.Background()).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Print(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;redis 链接成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般设置成这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rdb = redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">Addr:     <span class="string">&quot;127.0.0.1:6379&quot;</span>,</span><br><span class="line">Password: <span class="string">&quot;123456&quot;</span>, </span><br><span class="line">DB:       <span class="number">0</span>,        </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="一般写操作"><a href="#一般写操作" class="headerlink" title="一般写操作"></a>一般写操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String</span></span><br><span class="line">err := rdb.Set(ctx, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>, <span class="number">0</span>).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列表 List</span></span><br><span class="line">rdb.LPush(ctx, <span class="string">&quot;list&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合</span></span><br><span class="line">rdb.SAdd(ctx, <span class="string">&quot;team&quot;</span>, <span class="string">&quot;kobe&quot;</span>, <span class="string">&quot;jordan&quot;</span>)</span><br><span class="line">rdb.SAdd(ctx, <span class="string">&quot;team&quot;</span>, <span class="string">&quot;curry&quot;</span>)</span><br><span class="line">rdb.SAdd(ctx, <span class="string">&quot;team&quot;</span>, <span class="string">&quot;kobe&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash</span></span><br><span class="line">rdb.HSet(ctx, <span class="string">&quot;user&quot;</span>, <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>, <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>)</span><br><span class="line">rdb.HSet(ctx, <span class="string">&quot;user&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>, <span class="string">&quot;key4&quot;</span>, <span class="string">&quot;value4&quot;</span>&#125;)</span><br><span class="line">rdb.HSet(ctx, <span class="string">&quot;user&quot;</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;key5&quot;</span>: <span class="string">&quot;value5&quot;</span>, <span class="string">&quot;key6&quot;</span>: <span class="string">&quot;value6&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有序集合</span></span><br><span class="line">rdb.ZAdd(ctx, <span class="string">&quot;zSet&quot;</span>, &amp;redis.Z&#123;</span><br><span class="line">    Score:  <span class="number">0</span>,</span><br><span class="line">    Member: <span class="number">1</span>,</span><br><span class="line">&#125;)</span><br><span class="line">rdb.ZAdd(ctx, <span class="string">&quot;zSet&quot;</span>, &amp;redis.Z&#123;</span><br><span class="line">    Score:  <span class="number">0</span>,</span><br><span class="line">    Member: <span class="number">2</span>,</span><br><span class="line">&#125;)</span><br><span class="line">rdb.ZAdd(ctx, <span class="string">&quot;zSet&quot;</span>, &amp;redis.Z&#123;</span><br><span class="line">    Score:  <span class="number">0</span>,</span><br><span class="line">    Member: <span class="number">3</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道</span></span><br><span class="line">pipe := rdb.Pipeline()</span><br><span class="line"></span><br><span class="line">incr := pipe.Incr(ctx, <span class="string">&quot;pipeline_counter&quot;</span>)</span><br><span class="line">pipe.Expire(ctx, <span class="string">&quot;pipeline_counter&quot;</span>, time.Hour)</span><br><span class="line"></span><br><span class="line">cmds, err := pipe.Exec(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The value is available only after Exec is called.</span></span><br><span class="line">fmt.Println(incr.Val())</span><br></pre></td></tr></table></figure><h2 id="Zap"><a href="#Zap" class="headerlink" title="Zap"></a>Zap</h2><h3 id="配置日志记录器"><a href="#配置日志记录器" class="headerlink" title="配置日志记录器"></a>配置日志记录器</h3><p>Zap提供两种类型的日志记录器<code>Sugared Logger</code>和<code>Logger</code>，两种<strong>logger都打印输出JSON结构格式</strong>。</p><p><code>Logger</code>比<code>Sugared Logger</code>更快，内存分配次数更少，但只支持强类型的结构化 日志记录。</p><h4 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h4><ul><li>通过调用<code>Zap.NewProoduction()</code> 、<code>Zap.NewDevelopment()</code> 或者 <code>Zap.Example()</code>创建一个<code>Logger</code>  </li><li>以上函数都可创建一个<code>Logger</code> 区别在于它们记录的信息不同</li><li>默认情况下日志都会打印到应用程序的<code>console</code>界面</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger *zap.Logger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">InitLogger()</span><br><span class="line">  <span class="keyword">defer</span> logger.Sync()</span><br><span class="line">simpleHttpGet(<span class="string">&quot;www.google.com&quot;</span>)</span><br><span class="line">simpleHttpGet(<span class="string">&quot;http://www.google.com&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个logger</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">logger, _ = zap.NewProduction()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simpleHttpGet</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">//使用info/error等logger方法记录消息</span></span><br><span class="line">logger.Error(</span><br><span class="line"><span class="string">&quot;Error fetching url..&quot;</span>,</span><br><span class="line">zap.String(<span class="string">&quot;url&quot;</span>, url),</span><br><span class="line">zap.Error(err))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">logger.Info(<span class="string">&quot;Success..&quot;</span>,</span><br><span class="line">zap.String(<span class="string">&quot;statusCode&quot;</span>, resp.Status),</span><br><span class="line">zap.String(<span class="string">&quot;url&quot;</span>, url))</span><br><span class="line">resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志记录器方法的语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(log *Logger)</span></span> MethodXXX(msg <span class="type">string</span>, fields ...Field) </span><br></pre></td></tr></table></figure><p>其中<code>MethodXXX</code>是一个可变参数函数，可以是<code>Info/Error/Debug/Panic</code>等。每个方法都接受一个消息字符串和任意数量的<code>zapcore.Field</code>场参数</p><p><code>zapcore.Field</code>就是一组键值对参数</p><h4 id="Sugared-Logger"><a href="#Sugared-Logger" class="headerlink" title="Sugared Logger"></a>Sugared Logger</h4><p>大部分实现相同，区别在于要先调用主logger的<code>Sugar()</code>方法来获取一个<code>Sugared Logger</code>然后一使用<code>Suggar Logger</code> 代替<code>Logger</code>的代码</p><p>替换后的对应代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sugarLogger *zap.SugaredLogger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">InitLogger()</span><br><span class="line"><span class="keyword">defer</span> sugarLogger.Sync()</span><br><span class="line">simpleHttpGet(<span class="string">&quot;www.google.com&quot;</span>)</span><br><span class="line">simpleHttpGet(<span class="string">&quot;http://www.google.com&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个Sugared Logger</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">  logger, _ := zap.NewProduction()</span><br><span class="line">sugarLogger = logger.Sugar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以printf格式输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simpleHttpGet</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">sugarLogger.Debugf(<span class="string">&quot;Trying to hit GET request for %s&quot;</span>, url)</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">sugarLogger.Errorf(<span class="string">&quot;Error fetching URL %s : Error = %s&quot;</span>, url, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sugarLogger.Infof(<span class="string">&quot;Success! statusCode = %s for URL %s&quot;</span>, resp.Status, url)</span><br><span class="line">resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定制logger"><a href="#定制logger" class="headerlink" title="定制logger"></a>定制logger</h3><h4 id="将日志写入文件而不是输出终端"><a href="#将日志写入文件而不是输出终端" class="headerlink" title="将日志写入文件而不是输出终端"></a>将日志写入文件而不是输出终端</h4><p>使用<code>Zap.New(...)</code>方法传递所有配置，而不是使用像<code>Zap.Newproduction()</code>这样的预置方法创建<code>logger</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(core zapcore.Core, options ...Option)</span></span> *Logger</span><br></pre></td></tr></table></figure><p><code>zapcore.Core</code>需要三个配置：<code>Encoder</code>,<code>WriteSyncer</code>,<code>LogerLevel</code></p><ol><li><p>Encoder:编码器，配置如何写入日志。可以使用<code>NewJSONEncoder()</code>，并使用预先配置好的<code>ProducitonEncoderConfig()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig())</span><br></pre></td></tr></table></figure></li><li><p>WriteSyncer:指定日志写入的位置。使用<code>zapcore.AddSync</code>函数并将打开文件的句子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file, _ := os.Create(<span class="string">&quot;./test.log&quot;</span>)</span><br><span class="line">   writeSyncer := zapcore.AddSync(file)</span><br></pre></td></tr></table></figure></li><li><p>Log Level:那种级别的日志将被写入</p><p><strong>DebugLevel表示全部输出</strong></p></li></ol><h4 id="将JSON-Encoder更改为普通的Log-Encoder"><a href="#将JSON-Encoder更改为普通的Log-Encoder" class="headerlink" title="将JSON Encoder更改为普通的Log Encoder"></a>将JSON Encoder更改为普通的Log Encoder</h4><p>将<code>NewJSONEncoder()</code>更改为<code>NewConsoleEncoder()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> zapcore.NewConsoleEncoder(zap.NewProductionEncoderConfig())</span><br></pre></td></tr></table></figure><p>此时会输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.572161051846623e+09</span>debugTrying to hit GET request <span class="keyword">for</span> www.sogo.com</span><br><span class="line"><span class="number">1.572161051846828e+09</span><span class="type">error</span>Error fetching URL www.sogo.com : Error = Get www.sogo.com: unsupported protocol scheme <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="number">1.5721610518468401e+09</span>debugTrying to hit GET request <span class="keyword">for</span> http:<span class="comment">//www.sogo.com</span></span><br><span class="line"><span class="number">1.572161052068744e+09</span>infoSuccess! statusCode = <span class="number">200</span> OK <span class="keyword">for</span> URL http:<span class="comment">//www.sogo.com</span></span><br></pre></td></tr></table></figure><h4 id="更改时间编码并添加调用者详细信息"><a href="#更改时间编码并添加调用者详细信息" class="headerlink" title="更改时间编码并添加调用者详细信息"></a>更改时间编码并添加调用者详细信息</h4><p>覆盖默认的<code>PronductionConfig()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getEncoder</span><span class="params">()</span></span> zapcore.Encoder &#123;</span><br><span class="line">encoderConfig := zap.NewProductionEncoderConfig()</span><br><span class="line"><span class="comment">//修改时间编码器</span></span><br><span class="line">encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder</span><br><span class="line"><span class="comment">//在日志文件中使用大写字母记录日志级别</span></span><br><span class="line">encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder</span><br><span class="line"><span class="keyword">return</span> zapcore.NewConsoleEncoder(encoderConfig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改zap logger代码，在<code>zap.New()</code>添加一个<code>Option</code>添加将调用函数信息记录到日志中的功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger := zap.New(core, zap.AddCaller())</span><br></pre></td></tr></table></figure><h4 id="AddCallerSkip"><a href="#AddCallerSkip" class="headerlink" title="AddCallerSkip"></a>AddCallerSkip</h4><p>当我们不是直接使用初始化好的logger实例记录日志，而是将其包装成一个函数等，此时日录日志的函数调用链会增加，想要获得准确的调用信息就需要通过<code>AddCallerSkip</code>函数来跳过。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger := zap.New(core, zap.AddCaller(), zap.AddCallerSkip(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h4 id="将日志输出到多个位置"><a href="#将日志输出到多个位置" class="headerlink" title="将日志输出到多个位置"></a>将日志输出到多个位置</h4><p>利用io.MultiWriter，可以将日志同时输出到文件和终端</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLogWriter</span><span class="params">()</span></span> zapcore.WriteSyncer &#123;</span><br><span class="line">file, _ := os.Create(<span class="string">&quot;./test.log&quot;</span>)</span><br><span class="line">ws := io.MultiWriter(file, os.Stdout)</span><br><span class="line"><span class="keyword">return</span> zapcore.AddSync(ws)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="将err日志单独输出到文件"><a href="#将err日志单独输出到文件" class="headerlink" title="将err日志单独输出到文件"></a>将err日志单独输出到文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">encoder := getEncoder()</span><br><span class="line"><span class="comment">// test.log记录全量日志</span></span><br><span class="line">logF, _ := os.Create(<span class="string">&quot;./test.log&quot;</span>)</span><br><span class="line">c1 := zapcore.NewCore(encoder, zapcore.AddSync(logF), zapcore.DebugLevel)</span><br><span class="line"><span class="comment">// test.err.log记录ERROR级别的日志</span></span><br><span class="line">errF, _ := os.Create(<span class="string">&quot;./test.err.log&quot;</span>)</span><br><span class="line">c2 := zapcore.NewCore(encoder, zapcore.AddSync(errF), zap.ErrorLevel)</span><br><span class="line"><span class="comment">// 使用NewTee将c1和c2合并到core</span></span><br><span class="line">core := zapcore.NewTee(c1, c2)</span><br><span class="line">logger = zap.New(core, zap.AddCaller())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Lumberjack进行日志切割归档"><a href="#使用Lumberjack进行日志切割归档" class="headerlink" title="使用Lumberjack进行日志切割归档"></a>使用Lumberjack进行日志切割归档</h3><p>Zap本身不支持切割归档日志</p><p>官方为了添加日志切割归档功能，要使用Lumberjack来实现</p><p>目前只支持文件大小切割，原因是按时间切割效率低且不能保证日志数据不被破坏。</p><p>想按日期切割可以使用<a href="https://github.com/lestrrat-go/file-rotatelogs">https://github.com/lestrrat-go/file-rotatelogs</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用file-rotatelogs按天切割日志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rotatelogs <span class="string">&quot;github.com/lestrrat-go/file-rotatelogs&quot;</span></span><br><span class="line"></span><br><span class="line">l, _ := rotatelogs.New(</span><br><span class="line">filename+<span class="string">&quot;.%Y%m%d%H%M&quot;</span>,</span><br><span class="line">rotatelogs.WithMaxAge(<span class="number">30</span>*<span class="number">24</span>*time.Hour),    <span class="comment">// 最长保存30天</span></span><br><span class="line">rotatelogs.WithRotationTime(time.Hour*<span class="number">24</span>), <span class="comment">// 24小时切割一次</span></span><br><span class="line">)</span><br><span class="line">zapcore.AddSync(l)</span><br></pre></td></tr></table></figure><h4 id="zap-logger中加入Lumberjack"><a href="#zap-logger中加入Lumberjack" class="headerlink" title="zap logger中加入Lumberjack"></a>zap logger中加入Lumberjack</h4><p>要在zap中加入Lumberjack支持，需要修改<code>WriteSyncer</code>代码我们将按照下面的代码修改<code>getLogWriter()</code>函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLogWriter</span><span class="params">()</span></span> zapcore.WriteSyncer &#123;</span><br><span class="line">lumberJackLogger := &amp;lumberjack.Logger&#123;</span><br><span class="line">Filename:   <span class="string">&quot;./test.log&quot;</span>,</span><br><span class="line">MaxSize:    <span class="number">10</span>,</span><br><span class="line">MaxBackups: <span class="number">5</span>,</span><br><span class="line">MaxAge:     <span class="number">30</span>,</span><br><span class="line">Compress:   <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> zapcore.AddSync(lumberJackLogger)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lumberjack Logger采用一下属性作为输入</p><ul><li>Filename: 日志文件的位置</li><li>MaxSize：在进行切割之前，日志文件的最大大小（以MB为单位）</li><li>MaxBackups：保留旧文件的最大个数</li><li>MaxAges：保留旧文件的最大天数</li><li>Compress：是否压缩&#x2F;归档旧文件</li></ul><p>最后成果如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;gopkg.in/natefinch/lumberjack.v2&quot;</span></span><br><span class="line"><span class="string">&quot;go.uber.org/zap&quot;</span></span><br><span class="line"><span class="string">&quot;go.uber.org/zap/zapcore&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sugarLogger *zap.SugaredLogger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">InitLogger()</span><br><span class="line"><span class="keyword">defer</span> sugarLogger.Sync()</span><br><span class="line">simpleHttpGet(<span class="string">&quot;www.sogo.com&quot;</span>)</span><br><span class="line">simpleHttpGet(<span class="string">&quot;http://www.sogo.com&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">writeSyncer := getLogWriter()</span><br><span class="line">encoder := getEncoder()</span><br><span class="line">core := zapcore.NewCore(encoder, writeSyncer, zapcore.DebugLevel)</span><br><span class="line"></span><br><span class="line">logger := zap.New(core, zap.AddCaller())</span><br><span class="line">sugarLogger = logger.Sugar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getEncoder</span><span class="params">()</span></span> zapcore.Encoder &#123;</span><br><span class="line">encoderConfig := zap.NewProductionEncoderConfig()</span><br><span class="line">encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder</span><br><span class="line">encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder</span><br><span class="line"><span class="keyword">return</span> zapcore.NewConsoleEncoder(encoderConfig)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLogWriter</span><span class="params">()</span></span> zapcore.WriteSyncer &#123;</span><br><span class="line">lumberJackLogger := &amp;lumberjack.Logger&#123;</span><br><span class="line">Filename:   <span class="string">&quot;./test.log&quot;</span>,</span><br><span class="line">MaxSize:    <span class="number">1</span>,</span><br><span class="line">MaxBackups: <span class="number">5</span>,</span><br><span class="line">MaxAge:     <span class="number">30</span>,</span><br><span class="line">Compress:   <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> zapcore.AddSync(lumberJackLogger)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simpleHttpGet</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">sugarLogger.Debugf(<span class="string">&quot;Trying to hit GET request for %s&quot;</span>, url)</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">sugarLogger.Errorf(<span class="string">&quot;Error fetching URL %s : Error = %s&quot;</span>, url, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sugarLogger.Infof(<span class="string">&quot;Success! statusCode = %s for URL %s&quot;</span>, resp.Status, url)</span><br><span class="line">resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span><span class="number">-10</span><span class="number">-27</span>T15:<span class="number">50</span>:<span class="number">32.944</span>+<span class="number">0800</span>DEBUGlogic/temp2.<span class="keyword">go</span>:<span class="number">48</span>Trying to hit GET request <span class="keyword">for</span> www.sogo.com</span><br><span class="line"><span class="number">2019</span><span class="number">-10</span><span class="number">-27</span>T15:<span class="number">50</span>:<span class="number">32.944</span>+<span class="number">0800</span>ERRORlogic/temp2.<span class="keyword">go</span>:<span class="number">51</span>Error fetching URL www.sogo.com : Error = Get www.sogo.com: unsupported protocol scheme <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="number">2019</span><span class="number">-10</span><span class="number">-27</span>T15:<span class="number">50</span>:<span class="number">32.944</span>+<span class="number">0800</span>DEBUGlogic/temp2.<span class="keyword">go</span>:<span class="number">48</span>Trying to hit GET request <span class="keyword">for</span> http:<span class="comment">//www.sogo.com</span></span><br><span class="line"><span class="number">2019</span><span class="number">-10</span><span class="number">-27</span>T15:<span class="number">50</span>:<span class="number">33.165</span>+<span class="number">0800</span>INFOlogic/temp2.<span class="keyword">go</span>:<span class="number">53</span>Success! statusCode = <span class="number">200</span> OK <span class="keyword">for</span> URL http:<span class="comment">//www.sogo.com</span></span><br></pre></td></tr></table></figure><h3 id="使用zap的一般步骤"><a href="#使用zap的一般步骤" class="headerlink" title="使用zap的一般步骤"></a>使用zap的一般步骤</h3><ol><li>生成编码器,通过函数<code>getEncoder()zapcore.Encoder</code>配置时间编码，设置logger level大写等</li><li>通过函数<code>getLogWriter()zapcore.WriterSyncer</code>指定日志写入位置（使用Lumberjack)</li><li>通过函数<code>InitLogger()</code>生成<code>Logger</code>,函数内部调用<code>getEncoder()</code>和   <code>getLogWriter</code>，获得<code>zapcore.Encoder</code>和<code>zapcore.WriterSyncer</code>，然后调用方法<code>zap.New()</code>(可设置添加调用者信息）生成logger,在调用<code>logger.Sugar()</code>获得<code>sugaredLogger</code></li><li>在main函数中调用<code>InitLogger()</code>并<code>defer sugarLogger.Sync()</code>将缓存中的log<code>flush</code>进输出中</li></ol><h2 id="Viper"><a href="#Viper" class="headerlink" title="Viper"></a>Viper</h2><p><strong>viper支持以下特性:</strong></p><ul><li>设置默认值</li><li>从<code>JSON</code>、<code>TOML</code>、<code>YAML</code>、<code>HCL</code>、<code>envfile</code>和<code>Java properties</code>格式的配置文件读取配置信息(一般go常用<code>YAML</code>)</li><li>实时监控和重新读取配置文件(可选)</li><li>从环境变量读取</li><li>从远程配置系统（etcd或Consul）读取并监控配置变化</li><li>从命令行参数读取配置</li><li>从buffer读取配置</li><li>显式配置值</li></ul><h3 id="把值存入Viper"><a href="#把值存入Viper" class="headerlink" title="把值存入Viper"></a>把值存入Viper</h3><h4 id="建立默认值"><a href="#建立默认值" class="headerlink" title="建立默认值"></a>建立默认值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">viper.SetDefault(<span class="string">&quot;ContentDir&quot;</span>, <span class="string">&quot;content&quot;</span>)</span><br><span class="line">viper.SetDefault(<span class="string">&quot;LayoutDir&quot;</span>, <span class="string">&quot;layouts&quot;</span>)</span><br><span class="line">viper.SetDefault(<span class="string">&quot;Taxonomies&quot;</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;tag&quot;</span>: <span class="string">&quot;tags&quot;</span>, <span class="string">&quot;category&quot;</span>: <span class="string">&quot;categories&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><h4 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h4><p>下面是一个如何使用Viper搜索和读取配置文件的示例。不需要任何特定的路径，但是至少应该提供一个配置文件预期出现的路径。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">viper.SetConfigFile(<span class="string">&quot;./config.yaml&quot;</span>) <span class="comment">// 指定配置文件路径</span></span><br><span class="line">viper.SetConfigName(<span class="string">&quot;config&quot;</span>) <span class="comment">// 配置文件名称(无扩展名)</span></span><br><span class="line">viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>) <span class="comment">// 如果配置文件的名称中没有扩展名，则需要配置此项</span></span><br><span class="line">viper.AddConfigPath(<span class="string">&quot;/etc/appname/&quot;</span>)   <span class="comment">// 查找配置文件所在的路径</span></span><br><span class="line">viper.AddConfigPath(<span class="string">&quot;$HOME/.appname&quot;</span>)  <span class="comment">// 多次调用以添加多个搜索路径</span></span><br><span class="line">viper.AddConfigPath(<span class="string">&quot;.&quot;</span>)               <span class="comment">// 还可以在工作目录中查找配置</span></span><br><span class="line">err := viper.ReadInConfig() <span class="comment">// 查找并读取配置文件</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">// 处理读取配置文件的错误</span></span><br><span class="line"><span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;Fatal error config file: %s \n&quot;</span>, err))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载配置文件出错时，可以这样处理找不到配置文件的特定情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := viper.ReadInConfig(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := err.(viper.ConfigFileNotFoundError); ok &#123;</span><br><span class="line">        <span class="comment">// 配置文件未找到错误；如果需要可以忽略</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 配置文件被找到，但产生了另外的错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置文件找到并成功解析</span></span><br></pre></td></tr></table></figure><h4 id="写入配置文件"><a href="#写入配置文件" class="headerlink" title="写入配置文件"></a>写入配置文件</h4><p><strong>一般来说标记为<code>safe</code>的所有方法都不会覆盖任何文件，而是直接创建（如果不存在），而默认行为是创建或截断</strong></p><ul><li>WriteConfig - 将当前的<code>viper</code>配置写入预定义的路径并覆盖（如果存在的话）。如果没有预定义的路径，则报错。</li><li>SafeWriteConfig - 将当前的<code>viper</code>配置写入预定义的路径。如果没有预定义的路径，则报错。如果存在，将不会覆盖当前的配置文件。</li><li>WriteConfigAs - 将当前的<code>viper</code>配置写入给定的文件路径。将覆盖给定的文件(如果它存在的话)。</li><li>SafeWriteConfigAs - 将当前的<code>viper</code>配置写入给定的文件路径。不会覆盖给定的文件(如果它存在的话)。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">viper.WriteConfig() <span class="comment">// 将当前配置写入“viper.AddConfigPath()”和“viper.SetConfigName”设置的预定义路径</span></span><br><span class="line">viper.SafeWriteConfig()</span><br><span class="line">viper.WriteConfigAs(<span class="string">&quot;/path/to/my/.config&quot;</span>)</span><br><span class="line">viper.SafeWriteConfigAs(<span class="string">&quot;/path/to/my/.config&quot;</span>) <span class="comment">// 因为该配置文件写入过，所以会报错</span></span><br><span class="line">viper.SafeWriteConfigAs(<span class="string">&quot;/path/to/my/.other_config&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="监控并重新读取配置文件"><a href="#监控并重新读取配置文件" class="headerlink" title="监控并重新读取配置文件"></a>监控并重新读取配置文件</h4><p>Viper支持在运行时实时读取配置文件的功能，只需告诉viper实例watchConfig。可选地，你可以为Viper提供一个回调函数，以便在每次发生更改时运行。<strong>确保在调用<code>WatchConfig()</code>前添加了所有的配置路径</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">viper.WatchConfig()</span><br><span class="line">viper.OnConfigChange(<span class="function"><span class="keyword">func</span><span class="params">(e fsnotify.Event)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 配置文件发生变更之后会调用的回调函数</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Config file changed:&quot;</span>, e.Name)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="从io-Reader读取配置"><a href="#从io-Reader读取配置" class="headerlink" title="从io.Reader读取配置"></a>从io.Reader读取配置</h4><p>可以实现自己所需的配置源并将其提供给viper</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>) <span class="comment">// 或者 viper.SetConfigType(&quot;YAML&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任何需要将此配置添加到程序中的方法。</span></span><br><span class="line"><span class="keyword">var</span> yamlExample = []<span class="type">byte</span>(<span class="string">`</span></span><br><span class="line"><span class="string">Hacker: true</span></span><br><span class="line"><span class="string">name: steve</span></span><br><span class="line"><span class="string">hobbies:</span></span><br><span class="line"><span class="string">- skateboarding</span></span><br><span class="line"><span class="string">- snowboarding</span></span><br><span class="line"><span class="string">- go</span></span><br><span class="line"><span class="string">clothing:</span></span><br><span class="line"><span class="string">  jacket: leather</span></span><br><span class="line"><span class="string">  trousers: denim</span></span><br><span class="line"><span class="string">age: 35</span></span><br><span class="line"><span class="string">eyes : brown</span></span><br><span class="line"><span class="string">beard: true</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line"></span><br><span class="line">viper.ReadConfig(bytes.NewBuffer(yamlExample))</span><br><span class="line"></span><br><span class="line">viper.Get(<span class="string">&quot;name&quot;</span>) <span class="comment">// 这里会得到 &quot;steve&quot;</span></span><br></pre></td></tr></table></figure><h4 id="覆盖设置"><a href="#覆盖设置" class="headerlink" title="覆盖设置"></a>覆盖设置</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">viper.Set(<span class="string">&quot;Verbose&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">viper.Set(<span class="string">&quot;LogFile&quot;</span>, LogFile)</span><br></pre></td></tr></table></figure><h4 id="注册和使用别名"><a href="#注册和使用别名" class="headerlink" title="注册和使用别名"></a>注册和使用别名</h4><p>别名允许多个键引用单个值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">viper.RegisterAlias(<span class="string">&quot;loud&quot;</span>, <span class="string">&quot;Verbose&quot;</span>)  <span class="comment">// 注册别名（此处loud和Verbose建立了别名）</span></span><br><span class="line"></span><br><span class="line">viper.Set(<span class="string">&quot;verbose&quot;</span>, <span class="literal">true</span>) <span class="comment">// 结果与下一行相同</span></span><br><span class="line">viper.Set(<span class="string">&quot;loud&quot;</span>, <span class="literal">true</span>)   <span class="comment">// 结果与前一行相同</span></span><br><span class="line"></span><br><span class="line">viper.GetBool(<span class="string">&quot;loud&quot;</span>) <span class="comment">// true</span></span><br><span class="line">viper.GetBool(<span class="string">&quot;verbose&quot;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="使用环境变量"><a href="#使用环境变量" class="headerlink" title="使用环境变量"></a><del>使用环境变量</del></h4><p>Viper完全支持环境变量。有五种方法可以帮助ENV协作：</p><ul><li><code>AutomaticEnv()</code></li><li><code>BinEnv(string...):error</code></li><li><code>SetEnvPrefix(string)</code></li><li><code>SetEnvKeyReplacer(string...) *strings.Replacer</code></li><li><code>AllowEmptyEnv(bool)</code></li></ul><p>使用ENV变量时要注意Viper将ENV变量视为区分大小写</p><h4 id="使用Flags"><a href="#使用Flags" class="headerlink" title="使用Flags"></a><del>使用Flags</del></h4><h4 id="远程Key-x2F-Value存储支持"><a href="#远程Key-x2F-Value存储支持" class="headerlink" title="远程Key&#x2F;Value存储支持"></a><del>远程Key&#x2F;Value存储支持</del></h4><h3 id="从Viper获取值"><a href="#从Viper获取值" class="headerlink" title="从Viper获取值"></a>从Viper获取值</h3><p>在Viper中，有几种方法可以根据值的类型获取值。</p><ul><li><code>Get(key string) : interface&#123;&#125;</code></li><li><code>GetBool(key string) : bool</code></li><li><code>GetFloat64(key string) : float64</code></li><li><code>GetInt(key string) : int</code></li><li><code>GetIntSlice(key string) : []int</code></li><li><code>GetString(key string) : string</code></li><li><code>GetStringMap(key string) : map[string]interface&#123;&#125;</code></li><li><code>GetStringMapString(key string) : map[string]string</code></li><li><code>GetStringSlice(key string) : []string</code></li><li><code>GetTime(key string) : time.Time</code></li><li><code>GetDuration(key string) : time.Duration</code></li></ul><p>每一个Get方法在找不到值的时候都会返回零值，为了检查给定的键是否存在，可以使用<code>IsSet(key string) : bool</code></p><h4 id="访问嵌套的键"><a href="#访问嵌套的键" class="headerlink" title="访问嵌套的键"></a>访问嵌套的键</h4><p>访问器方法也接受深度嵌套键的格式化路径</p><p>例如，加载下面的JSON文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;host&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;address&quot;</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">        <span class="string">&quot;port&quot;</span>: <span class="number">5799</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;datastore&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;metric&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;host&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;port&quot;</span>: <span class="number">3099</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;warehouse&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;host&quot;</span>: <span class="string">&quot;198.0.0.1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;port&quot;</span>: <span class="number">2112</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Viper可以通过传入<code>.</code>的路径访问嵌套字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetString(<span class="string">&quot;datastore.metric.host&quot;</span>) <span class="comment">// (返回 &quot;127.0.0.1&quot;)</span></span><br></pre></td></tr></table></figure><p>​        Viper访问配置问价中的字段遵循一定的优先规则，因为Viper支持从多种配置来源，例如磁盘上的配置文件&gt;命令行标志位&gt;环境变量&gt;远程Key&#x2F;Value存储&gt;默认值，我们在查找一个配置的时候如果在当前配置源中没找到，就会继续从后续的配置源查找，直到找到为止。</p><p>​       如果父键被直接复制覆盖，那么其子键都将变成未定义状态，们被高优先级配置级别<strong>“遮蔽”</strong>（shadowed）了。</p><p>​       最后，如果存在与分隔的键路径匹配的键，则返回其值。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;datastore.metric.host&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;host&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;address&quot;</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">        <span class="string">&quot;port&quot;</span>: <span class="number">5799</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;datastore&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;metric&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;host&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;port&quot;</span>: <span class="number">3099</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;warehouse&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;host&quot;</span>: <span class="string">&quot;198.0.0.1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;port&quot;</span>: <span class="number">2112</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GetString(<span class="string">&quot;datastore.metric.host&quot;</span>) <span class="comment">// 返回 &quot;0.0.0.0&quot;</span></span><br></pre></td></tr></table></figure><h4 id="提取子树"><a href="#提取子树" class="headerlink" title="提取子树"></a>提取子树</h4><p>例如,<code>viper</code>实例现在代表了以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app:</span></span><br><span class="line">  <span class="attr">cache1:</span></span><br><span class="line">    <span class="attr">max-items:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">item-size:</span> <span class="number">64</span></span><br><span class="line">  <span class="attr">cache2:</span></span><br><span class="line">    <span class="attr">max-items:</span> <span class="number">200</span></span><br><span class="line">    <span class="attr">item-size:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>调用<code>sub()</code>从Viper中提取子树</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subv := viper.Sub(<span class="string">&quot;app.cache1&quot;</span>)</span><br></pre></td></tr></table></figure><p>此时<code>subv</code>代表以下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">max-items:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">item-size:</span> <span class="number">64</span></span><br></pre></td></tr></table></figure><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>可以将所有或特定值解析到结构体、map等，默认情况下使用<code>mapstructure</code>tag</p><ul><li><code>Unmarshal(rawval interface&#123;&#125;)error</code></li><li><code>Unmarshal(key string ,rawVal interface&#123;&#125;)error</code></li></ul><p>例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line">Port <span class="type">int</span></span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">PathMap <span class="type">string</span> <span class="string">`mapstructure:&quot;path_map&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> C config</span><br><span class="line"></span><br><span class="line">err := viper.Unmarshal(&amp;C)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">&quot;unable to decode into struct, %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要解析的键本身包含<code>.</code>的配置，需要修改分割符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">v := viper.NewWithOptions(viper.KeyDelimiter(<span class="string">&quot;::&quot;</span>))</span><br><span class="line"></span><br><span class="line">v.SetDefault(<span class="string">&quot;chart::values&quot;</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">    <span class="string">&quot;ingress&quot;</span>: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">        <span class="string">&quot;annotations&quot;</span>: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">            <span class="string">&quot;traefik.frontend.rule.type&quot;</span>:                 <span class="string">&quot;PathPrefix&quot;</span>,</span><br><span class="line">            <span class="string">&quot;traefik.ingress.kubernetes.io/ssl-redirect&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line">Chart <span class="keyword">struct</span>&#123;</span><br><span class="line">        Values <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> C config</span><br><span class="line"></span><br><span class="line">v.Unmarshal(&amp;C)</span><br></pre></td></tr></table></figure><p>viper还支持解析到嵌入的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Example config:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">module:</span></span><br><span class="line"><span class="comment">    enabled: true</span></span><br><span class="line"><span class="comment">    token: 89h3f98hbwf987h3f98wenf89ehf</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line">Module <span class="keyword">struct</span> &#123;</span><br><span class="line">Enabled <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">moduleConfig <span class="string">`mapstructure:&quot;,squash&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// moduleConfig could be in a module specific package</span></span><br><span class="line"><span class="keyword">type</span> moduleConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Token <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> C config</span><br><span class="line"></span><br><span class="line">err := viper.Unmarshal(&amp;C)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">t.Fatalf(<span class="string">&quot;unable to decode into struct, %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="序列化成字符串"><a href="#序列化成字符串" class="headerlink" title="序列化成字符串"></a>序列化成字符串</h4><p>你可以将自己喜欢的格式的序列化器与<code>AllSettings()</code>返回的配置一起使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    yaml <span class="string">&quot;gopkg.in/yaml.v2&quot;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">yamlStringSettings</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    c := viper.AllSettings()</span><br><span class="line">    bs, err := yaml.Marshal(c)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;unable to marshal config to YAML: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(bs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><p>go语言内置的<code>flag</code>包实现了命令行参数的解析</p><h3 id="os-Args"><a href="#os-Args" class="headerlink" title="os.Args"></a>os.Args</h3><p><code>os.Args</code>也可以获取命令行参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//os.Args demo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//os.Args是一个[]string</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> index, arg := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;args[%d]=%v\n&quot;</span>, index, arg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>os.Args</code>是一个存储命令函参数的字符串切片，它的第一个元素是执行文件的名称</p><h3 id="flag包基本使用"><a href="#flag包基本使用" class="headerlink" title="flag包基本使用"></a>flag包基本使用</h3><h3 id="flag参数类型"><a href="#flag参数类型" class="headerlink" title="flag参数类型"></a>flag参数类型</h3><p>flag包支持的命令行参数类型有<code>bool</code>、<code>int</code>、<code>int64</code>、<code>uint</code>、<code>uint64</code>、<code>float</code>、<code>float64</code>、<code>string</code>、<code>duration</code>。</p><table><thead><tr><th>flag参数</th><th>有效值</th></tr></thead><tbody><tr><td>字符串flag</td><td>合法字符串</td></tr><tr><td>整数flag</td><td>1234、0664、0x1234等类型，也可以是负数</td></tr><tr><td>浮点数flag</td><td>合法浮点数</td></tr><tr><td>布尔flag</td><td>1,0,t,g,T,F,true,false,TRUE,FALSE,True,False</td></tr><tr><td>时间段flag</td><td>任何合法的时间段字符串。如”300ms”、”-1.5h”、”2h45m”。合法的单位有”ns”、”us&#x2F;µs”、”ms”、”s”、”m”、”h”。</td></tr></tbody></table><h3 id="定义命令行参数"><a href="#定义命令行参数" class="headerlink" title="定义命令行参数"></a>定义命令行参数</h3><h4 id="flag-Type"><a href="#flag-Type" class="headerlink" title="flag.Type()"></a>flag.Type()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//flag.Tpye(flag名，默认值，帮助信息)*Type</span></span><br><span class="line">name :=flag.String(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;姓名&quot;</span>)</span><br><span class="line">age:=flag.Int(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>,<span class="string">&quot;年龄&quot;</span>)</span><br><span class="line">married:=flag.Bool(<span class="string">&quot;married&quot;</span>,<span class="literal">false</span>,<span class="string">&quot;婚否&quot;</span>)</span><br><span class="line">delay:=flag.Duration(<span class="string">&quot;d&quot;</span>,<span class="number">0</span>,<span class="string">&quot;时间间隔&quot;</span>)</span><br></pre></td></tr></table></figure><p>需要注意的是此时<code>name</code>、<code>age</code>、<code>married</code>、<code>delay</code>均为对应类型的指针</p><h4 id="flag-TypeVar"><a href="#flag-TypeVar" class="headerlink" title="flag.TypeVar()"></a>flag.TypeVar()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//flag.TypeVar(Type指针,flag名,默认值,帮助信息)</span></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> married <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> delay time.Duration</span><br><span class="line">flag.StringVar (&amp;name,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;姓名&quot;</span>)</span><br><span class="line">flag.IntVar(&amp;age,<span class="string">&quot;age&quot;</span>,<span class="number">18</span>,<span class="string">&quot;年龄&quot;</span>)</span><br><span class="line">flag.BoolVar(&amp;married,<span class="string">&quot;married&quot;</span>,<span class="literal">false</span>,<span class="string">&quot;婚否&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="flage-Parse"><a href="#flage-Parse" class="headerlink" title="flage.Parse()"></a>flage.Parse()</h3><p>通过以上两种方法定义好命令行flag参数后，需要调用<code>flag.Parse()</code>来对命令行参数进行解析</p><p><strong>支持的命令行参数格式有以下几种：</strong></p><ul><li><code>-flag xxx</code>（使用空格，一个<code>-</code>符号）</li><li><code>--flag xxx</code>（使用空格，两个<code>-</code>符号</li><li><code>-flag=xxx</code>(使用等号，一个<code>-</code>符号)</li><li><code>--flag=xxx</code>（使用等号，两个<code>-</code>符号）</li></ul><p><strong>其中，布尔类型的参数必须使用等号的方式指定。</strong></p><p>flag解析在第一个非flag参数（单个<code>-</code>不是flag参数）之前停止，或者在终止符”-“之后停止</p><h3 id="flag其他函数"><a href="#flag其他函数" class="headerlink" title="flag其他函数"></a>flag其他函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag.Args()  <span class="comment">//返回命令行参数后的其他参数，以[]string类型</span></span><br><span class="line">flag.NArg()  <span class="comment">//返回命令行参数的其他参数个数</span></span><br><span class="line">flag.NFlag() <span class="comment">//返回使用的命令行参数个数</span></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="命令行使用提示"><a href="#命令行使用提示" class="headerlink" title="命令行使用提示"></a>命令行使用提示</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./flag_demo -<span class="built_in">help</span></span></span><br><span class="line">Usage of ./flag_demo:</span><br><span class="line">  -age int</span><br><span class="line">        年龄 (default 18)</span><br><span class="line">  -d duration</span><br><span class="line">        时间间隔</span><br><span class="line">  -married</span><br><span class="line">        婚否</span><br><span class="line">  -name string</span><br><span class="line">        姓名 (default &quot;张三&quot;)</span><br></pre></td></tr></table></figure><p>正常使用命令行flag参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./flag_demo -name 沙河娜扎 --age 28 -married=<span class="literal">false</span> -d=1h30m</span></span><br><span class="line">沙河娜扎 28 false 1h30m0s</span><br><span class="line">[]</span><br><span class="line">0</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>使用非flag命令行参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./flag_demo a b c</span></span><br><span class="line">张三 18 false 0s</span><br><span class="line">[a b c]</span><br><span class="line">3</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><h3 id="和数组对比"><a href="#和数组对比" class="headerlink" title="和数组对比"></a>和数组对比</h3><ul><li>在go中，数组是<strong>值类型</strong>，赋值和函数传参都会复制整个数组数据。在数据量大的时候，如果每次传参都用数组，那么每次数组都要被复制一次，这样会消耗大量的内存。所以函数传参改为使用数组的指针。</li><li>但是传递指针有一个弊端。如果原数组的指针指向更改了，那么函数里面的指针指向都会跟着更改。</li><li>切片是一个<strong>引用类型</strong>。切片是一个拥有相同类型元素的<strong>可变长度</strong>的序列，是基于数组类型做的一层封装，能够自动扩容。</li></ul><h3 id="切片的数据结构"><a href="#切片的数据结构" class="headerlink" title="切片的数据结构"></a>切片的数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span>&#123;</span><br><span class="line">     array unsafe.Pointer</span><br><span class="line">     <span class="built_in">len</span> <span class="type">int</span> </span><br><span class="line">     <span class="built_in">cap</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>切片的结构体由3部分构成，Pointer是指向它底层数组的指针,len 是当前切片的长度,cap是当前切片的容量。cap&gt;&#x3D;len。</li><li>slice本身不是动态数组或者数组指针，它的内部实现是通过引用底层数组，设置相关的属性，将数据的读写读写操作限定在指定的区域。</li><li>对slice的修改实际上是修改slice的底层数组，而不是slice本身。</li></ol><h3 id="切片的扩容策略"><a href="#切片的扩容策略" class="headerlink" title="切片的扩容策略"></a>切片的扩容策略</h3><table><thead><tr><th>切片的容量</th><th>扩容策略</th></tr></thead><tbody><tr><td>&lt;1024个元素</td><td>翻倍增加容量</td></tr><tr><td>&gt;1024个元素</td><td>每次增加原来的1&#x2F;4</td></tr></tbody></table><p>扩大的容量都是针对原来的容量而言，不是针对原来数组的长度而言的。</p><h3 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line"><span class="comment">//声明一个int类型的切片</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s =[]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">//声明一个int类型的切片并初始化</span></span><br></pre></td></tr></table></figure><h4 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h4><p>可以用<code>len()</code>函数求长度，用<code>cap()</code>函数求容量</p><h4 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h4><p>切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。</p><p>有两种形式：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式。</p><h5 id="简单切片表达式"><a href="#简单切片表达式" class="headerlink" title="简单切片表达式"></a><strong>简单切片表达式</strong></h5><p>切片的底层就是数组，所以可以基于数组通过切片表达式得到切片。切片表达式中的high和low表示一个索引的范围(左闭右开)长度len&#x3D;high-low，容量cap&#x3D;切片底层数组的容量-low。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:=[<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">s:=a[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment">//s=2,3 len(s)=2 cap(s)=4</span></span><br></pre></td></tr></table></figure><p>也可省略索引</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">2</span>:]  <span class="comment">// 等同于 a[2:len(a)]</span></span><br><span class="line">a[:<span class="number">3</span>]  <span class="comment">// 等同于 a[0:3]</span></span><br><span class="line">a[:]   <span class="comment">// 等同于 a[0:len(a)]</span></span><br></pre></td></tr></table></figure><ol><li>切片再切片的时候，high&lt;&#x3D;切片的容量cap(s)，而不是长度</li><li>low和high的值必须是非负的，可以用int类型的值表示</li><li>对数组或者字符串进行切片时，high&lt;&#x3D;len(a)</li><li>不满足上面三种条件的切片表达式都发生<code>panic</code></li></ol><h5 id="完整切片表达式"><a href="#完整切片表达式" class="headerlink" title="完整切片表达式"></a><strong>完整切片表达式</strong></h5><p>对于数组，指向数组的指针，或切片a支持（注意不能是字符串）完整切片表达式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[low:high:max]</span><br></pre></td></tr></table></figure><p>得到一个与a[low:high]相同类型、相同长度和元素的切片。还会将切片的容量设置为max-low。在完整切片表达式中只有low可以省略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:=[<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">t:=a[<span class="number">1</span>:<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment">//t=2,3 len(t)=2 cap(t)=4</span></span><br></pre></td></tr></table></figure><p>完整切片需要满足<code>0&lt;=low&lt;=high&lt;=max&lt;=cap(a)</code>,其他条件和简单切片表达式相同</p><h4 id="使用make函数构造切片"><a href="#使用make函数构造切片" class="headerlink" title="使用make函数构造切片"></a>使用make函数构造切片</h4><p>我们可以根据已有的数组，字符串和切片得到一个新的切片，也可以用make函数凭空创造一个切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a:=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">2</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment">//创建int类型的切片 len(a)=2 cap(a)=10</span></span><br></pre></td></tr></table></figure><p>上面的代码给a分配了10个存储空间，但实际上只用了两个，所以len&#x3D;2，cap&#x3D;10。</p><h3 id="切片不能直接比较"><a href="#切片不能直接比较" class="headerlink" title="切片不能直接比较"></a>切片不能直接比较</h3><p>不能直接用<code>==</code>操作符来判断两个切片时候含有全部相同元素。切片只能和nil比较，nil的切片没有底层数组，长度和容量都是0。但长度和容量都是0的切片未必是nil</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="type">int</span>         <span class="comment">//len(s1)=0;cap(s1)=0;s1==nil</span></span><br><span class="line">s2 := []<span class="type">int</span>&#123;&#125;        <span class="comment">//len(s2)=0;cap(s2)=0;s2!=nil</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>) <span class="comment">//len(s3)=0;cap(s3)=0;s3!=nil</span></span><br></pre></td></tr></table></figure><p>所以要检查一个切片是否为空，要用len(s)&#x3D;&#x3D;0来判断，而不能用s&#x3D;&#x3D;nil来判断</p><h3 id="切片的赋值拷贝"><a href="#切片的赋值拷贝" class="headerlink" title="切片的赋值拷贝"></a>切片的赋值拷贝</h3><p>拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>) <span class="comment">//[0 0 0]</span></span><br><span class="line">s2 := s1             <span class="comment">//将s1直接赋值给s2，s1和s2共用一个底层数组</span></span><br><span class="line">s2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(s1) <span class="comment">//[100 0 0]</span></span><br><span class="line">fmt.Println(s2) <span class="comment">//[100 0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="append添加元素"><a href="#append添加元素" class="headerlink" title="append添加元素"></a>append添加元素</h3><p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。</p><p><strong>append函数签名</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(slice []Type, elems ...Type)</span></span> []Type</span><br></pre></td></tr></table></figure><p> 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…用于把切片打散成一个个元素）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)        <span class="comment">// [1]</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// [1 2 3 4]</span></span><br><span class="line">s2 := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;  </span><br><span class="line">s = <span class="built_in">append</span>(s, s2...)    <span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>var声明的零值切片可以直接在append中使用，无需初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>没有必要像下面的代码一样初始化一个切片再传入<code>append()</code>函数使用，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;&#125;  <span class="comment">// 没有必要初始化</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">make</span>([]<span class="type">int</span>)  <span class="comment">// 没有必要初始化</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>每个切片都指向一个底层数组，这个数组的容量够用就添加新元素。当底层数组不够用时，切片就会自动扩容，此时切片指向的底层数组就会更换，所以通常需要用原变量接收append函数的返回值。</p><h3 id="copy函数复制切片"><a href="#copy函数复制切片" class="headerlink" title="copy函数复制切片"></a>copy函数复制切片</h3><p>由于切片是引用类型，当使用赋值拷贝时，原切片和新切片都指向一个底层数组</p><p>go内置一个copy函数可以迅速将一个切片的数复制到另一个切片中，这两个切片指向不同的底层数组</p><p>copy函数签名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copy</span><span class="params">(dst, src []Type)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// copy()复制切片</span></span><br><span class="line">a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">copy</span>(c, a)     <span class="comment">//使用copy()函数将切片a中的元素复制到切片c</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.Println(c) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.Println(c) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到修改新切片的值，不会影响到原切片</p><h3 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h3><p>go语言中没有删除切片元素的专用方法，可以使用切片的特性来删除元素</p><p>如要从切片a中删除索引为index的元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="built_in">append</span>(a[:index],a[index+<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组从声明时就确定，可以修改数组成员，但不能修改数组的大小</p><h3 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名[元素数量]T</span><br></pre></td></tr></table></figure><h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3><h4 id="初始化列表设置数组元素"><a href="#初始化列表设置数组元素" class="headerlink" title="初始化列表设置数组元素"></a>初始化列表设置数组元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="type">int</span>                        <span class="comment">//数组会初始化为int类型的零值</span></span><br><span class="line"><span class="keyword">var</span> numArray = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;                 <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line"><span class="keyword">var</span> cityArray = [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125; <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line">fmt.Println(testArray)                      <span class="comment">//[0 0 0]</span></span><br><span class="line">fmt.Println(numArray)                       <span class="comment">//[1 2 0]</span></span><br><span class="line">fmt.Println(cityArray)                      <span class="comment">//[北京 上海 深圳]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="让编译器自行推断数组长度"><a href="#让编译器自行推断数组长度" class="headerlink" title="让编译器自行推断数组长度"></a>让编译器自行推断数组长度</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> numArray = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> cityArray = [...]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;</span><br><span class="line">fmt.Println(testArray)                          <span class="comment">//[0 0 0]</span></span><br><span class="line">fmt.Println(numArray)                           <span class="comment">//[1 2]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type of numArray:%T\n&quot;</span>, numArray)   <span class="comment">//type of numArray:[2]int</span></span><br><span class="line">fmt.Println(cityArray)                          <span class="comment">//[北京 上海 深圳]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type of cityArray:%T\n&quot;</span>, cityArray) <span class="comment">//type of cityArray:[3]string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用索引值初始化数组"><a href="#使用索引值初始化数组" class="headerlink" title="使用索引值初始化数组"></a>使用索引值初始化数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [...]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(a)                  <span class="comment">// [0 1 0 5]</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, a) <span class="comment">//type of a:[4]int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>go语言支持多维数组</p><h3 id="多维数组的定义"><a href="#多维数组的定义" class="headerlink" title="多维数组的定义"></a>多维数组的定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">3</span>][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a) <span class="comment">//[[北京 上海] [广州 深圳] [成都 重庆]]</span></span><br><span class="line">fmt.Println(a[<span class="number">2</span>][<span class="number">1</span>]) <span class="comment">//支持索引取值:重庆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意多维数组只有第一层可以用<code>...</code>来让编译器推到数组长度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支持的写法</span></span><br><span class="line">a := [...][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不支持多维数组的内层使用...</span></span><br><span class="line">b := [<span class="number">3</span>][...]<span class="type">string</span>&#123;</span><br><span class="line">&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go的类型转换"><a href="#Go的类型转换" class="headerlink" title="Go的类型转换"></a>Go的类型转换</h2><h3 id="Go语言中类型推断的特性"><a href="#Go语言中类型推断的特性" class="headerlink" title="Go语言中类型推断的特性"></a>Go语言中类型推断的特性</h3><p>go是强类型语言，对变量使用简单的类型推断</p><p><strong>go语言还进禁用了不同类型的之间的转换（常量除外）</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">a:=<span class="number">333</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int64</span></span><br><span class="line">b=a   <span class="comment">//会发生错误，因为a已经被推断为int类型，所以不能赋值给int64类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译器不会对变量标识符引用的值进行强制类型转换</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a:=<span class="number">1.1</span></span><br><span class="line">b:=a+<span class="number">1</span>    <span class="comment">//代码正确a被推断为浮点数，1会被转换为浮点数和a的值相加</span></span><br><span class="line"></span><br><span class="line">a:=<span class="number">1</span></span><br><span class="line">b:=a+<span class="number">1.1</span> <span class="comment">//代码错误，a已经被推断为整数，不能将a转化成浮点数，相加失败，编译器报错，constant 1.1 truncated to integer</span></span><br><span class="line"></span><br><span class="line">a:=<span class="number">1</span></span><br><span class="line">b:=<span class="number">1.1</span></span><br><span class="line">c:=a+b <span class="comment">//与上面的例子犯了相同的错误</span></span><br></pre></td></tr></table></figure><h1 id="Effective-Go"><a href="#Effective-Go" class="headerlink" title="Effective Go"></a>Effective Go</h1><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><h3 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h3><p><strong>getter 是一种获得属性值的方法，setter是一种设置属性值的方法</strong></p><p>Go 并不对获取器（getter）和设置器（setter）提供自动支持。应当自己提供获取器和设置器。但把 Get 放到获取器的名字中，既不复合习惯，也没有必要。假设有一个 owner （小写，未导出）的字段，其获取器的名字应该为 Owner（大写，可导出）而非 GetOwner。</p><p>若要提供设置器的方法，SetOwner 是个不错的选择。两个命名都看起来很合理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">owner := obj.Owner()</span><br><span class="line"><span class="keyword">if</span> owner!=user&#123;</span><br><span class="line"> obj.SetOwner(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口名"><a href="#接口名" class="headerlink" title="接口名"></a>接口名</h3><p>按照约定，只包含一个方法的接口应当以该方法的名称加上 <code>-er</code> 后缀来命名，如 Reader、Writer、Formatter、CloseNotifier 等。</p><p>Read、Write、Close、Flush、 String 等都具有典型的签名和意义。为避免冲突，请不要用这些名称为你的方法命名， 除非你明确知道它们的签名和意义相同。反之，若你的类型实现了的方法， 与一个众所周知的类型的方法拥有相同的含义，那就使用相同的命名。 例如将字符串转换方法命名为 String 而非 ToString。</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>可以使用 range 子句实现数组、切片、字符串或者映射的遍历，或从 channel 中读取消息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key,value := <span class="keyword">range</span> oldMap&#123;</span><br><span class="line">newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若只需要遍历键或者下标</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> m &#123;</span><br><span class="line"><span class="keyword">if</span> key.expired()&#123;</span><br><span class="line"><span class="built_in">delete</span>(m,key)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若只需要遍历第二个值，需要使用空白标识符</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> array &#123;</span><br><span class="line">sum += value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于字符串，range 能提供更多遍历。它能够通过解析 UTF-8，将每个独立的 Unicode 码点分离出来。错误的编码将占用一个rune，并用  <code>U+FFFD</code> 替代。（rune是 Go 对单个 Unicode 码点的称谓）。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> pos, char := <span class="keyword">range</span> <span class="string">&quot;日本 \ x80 語&quot;</span> &#123; <span class="comment">// \x80 is an illegal UTF-8 encoding</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;character %#U starts at byte position %d\n&quot;</span>, char, pos)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">character U+65E5 &#x27;日&#x27; starts at byte position 0</span><br><span class="line">character U+672C &#x27;本&#x27; starts at byte position 3</span><br><span class="line">character U+FFFD &#x27;�&#x27; starts at byte position 6</span><br><span class="line">character U+8A9E &#x27;語&#x27; starts at byte position 7</span><br></pre></td></tr></table></figure><p>最后，Go没有逗号操作符，++和–为语句而非表达式。因此，如果想要在 for 中使用多个变量，应采用平行赋值的方式（因为它会拒绝 ++ 和 –）。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reverse a</span></span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(a)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">a[i], a[j] = a[j], a[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p>switch 并不会自动下溯，但 case 可以通过逗号分割来列举相同的处理条件</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shouldEscape</span><span class="params">(c <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> c &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;&amp;&#x27;</span>, <span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch 可用于判断接口变量的动态类型。如 类型选择 通过圆括号中的关键字 <code>type</code> 使用类型断言语法。若 switch 在表达式中声明了一个变量，那么该变量的每个子句中都将有该变量对应的类型。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span>&#123;&#125; </span><br><span class="line">t = functionOfSomeType()   <span class="comment">//声明了新变量 t ， 作用域仅限于 switch 语句块内部</span></span><br><span class="line"><span class="keyword">switch</span> t := t.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;unexpected type %T&quot;</span>, t)       <span class="comment">// %T 输出 t 是什么类型</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;boolean %t\n&quot;</span>, t)             <span class="comment">// t 是 bool 类型</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;integer %d\n&quot;</span>, t)             <span class="comment">// t 是 int 类型</span></span><br><span class="line"><span class="keyword">case</span> *<span class="type">bool</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;pointer to boolean %t\n&quot;</span>, *t) <span class="comment">// t 是 *bool 类型</span></span><br><span class="line"><span class="keyword">case</span> *<span class="type">int</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;pointer to integer %d\n&quot;</span>, *t) <span class="comment">// t 是 *int 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="可命名结果形参"><a href="#可命名结果形参" class="headerlink" title="可命名结果形参"></a>可命名结果形参</h3><p>Go 函数的返回值或结果“形参”可被命名，并作为常规变量使用，就像传入的形参一样。命名后，一旦该函数开始执行，它们就会被初始化为与其类型响应的<strong>零值</strong>；<strong>若该函数执行了一条不带实参的 return 语句，则结果形参的当前值将被返回。</strong></p><p>此名称不是强制性的，但是能让代码更加简短清晰。可以把它们看作文档的一部分，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextInt</span><span class="params">(b []<span class="type">byte</span>, pos <span class="type">int</span>)</span></span> (value, nextPos <span class="type">int</span>) </span><br></pre></td></tr></table></figure><p>命名了 nextInt 的结果，那么它返回的 int 就值如其意了</p><p>由于被命名的结果已经初始化，且已经关联至无参数的返回，它们就能让代码简单而清晰。 下面的 io.ReadFull 就是个很好的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFull</span><span class="params">(r Reader, buf []<span class="type">byte</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(buf) &gt; <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">var</span> nr <span class="type">int</span></span><br><span class="line">nr, err = r.Read(buf)</span><br><span class="line">n += nr</span><br><span class="line">buf = buf[nr:]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>被推迟函数的实参（如果该函数为方法则还包括接收者）在推迟执行时就会被求值，而不是在调用执行时才求值。这样不仅无需担心变量值在函数执行时被改变，同时还意味着单个被推迟的调用可推迟多个函数的执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被推迟的函数按后进先出（LIFO）的顺序执行，因此以上代码在函数返回时会打印 4 3 2 1 0。</p><p>进：0 1 2 3 4 </p><p>出：4 3 2 1 0</p><p><strong>用程序跟踪函数的执行</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;entering:&quot;</span>, s)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">un</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;leaving:&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> un(trace(<span class="string">&quot;a&quot;</span>)) <span class="comment">//函数执行到这一步时, trace(&quot;a&quot;)就已经被执行了</span></span><br><span class="line">fmt.Println(<span class="string">&quot;in a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> un(trace(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">fmt.Println(<span class="string">&quot;in b&quot;</span>)</span><br><span class="line">a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">b()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">entering: b</span><br><span class="line">in b</span><br><span class="line">entering: a</span><br><span class="line">in a</span><br><span class="line">leaving: a</span><br><span class="line">leaving: b</span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="new-分配"><a href="#new-分配" class="headerlink" title="new 分配"></a>new 分配</h3><p>Go 提供了两种分配原语，即内建函数 <code>new</code> 和 <code>make</code> 。它们所做的事情不同，所应用的类型也不同。</p><p>先看 <code>new</code> 。这是个用来分配内存的内建函数，但与其他语言中的同名函数不同，它不会<strong>初始化内存</strong>，只会<strong>将内存置零</strong>。也就是说，<code>new(T)</code> 会为类型 <code>T</code> 的的新项分配已置零的内存空间，并返回它的地址，也就是一个类型为 <code>*T</code> 的值。用 Go 的术语来说，它返回一个指针，该指针指向新分配的，类型为 <code>T</code> 的零值。</p><p>既然 <code>new</code> 返回的内存已置零，那么设计数据结构时，每种类型的零值就不必进一步初始化了，这意味着该数据结构的使用者只需使用 <code>new</code> 创建一个新的对象就能使用了。</p><p> 例如，<code>bytes.Buffer</code> 的文档中提到的“零值的 Buffer 就是已准备就绪的缓冲区。”同样，<code>sync.Mutex</code> 并没有显式的构造函数或 init 方法，而是零值的 <code>sync.Mutex</code> 就已经被定义为已解锁的互斥锁。</p><p>“零值属性”是传递性的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SyncedBuffer strcut&#123;</span><br><span class="line">lock sync.Mutex</span><br><span class="line">buffer bytes.Buffer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SyncedBuffer 类型的值也是在声明时就分配好内存就绪了。后续代码中， p 和 v 无需进一步处理即可正常使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(SyncedBuffer)  <span class="comment">// type *SyncedBuffer</span></span><br><span class="line"><span class="keyword">var</span> v SyncedBuffer      <span class="comment">// type  SyncedBuffer</span></span><br></pre></td></tr></table></figure><h3 id="构造函数与复合字面量"><a href="#构造函数与复合字面量" class="headerlink" title="构造函数与复合字面量"></a>构造函数与复合字面量</h3><p>有时候置零还不够好，这时候就需要一个构造函数，如来自 os 包中的这段代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="type">int</span>, name <span class="type">string</span>)</span></span> *File &#123;</span><br><span class="line"><span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">f := <span class="built_in">new</span>(File)</span><br><span class="line">f.fd = fd</span><br><span class="line">f.name = name</span><br><span class="line">f.dirinfo = <span class="literal">nil</span></span><br><span class="line">f.nepipe = <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> f</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这段代码过于冗长，可以通过复合字面量来简化它</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="type">int</span>, name <span class="type">string</span>)</span></span> *File &#123;</span><br><span class="line"><span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">f := File&#123;fd, name, <span class="literal">nil</span>, <span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意返回一个局部变量的地址完全没有问题。该局部变量对应的数据在函数返回后依然有效。实际上每当获取一个复合字面量的地址时，都将为一个新的实例分配内存，一次可以将上面的最后两行代码合并：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;File&#123;fd, name, <span class="literal">nil</span>, <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><p>复合字面量的字段必须按照顺序全部列出。但如果以 kv 对的形式显示地标出元素，初始化字段是就可以按任何顺序出现，未给出地字段值将被赋予零值。因此可以用如下形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;File&#123;fd: fd, name: name&#125;</span><br></pre></td></tr></table></figure><p> 若复合字面量不包括任何字段，它将创建该类型的零值。即 <code>new(File)</code> 和 <code>&amp;File&#123;&#125;</code> 是等价的。</p><p>复合字面量同样可以用于创建数组、切片以及映射，字段标签是索引还是键则视情况而定。</p><p> 在下例初始化过程中，无论 Enone、Eio 和 Einval 的值是什么，只要它们的标签不同就行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Enone  = <span class="number">0</span></span><br><span class="line">Eio    = <span class="number">1</span></span><br><span class="line">Einval = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [...]<span class="type">string</span>&#123;Enone: <span class="string">&quot;no error&quot;</span>, Eio: <span class="string">&quot;Eio&quot;</span>, Einval: <span class="string">&quot;invalid argument&quot;</span>&#125;</span><br><span class="line">s := []<span class="type">string</span>&#123;Enone: <span class="string">&quot;no error&quot;</span>, Eio: <span class="string">&quot;Eio&quot;</span>, Einval: <span class="string">&quot;invalid argument&quot;</span>&#125;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;Enone: <span class="string">&quot;no error&quot;</span>, Eio: <span class="string">&quot;Eio&quot;</span>, Einval: <span class="string">&quot;invalid argument&quot;</span>&#125;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="make分配"><a href="#make分配" class="headerlink" title="make分配"></a>make分配</h3><p>内建函数 <code>make(T, args)</code> 的目的不同于 <code>new(T)</code> 。它只会用于<strong>创建切片、映射和channel</strong>，并返回类型为T（而非*T）的一个已初始化（而非置零的值）。出现这种差异的原因在于，这三种类型本质上 为引用数据类型，它们在使用前必须初始化。例如，切片是一个具有三项内容的描述符，包含一个指向（数组内部）数据的指针、长度以及容量，在这三项被初始化之前，该切片为nil。对于切片、映射和信道，make用于初始化其内部的数据结构并准备好将要使用的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>会分配一个具有100个int的数组空间，接着创建一个长度为10，容量为100并指向该数组中前十个元素的切片结构。（生成切片时，其容量可以省略）。与此相反，new([]int)会返回一个指向新分配的，已置零的切片结构，即一个指向 <code>nil</code> 切片值得指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *[]<span class="type">int</span> = <span class="built_in">new</span>([]<span class="type">int</span>)       <span class="comment">// allocates slice structure; *p == nil; rarely useful</span></span><br><span class="line"><span class="keyword">var</span> v  []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">100</span>) <span class="comment">// the slice v now refers to a new array of 100 ints</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unnecessarily complex:</span></span><br><span class="line"><span class="keyword">var</span> p *[]<span class="type">int</span> = <span class="built_in">new</span>([]<span class="type">int</span>)</span><br><span class="line">*p = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Idiomatic:</span></span><br><span class="line">v := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>make只适用于映射、切片和channel且不返回指针。若要获取明确的指针，需使用 new 分配内存或显示地获取一个变量的地址。</p><ul><li>make创建的映射、切片和channel是可以直接使用的</li><li>new创建的映射、切片和channel需要进一步分配和初始化底层数组</li></ul><h3 id="二维切片"><a href="#二维切片" class="headerlink" title="二维切片"></a>二维切片</h3><p>有时候必须分配一个二维数组，例如在处理像素的扫描行时，就会发生这种情况。有两种方式来达到这个目的。一种就是独立地分配每一个切片；另一种就是只分配一个数组，将各个切片都指向它。</p><p>若切片会增长或收缩，就应该通过独立分配来避免覆盖下一行；若不会，用单次分配来构造对象会更高效。</p><ul><li><p>方式一</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配顶层切片。</span></span><br><span class="line">picture := <span class="built_in">make</span>([][]<span class="type">uint8</span>, YSize) <span class="comment">// 每 y 个单元一行。</span></span><br><span class="line"><span class="comment">// 遍历行，为每一行都分配切片</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> picture &#123;</span><br><span class="line">picture[i] = <span class="built_in">make</span>([]<span class="type">uint8</span>, XSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式二</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配顶层切片，和前面一样。</span></span><br><span class="line">picture := <span class="built_in">make</span>([][]<span class="type">uint8</span>, YSize) <span class="comment">// 每 y 个单元一行。</span></span><br><span class="line"><span class="comment">// 分配一个大的切片来保存所有像素</span></span><br><span class="line">pixels := <span class="built_in">make</span>([]<span class="type">uint8</span>, XSize*YSize) <span class="comment">// 拥有类型 []uint8，尽管图片是 [][]uint8.</span></span><br><span class="line"><span class="comment">// 遍历行，从剩余像素切片的前面切出每行来。</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> picture &#123;</span><br><span class="line">picture[i], pixels = pixels[:XSize], pixels[XSize:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>map</p><p>如果尝试通过映射中不存在的键来取值，就会返回该映射中项的类型对应的零值。有时候需要区分某项是不存在还是其值为零值。如对一个值本应为零的条目，也可能是由于不存在该想而得到零值。可以使用螽赋值的形式来分辨这种情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> seconds <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> ok <span class="type">bool</span> </span><br><span class="line">seconds, ok = timeZone[tz]</span><br></pre></td></tr></table></figure><p>若 tz 存在， seconds 就会被赋予适当的值，且 ok 会被置为 true； 若不存在，seconds 则会被置为零，而 ok 会被置为 false。</p><p>若仅需判断映射中是否存在某项而不关心实际的值，可使用空白标识符 （_）来代替该值的一般变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, present := timeZone[tz]</span><br></pre></td></tr></table></figure><h3 id="Print"><a href="#Print" class="headerlink" title="Print"></a>Print</h3><p>像 %d 这样的数值格式并不接受表示符号或大小的标记， 打印例程会根据实参的类型来决定这些属性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">uint64</span> = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d %x; %d %x\n&quot;</span>, x, x, <span class="type">int64</span>(x), <span class="type">int64</span>(x))</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18446744073709551615 ffffffffffffffff; -1 -1</span><br></pre></td></tr></table></figure><p>如果只想要默认的转换，如使用十进制的整数，可以使用通用的格式 %v （对应“值”）；其结果与 Print 和 Println 的输出完全相同。此外这种格式还能打印任意值，包括数据、结构体和映射。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, timeZone)  <span class="comment">// or just fmt.Println(timeZone)</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[CST:-21600 PST:-28800 EST:-18000 UTC:0 MST:-25200]</span><br></pre></td></tr></table></figure><p>映射中的键可能按任意顺序输出。当打印结构体是，改进的格式 <code>%+v</code> 会为结构体的每个字段添上字段名，另一种格式 <code>%#v</code> 将顽强按照 Go 的语法打印值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="type">int</span></span><br><span class="line">b <span class="type">float64</span></span><br><span class="line">c <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">t := &amp;T&#123; <span class="number">7</span>, <span class="number">-2.35</span>, <span class="string">&quot;abc\tdef&quot;</span> &#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, t)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, t)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, t)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, timeZone)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;&#123;<span class="number">7</span> <span class="number">-2.35</span> abc   def&#125;</span><br><span class="line">&amp;&#123;a:<span class="number">7</span> b:<span class="number">-2.35</span> c:abc     def&#125;</span><br><span class="line">&amp;main.T&#123;a:<span class="number">7</span>, b:<span class="number">-2.35</span>, c:<span class="string">&quot;abc\tdef&quot;</span>&#125;</span><br><span class="line"><span class="keyword">map</span>[<span class="type">string</span>] <span class="type">int</span>&#123;<span class="string">&quot;CST&quot;</span>:<span class="number">-21600</span>, <span class="string">&quot;PST&quot;</span>:<span class="number">-28800</span>, <span class="string">&quot;EST&quot;</span>:<span class="number">-18000</span>, <span class="string">&quot;UTC&quot;</span>:<span class="number">0</span>, <span class="string">&quot;MST&quot;</span>:<span class="number">-25200</span>&#125;</span><br></pre></td></tr></table></figure><p>如果想控制自定义类型的默认格式，只需要为该类型定义一个具有 String()string 签名的方法。例如下面的类型 T 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d/%g/%q&quot;</span>, t.a, t.b, t.c)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, t)</span><br></pre></td></tr></table></figure><p>输出 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7/-2.35/&quot;abc\tdef&quot;</span><br></pre></td></tr></table></figure><p>如果需要向指向 T 的指针那样打印类型 T 的值， String 的接收者就必须是值类型的；上面的例子中接收者是一个指针，因为这对于结构来说更高效而通用。</p><p>这是 String 方法也可以调用 Sprintf 。注意不要通过调用 Sprintf 来构造 String 方法，因为这样会无限递归 String 方法。当 Sprintf 试图将一个接收者以字符串形式打印输出，而在此过程中反过来又调用了 Sprintf 时，这种情况就会出现，这是一个很常见的错误。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyString)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;MyString=%s&quot;</span>, m) <span class="comment">// Error: will recur forever.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fmt.Sprintf</code> 中使用 <code>%s</code> 格式化一个自定义类型时，会调用该类型的 <code>String()</code> 方法。这个例子中 <code>String </code>方法内部又调用了 <code>fmt.Sprintf</code> ，这样就导致了无限递归的错误。</p><p>要解决这个问题也很简单：将该实参转换为基本的字符串类型，这时候调用的是内建函数<code>string</code>，一次不会发生无限递归。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyString)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;MyString=%s&quot;</span>, <span class="type">string</span>(m)) <span class="comment">// OK: note conversion.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>Go 中的常量就是不变量。它们在编译时创建，即便它们可能是函数中定义的局部变量。 常量只能是数字、字符（符文）、字符串或布尔值。由于编译时的限制， 定义它们的表达式必须也是可被编译器求值的常量表达式。例如 1&lt;&lt;3 就是一个常量表达式，而 math.Sin(math.Pi&#x2F;4) 则不是，因为对 math.Sin 的函数调用在运行时才会发生。</p><p>在 Go 中，枚举常量使用枚举器 iota 创建。由于 iota 可为表达式的一部分，而表达式可以被隐式地重复，这样也就更容易构建复杂的值的集合了。</p><p>例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteSize <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// 通过赋予空白标识符来忽略第一个值</span></span><br><span class="line">    _           = <span class="literal">iota</span> <span class="comment">// ignore first value by assigning to blank identifier</span></span><br><span class="line">    KB ByteSize = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    MB</span><br><span class="line">    GB</span><br><span class="line">    TB</span><br><span class="line">    PB</span><br><span class="line">    EB</span><br><span class="line">    ZB</span><br><span class="line">    YB</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以这样使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b ByteSize)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> b &gt;= YB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fYB&quot;</span>, b/YB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= ZB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fZB&quot;</span>, b/ZB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= EB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fEB&quot;</span>, b/EB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= PB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fPB&quot;</span>, b/PB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= TB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fTB&quot;</span>, b/TB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= GB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fGB&quot;</span>, b/GB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= MB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fMB&quot;</span>, b/MB)</span><br><span class="line">    <span class="keyword">case</span> b &gt;= KB:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fKB&quot;</span>, b/KB)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%.2fB&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表达式 YB 会打印出 1.00YB，而 ByteSize(1e13) 则会打印出 9.09TB。</p><p>在这里用 Sprintf 实现 ByteSize 的 String 方法很安全（不会无限递归），它以 %f 调用了 Sprintf，它并不是一种字符串格式：Sprintf 只会在它需要字符串时才调用 String 方法，而 %f 需要一个浮点数值。</p><h3 id="init-函数"><a href="#init-函数" class="headerlink" title="init 函数"></a>init 函数</h3><p>每个源文件都可以通过当以自己的无参数 init 函数来设置一些必要的状态。一个包可以有多个 init 函数。一个源文件可以有多个 init 函数。它的结束就意味着初始化结束，只有该包中的所有变量都通过它们的初始化器求值后 init 才会被调用，</p><p>除了那些不能被表示成声明的初始化外，init 函数还常被用在程序真正开始执行前，检验或校正程序的状态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> user == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;$USER not set&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> home == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">home = <span class="string">&quot;/home/&quot;</span> + user</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> gopath == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">gopath = home + <span class="string">&quot;/go&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gopath may be overridden by --gopath flag on command line.</span></span><br><span class="line">flag.StringVar(&amp;gopath, <span class="string">&quot;gopath&quot;</span>, gopath, <span class="string">&quot;override default GOPATH&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行顺序</strong></p><ul><li>一个文件中的多个 init 函数执行顺序与其<strong>定义顺序</strong>一致</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;init a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;init b&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;init c&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">init a</span><br><span class="line">init b</span><br><span class="line">init c</span><br><span class="line">main</span><br></pre></td></tr></table></figure><ul><li>一个包中的多个 init 函数的执行顺序根据<strong>文件名的字典序</strong>来确定</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;init a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;init b&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;init c&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;init main&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go build &amp;&amp; ./main</span><br><span class="line">init a</span><br><span class="line">init b</span><br><span class="line">init c</span><br><span class="line">init main</span><br><span class="line">main</span><br></pre></td></tr></table></figure><ul><li>不同的包，不相互依赖，按照 main 包中导入顺序调用包的 init 函数，最后再调用 main 包的 init 函数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a 包</span></span><br><span class="line"><span class="comment">// a.go</span></span><br><span class="line"><span class="keyword">package</span> a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;init a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b 包</span></span><br><span class="line"><span class="comment">// b.go</span></span><br><span class="line"><span class="keyword">package</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;init b&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 包</span></span><br><span class="line"><span class="comment">// c.go</span></span><br><span class="line"><span class="keyword">package</span> c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;init c&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 包</span></span><br><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">&quot;main/a&quot;</span></span><br><span class="line">_ <span class="string">&quot;main/b&quot;</span></span><br><span class="line">_ <span class="string">&quot;main/c&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;init main&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go build &amp;&amp; ./main</span><br><span class="line">init a</span><br><span class="line">init b</span><br><span class="line">init c</span><br><span class="line">init main</span><br><span class="line">main</span><br></pre></td></tr></table></figure><ul><li>不同的包，存在相互依赖</li></ul><p>假设有包 a，b 和 c，main 包，main import a ，a import b，b import c，即依赖关系为 main &gt; a &gt; b &gt; c，按照包导入的依赖关系决定执行顺序。 调用顺序为最后被依赖的最先被初始化，如导入顺序 main &gt; a &gt; b &gt; c，则初始化顺序为 c &gt; b &gt; a &gt; main，依次执行对应的 init 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.go</span></span><br><span class="line"><span class="keyword">package</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;main/b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;init a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.go</span></span><br><span class="line"><span class="keyword">package</span> b</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;main/c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;init b&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c.go</span></span><br><span class="line"><span class="keyword">package</span> c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;init c&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">&quot;main/a&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;init main&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go build &amp;&amp; ./main</span><br><span class="line">init c</span><br><span class="line">init b</span><br><span class="line">init a</span><br><span class="line">init main</span><br><span class="line">main</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>指针 vs. 值</p><p>如 <code>Bytesize</code>我们可以为任何已命名的类型（除了指针或接口）定义方法；接收者不一定为结构体。</p><p>将函数修改为与标准 Write 类似的方法，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ByteSlice)</span></span> Write(data []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">slice := *p</span><br><span class="line"><span class="comment">// Again as above.</span></span><br><span class="line">*p = slice</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(data), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么类型 <code>*ByteSlice</code> 就满足了标准的 <code>io.Writer</code> 接口，这将非常使用。例如，可以通过打印将内容写入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b ByteSlice</span><br><span class="line">fmt.Fprintf(&amp;b, <span class="string">&quot;This hour has %d days\n&quot;</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>以指针或值为接收者的区别在于：值方法可通过指针和值调用， 而指针方法只能通过指针来调用。</p><p>之所以有这条规则是因为指针方法可以修改接收者；通过值调用它们会导致方法接收到该值的副本，因此任何修改都将被丢弃，因此该语言不允许这种错误。</p><p>注意有一个例外：当这个值是可寻址的，那么该语言就会自动插入取值操作符来对付一般的通过值调用的指针方法。在我们的例子中，变量b是可寻址的，因此只需要通过 <code>b.Write</code> 来调用它的 <code>Write</code> 方法，编译器会将它重写为 <code>(&amp;b).Write</code></p><h2 id="接口和其他类型"><a href="#接口和其他类型" class="headerlink" title="接口和其他类型"></a>接口和其他类型</h2><p>Go 中的接口为指定对象的行为提供了一种方法：如果某样东西能做这个，那么他就可以被用在这里。</p><p>有很多这样简单的例子：通过实现 String 方法，可以自定义打印函数；通过实现 Write 方法，Fprint 能对任何对象产生输出。在 Go 代码中，仅包含一两种方法的接口很常见，且其名称通常来自于实现它的方法，例如 <code>io.Writer</code> 就是实现了 Write 的一类对象。</p><p>每种类型都能实现多个接口。例如一个实现了 sort.Interface 接口的集合就可通过 sort 包中的函数进行排序。该接口包括 <code>Len()</code> 、<code>Less(i,j int)bool</code> 、<code>Swap(i,j int)</code> 方法。另外该集合还可以有一个自定义的格式化器。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Sequence []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Methods required by sort.Interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s[i] &lt; s[j]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">    s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Method for printing - sorts the elements before printing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    sort.Sort(s)</span><br><span class="line">    str := <span class="string">&quot;[&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i, elem := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">            str += <span class="string">&quot; &quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        str += fmt.Sprint(elem)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str + <span class="string">&quot;]&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>Sequence 的 String 方法重新实现了 Sprint 为切片实现的功能。若我们在调用 Sprint 之前将 Sequence 转换为的 []int ，就能共享已经实现的功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">sort.Sort(s)</span><br><span class="line"><span class="keyword">return</span> fmt.Sprint([]<span class="type">int</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法时通过类型转换技术，在 String 方法中安全调用 Sprintf 的另一个例子。若我们忽略类型名的话，这两种类型（Sequence和[]int）其实是相同的，因此在二者之间进行转换是合法的。转换过程并不会创建新值，只是暂时让现有的值看起来有个新类型而已。（有些合法转换会创建新值，如从整型转换为浮点型等）</p><p>在 Go 程序中，为访问不同的方法集而进行类型转换的情况非常常见。例如，可以使用现有的 sort.IntSlice 类型来简化上面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Sequence []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Method for printing - sorts the elements before printing</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">sort.IntSlice(s).Sort()</span><br><span class="line"><span class="keyword">return</span> fmt.Sprint([]<span class="type">int</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，不必让 Sequence 实现多个接口（排序和打印），我们可以通过将数据条目转换为多种类型（Sequence、sort.IntSlice 和 []int）来使用相应的功能，每次转换都完成一部分工作。</p><h3 id="接口转换与类型断言"><a href="#接口转换与类型断言" class="headerlink" title="接口转换与类型断言"></a>接口转换与类型断言</h3><p>类型选择 是类型转换的一种形式：它接受一个接口，在选择（swtich）中根据判断选择对应的情况（case），并在某种意义上将其转换为该种类型。以下代码为 <code>fmt.Printf</code> 通过类型选择将值转换为字符串的简化版。若它已经为字符串，我们需要该接口中实际的字符串值；若它有 String 方法，我们则需要调用该方法所得的结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">String() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 调用者提供的值。</span></span><br><span class="line"><span class="keyword">switch</span> str := value.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line"><span class="keyword">return</span> str</span><br><span class="line"><span class="keyword">case</span> Stringer:</span><br><span class="line"><span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种情况获取具体的值，第二种将接口转换为另一个接口。这种方式对于混合类型来说非常完美。</p><p>如果我们只关心一种类型呢？如果我们知道该值拥有一个 string 而想要提取它呢？只需要一种情况的了类型选择就行，但它需要类型断言。类型断言接受一个接口值，并从中提取指定的明确类型的值。其语法借鉴自类型选择开口的子句，但它需要一个具体的类型，而非 <code>type</code> 关键字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value.(typeName)</span><br></pre></td></tr></table></figure><p>其结果是拥有静态类型 <code>typeName</code> 的新值。该类型必须为该接口所拥有的具体类型，或者该值可转换成的第二种接口类型，要提取我们知道在该值中的字符串，可以这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str := value.(<span class="type">string</span>)</span><br></pre></td></tr></table></figure><p>但若他所转换的值中不包含字符串，该程序就会以运行时错误崩溃，为避免这种情况，需要使用”, ok“ 来安全地测试它是不是字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str, ok := value.(<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串值为 %q\n&quot;</span>, str)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;该值非字符串\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若类型断言失败，str 将继续存在且为字符串类型，但它将拥有零值，即空字符串。</p><p>作为对这种能力的说明，这里有个 if-else 语句，它等价于本节开头的类型选择。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> str, ok := value.(<span class="type">string</span>); ok &#123;</span><br><span class="line"><span class="keyword">return</span> str</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> str, ok := value.(Stringer); ok &#123;</span><br><span class="line"><span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通用性"><a href="#通用性" class="headerlink" title="通用性"></a>通用性</h3><p>若某种现有的类型实现了一个接口，且除此之外并无可导出的方法，则该类型本身就无需导出。仅导出接口能让我们更专注于其行为而非实现，其他属性不同的实现则能反映该原始类型的行为。这也能避免为每个通用接口的实例重复编写文档。</p><p>在这种情况下，构造函数应当返回一个接口值而非实现的类型。例如在 <code>hash</code> 库中， <code>rs32.NewIEEE</code> 和 <code>adler32.New</code> 都返回接口类型 <code>hash.Hash32</code> 。要在 Go 程序中使用 Adler-32 算法替代 CRC-32，只需修改构造函数调用即可，其余代码则不受算法改变的影响。</p><p>同样的方式能将 crypto 包中多种联系在一起的流密码算法与块密码算法分开。 crypto&#x2F;cipher 包中的 Block 接口指定了块密码算法的行为， 它为单独的数据块提供加密。接着，和 bufio 包类似，任何实现了该接口的密码包都能被用于构造以 Stream 为接口表示的流密码，而无需知道块加密的细节。</p><p><code>crypto/cipher</code> 接口看起来就像这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">interface</span> &#123;</span><br><span class="line">BlockSize() <span class="type">int</span></span><br><span class="line">Encrypt(src, dst []<span class="type">byte</span>)</span><br><span class="line">Decrypt(src, dst []<span class="type">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stream <span class="keyword">interface</span> &#123;</span><br><span class="line">XORKeyStream(dst, src []<span class="type">byte</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是计数器模式 （CTR ）流的定义，它将块加密改为流加密，注意块加密的细节已被抽象化了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewCTR 返回一个 Stream，其加密 / 解密使用计数器模式中给定的 Block 进行。</span></span><br><span class="line"><span class="comment">// iv 的长度必须与 Block 的块大小相同。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCTR</span><span class="params">(block Block, iv []<span class="type">byte</span>)</span></span> Stream</span><br></pre></td></tr></table></figure><p>NewCTR 的应用并不仅限于特定的加密算法和数据源，它适用于任何对 Block 接口和 Stream 的实现。因为它们返回接口值， 所以用其它加密模式来代替 CTR 只需做局部的更改。构造函数的调用过程必须被修改， 但由于其周围的代码只能将它看做 Stream，因此它们不会注意到其中的区别。</p><h3 id="接口和方法"><a href="#接口和方法" class="headerlink" title="接口和方法"></a>接口和方法</h3><p>由于几乎任何类型都能添加方法，因此几乎所有任何类型都能满足一个接口。</p><p>一个很直观的例子就是 http 包中定义的 Handler 接口。任何实现 Handler 的对象都能够处理 http 请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span>&#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ResponseWriter 接口提供了对方法的访问，这些方法需要响应客户端的请求。 由于这些方法包含了标准的 Write 方法，因此 http.ResponseWriter 可用于任何 io.Writer 适用的场景。Request 是一个包含已解析的客户端请求的结构体。</p><p><strong>为简单起见，这里假设所有的 HTTP 请求都是 GET 方法。下面有一个简短的处理程序实现，用于记录某个页面被访问的次数。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Simple counter server.</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">n <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctr *Counter)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">ctr.n++</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;counter = %d\n&quot;</span>, ctr.n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面将这样一个服务器添加到 URL 树的一个节点上</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br><span class="line">...</span><br><span class="line">ctr := <span class="built_in">new</span>(Counter)</span><br><span class="line">http.Handle(<span class="string">&quot;/counter&quot;</span>, ctr)</span><br></pre></td></tr></table></figure><p>事实上这里 Counter 不一定要是一个结构体，一个整数就够了</p><p>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Simple counter server.</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctr *Counter)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request)&#123;</span><br><span class="line">*ctr++</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;counter = %d\n&quot;</span>,*ctr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>页面被访问时，可以通过绑定一个 channel  通知程序</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A channel that sends a notification on each visit.</span></span><br><span class="line"><span class="comment">// (Probably want the channel to be buffered.)</span></span><br><span class="line"><span class="keyword">type</span> Chan <span class="keyword">chan</span> *http.Request</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ch Chan)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">ch &lt;- req</span><br><span class="line">fmt.Fprint(w, <span class="string">&quot;notification sent&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最后假设需要输出调用服务器二进制程序时使用的实参 <code>args</code> 。如下：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArgServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(os.Args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何将它转换为 HTTP 服务器？既然可以为除了指针和接口以为的任何类型定义方法，同样也能为函数写一个方法。http 包包含以下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The HandlerFunc type is an adapter to allow the use of</span></span><br><span class="line"><span class="comment">// ordinary functions as HTTP handlers.  If f is a function</span></span><br><span class="line"><span class="comment">// with the appropriate signature, HandlerFunc(f) is a</span></span><br><span class="line"><span class="comment">// Handler object that calls f.</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(c, req).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, req *Request) &#123;</span><br><span class="line">f(w, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HandlerFunc 是一个具有 ServerHTTP 方法的类型，因此该类型的值就能处理 HTTP 请求。</p><p>为了将 ArgsServer 实现成 HTTP 服务器，首先得有合适的签名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Argument server.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArgServer</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintln(w, os.Args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArgServer 和 HandlerFunc 现在拥有了相同的签名， 因此我们可将其转换为这种类型以访问它的方法，就像我们将 Sequence 转换为 IntSlice 以访问 IntSlice.Sort 那样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.Handle(<span class="string">&quot;/args&quot;</span>, http.HandlerFunc(ArgServer))</span><br></pre></td></tr></table></figure><p>当访问 &#x2F;args 页面时，该页面的处理程序就有了值 ArgServer 和类型 HandlerFunc。 HTTP 服务器会以 ArgServer 为接收者，调用该类型的 ServeHTTP 方法，它会反过来调用 ArgServer（通过 f(c, req)），接着实参就会被显示出来。</p><h2 id="空白表示符"><a href="#空白表示符" class="headerlink" title="空白表示符"></a>空白表示符</h2><p>空白标识符可被赋予或声明为任何类型的任何值，其值会被无害地丢弃。有点像 Unix 中的 &#x2F;dev&#x2F;null 文件：它表示只写的值，在需要变量但不需要实际值的地方用作占位符。</p><h3 id="多重赋值中的空白表示符"><a href="#多重赋值中的空白表示符" class="headerlink" title="多重赋值中的空白表示符"></a>多重赋值中的空白表示符</h3><p>for range 循环中对空白标识符的用法是一种具体情况，更一般的情况即为多重赋值。</p><p>若某次赋值需要匹配多个左值，但其中某个变量不会被程序使用， 那么用空白标识符来代替该变量可避免创建无用的变量，并能清楚地表明该值将被丢弃。 例如，当调用某个函数时，它会返回一个值和一个错误，但只有错误很重要， 那么可使用空白标识符来丢弃无关的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err := os.Stat(path); os.IsNotExist(err) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s does not exist\n&quot;</span>, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="未使用的导入和变量"><a href="#未使用的导入和变量" class="headerlink" title="未使用的导入和变量"></a>未使用的导入和变量</h3><p>若导入某个包或某个变量而不使用它就会产生错误。未使用的包会让程序膨胀并拖慢编译速度，而已初始化但未使用的变量不仅会浪费计算能力，还可能暗藏更大的 bug 。然而在程序开发过程中，经常会产生为使用的导入和变量，虽然以后会用到它们，但是为了完成编译又不得不删除它们才行，空白标识符能提供一个临时解决方案。</p><p>下面有一个写了一半的程序有两个个未使用的导入（<code>fmt</code> 和 <code>io</code>）以及一个未使用的变量 <code>fd</code>，因此它不能编译。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fd, err := os.Open(<span class="string">&quot;test.go&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> use fd.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要让编译停止关于未使用导入的报错，需要空白标识符来引用已导入包中的符号。同样，将未使用的变量 fd 赋予空白标识符来关闭未使用变量的报错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = fmt.Printf <span class="comment">// For debugging; delete when done. </span></span><br><span class="line"><span class="keyword">var</span> _ io.Reader    <span class="comment">// For debugging; delete when done. </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fd, err := os.Open(<span class="string">&quot;test.go&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> use fd.</span></span><br><span class="line">    _ = fd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照惯例，我们应在导入并加以注释后，再使全局声明导入错误静默，这样可以让它们更易找到， 并作为以后清理它的提醒。</p><h3 id="空白导入"><a href="#空白导入" class="headerlink" title="空白导入"></a>空白导入</h3><p>又叫匿名导入</p><p>像前面 fmt 或 io 这种未使用的导入最后都要被处理。但有时导入某个包只是为了其副作用，而没有任何明确的使用。例如在 net&#x2F;http&#x2F;pprof 包中的 <strong>init</strong> 函数中记录了 HTTP 处理程序的调试信息。它有个可导出的 API ，但大部分客户端只需要该处理程序的记录和通过 Web 页面访问数据。欲导入一个只使用其副作用的包只需要将该包重命名为空白表示符</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;net/http/pprof&quot;</span></span><br></pre></td></tr></table></figure><p>这种导入格式能明确表示该包是为其副作用而导入的，因为没有其它使用该包的可能： 在此文件中，它没有名字。</p><p>空白导入或匿名导入在以下几种情况下可能会被使用：</p><ol><li>执行包的<code>init</code>函数：有些包在导入时需要执行一些初始化逻辑，但在代码中并不直接使用该包的功能。此时，可以使用空白导入来确保执行包的<code>init</code>函数。</li><li>注册驱动或插件：某些驱动或插件需要在导入时注册自己，以便在后续的程序执行中被正确地识别和使用。通过空白导入，可以让驱动或插件的<code>init</code>函数得到执行，从而进行注册。</li><li>副作用操作：一些包可能会在导入时产生副作用，例如修改程序状态、注册全局变量等。通过空白导入，可以触发这些副作用操作。</li><li>触发编译器插件：有些包是为了触发编译器插件而导入的。这些插件在编译过程中会检查代码，并可能进行一些额外的代码转换或优化。通过空白导入，可以让编译器插件感知到需要处理的代码。</li></ol><h3 id="接口检查"><a href="#接口检查" class="headerlink" title="接口检查"></a>接口检查</h3><h4 id="类型一"><a href="#类型一" class="headerlink" title="类型一"></a>类型一</h4><p>一个类型无需显式地声明它实现了某个接口。取而代之，该类型只要实现了某个接口的方法，其实就实现了该接口。在实践中，大部分接口转换都是静态，因此会在编译时检测。例如，将一个 <code>*os.File</code> 传入一个接收 <code>io.Reader</code> 函数将不会被编译，除非 <code>*os.File</code>  实现了 <code>io.Reader</code>  接口。</p><p>尽管如此，有些接口检查会在运行时进行。例如, <code>encoding/json</code> 包定义了一个 <code>Marshaler</code> 接口。当 JSON 编码器接收到了一个实现该接口的值，那么该编码器就会调用该值的编组方法，将其转换为 JSON，而非进行标准的转换。编码器在运行时通过类型断言检查其属性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m, ok := val.(json.Marshaler)</span><br></pre></td></tr></table></figure><p>若只需要判断某个类型是否实现了某个接口，而不需要实际使用接口本身，就是用空白标识符来忽略类型断言的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _, ok := val.(json.Marshaler);ok&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;value %v of type %T implements json.Marshaler\n&quot;</span>,val,val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型二"><a href="#类型二" class="headerlink" title="类型二"></a>类型二</h4><p>若某个类型（例如 json.RawMessage）需要一种定制的 JSON 表现时，它应当实现 json.Marshaler，<strong>不过现在没有静态转换可以让编译器自动验证它</strong>。又或者该类型通过忽略转换失败来满足该接口，那么 JSON 编码器仍可工作，但它不会使用自定义的实现。为确保其实现正确，可在该包中用空白标识符声明一个全局变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ json.Marshaler = (*RawMessage)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>此声明中，调用了一个 <code>*RawMessage </code>转换并将其赋予了 Marshaler，以此来要求<code>*RawMessage</code> 实现 Marshaler，这时其属性就会在编译时被检测。若 json.Marshaler 接口被更改，此包将无法通过编译，这样就能注意到它需要更新。</p><p>这种结构中出现空白表示符，即表示该声明的存在只是为了类型检查。</p><p>不要为了实现接口对任何类型都使用这种方法，作为约定，仅当代码中不存在静态类型转换时才使用这种声明。</p><h2 id="内嵌"><a href="#内嵌" class="headerlink" title="内嵌"></a>内嵌</h2><p>Go 并不提供典型的，类型驱动的子类化概念，但通过将类型内嵌到结构体或接口中，就能使用部分实现。</p><h3 id="接口内嵌"><a href="#接口内嵌" class="headerlink" title="接口内嵌"></a>接口内嵌</h3><p>接口内嵌非常简单，例如 <code>io.Reader</code> 和 <code>io.Writer</code> 接口，下面是它的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">Read(p []<span class="type">byte</span>)(n <span class="type">int</span>,err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">Write(p []<span class="type">byte</span>)(n <span class="type">int</span>,err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>io 包也导出了一些其它接口，以此来阐明对象所需要实现的方法。例如 io.ReadWriter 就是个包含 Read 和 Write 的接口。我们可以通过显式的列出这两个方法来指明 io.ReadWriter，但通过这两个接口内嵌到新的接口中显然更容易且更具启发性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadWriter is the interface that combines the Reader and Writer interfaces.</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span>&#123;</span><br><span class="line">Reader</span><br><span class="line">Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReadWriter 能够做任何 Reader 和 Writer 可以做到的事情，它是内嵌了接口的联合体。<strong>只有接口能被内嵌到接口中。</strong></p><h3 id="结构体内嵌"><a href="#结构体内嵌" class="headerlink" title="结构体内嵌"></a>结构体内嵌</h3><p>同样的思想可以应用在结构体中，但意义更深远。bufio 包中有 bufio.Reader 和 bufio.Writer 这两个结构体类型，它们每一个都实现了与 io 包中相同意义的接口。此外，bufio 还通过结合 reader&#x2F;writer 并将其内嵌到结构体中，实现了带缓冲的 reader&#x2F;writer：它在结构体中列出了这些类型，但是匿名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadWriter stores pointers to a Reader and a Writer.</span></span><br><span class="line"><span class="comment">// It implements io.ReadWriter.</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">reader *Reader</span><br><span class="line">writer *Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内嵌的元素为指向结构体的指针，<strong>在使用前必须被初始化为指向有效结构体的指针</strong>。但为了提升该字段的方法并满足 io 接口，同样需要提供转发的方法，就像这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *ReadWriter)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> rw.reader.Read(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者显示地指定字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rw ReadWriter</span><br><span class="line">rw.reader.Read()</span><br></pre></td></tr></table></figure><p>而通过直接内嵌结构体（匿名），就能避免这样的繁琐。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">struct</span> &#123;</span><br><span class="line"> *Reader</span><br><span class="line"> *Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候内嵌类型的方法可以直接引用，当匿名内嵌的类型中有同名的方法时，尝试直接调用这个方法时编译器会报错，解决办法是指定类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rw ReadWriter</span><br><span class="line">rw.Reader.Read()</span><br></pre></td></tr></table></figure><p>现在的嵌套关系是：<code>bufio.ReadWriter</code> &gt;&gt; <code>bufio.Reader/bufio.Writer</code> &gt;&gt; <code>io.Reader/io.Writer</code> 这意味着 bufio.ReadWriter 不仅包括 bufio.Reader 和 bufio.Writer 的方法，它还同时满足下列三个接口： io.Reader、io.Writer 以及 io.ReadWriter。</p><p>当内嵌一个类型时，该类型的方法会成为外部类型的方法，但当它们被调用时，该方法的接收者是内部类型，而非外部的。在上面的例子中，当 bufio.ReadWriter 的 Read 方法被调用时，接收者是 ReadWriter 的 reader 字段，而非 ReadWriter 本身。</p><h3 id="另一个例子"><a href="#另一个例子" class="headerlink" title="另一个例子"></a>另一个例子</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">Command <span class="type">string</span></span><br><span class="line">*log.Logger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若我们需要直接引用内嵌字段，<strong>可以忽略包限定名</strong>，直接将该字段的类型名作为字段名。例如，我们需要访问 Job 类型的变量 job 的 <code>*log.Logger</code>， 可以直接写作 job.Logger。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(job *Job)</span></span> Logf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">job.Logger.Logf(<span class="string">&quot;%q: %s&quot;</span>, job.Command, fmt.Sprintf(format, args...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内嵌类型会引入命名冲突的问题，但解决方法却很简单。首先，字段或方法 X 会隐藏该类型中更深层嵌套的其他项 X。例如，若 log.Logger 包含一个名为 Logf 的方法，Job 的 Logf 方法会覆盖它。</p><p>其次，若相同的嵌套层级上出现同名冲突，通常会产生一个错误。若 Job 结构体中包含名为 Logger 的字段或方法，再将 log.Logger 内嵌到其中的话就会产生错误。然而，若重名的字段或方法不在该类型定义之外的程序中使用，那就不会报错。  因此，就算添加的字段或方法与另一个中的字段或方法相冲突，只要不使用就没问题。</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating.</p><p>不要通过共享内存来通信，而应通过通信来共享内存。</p></blockquote><h3 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h3><p>之所以称之为 <code>Goroutine</code> 是因为现有的术语：线程、协程、进程……都无法准确传达它的含义。Goroutine 是轻量级的，所有消耗几乎就只有栈空间的分配，而且栈最开始是非常小的，所以 Goroutine 很廉价，仅在需要时才会随着堆空间的分配（和释放）而变化。</p><p>Goroutine 在多线程操作系统上可实现多路复用，因此若一个线程阻塞，比如说等待 I&#x2F;O，那么其它的线程就会运行。Goroutine 的设计隐藏了线程创建和管理的诸多复杂性。</p><p>在函数或方法前添加 go 关键字能够在新的 goroutine 中调用它。当调用完成后，该 goroutine 也会安静地退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> list.Sort()  <span class="comment">// run list.Sort concurrently; don&#x27;t wait for it.</span></span><br></pre></td></tr></table></figure><p>在 Go 中，函数字面都是闭包：其实现在保证了函数内引用变量的生命周期与函数的活动时间相同。</p><h3 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h3><p>Channels 和 map 一样，也需要 make 来分配内存，其结果值充当了对底层数据结构的引用。若提供了一个可选的整数形参，就会为 channel 设置缓冲区大小。默认值时零，表示不带缓冲或同步的 channel。</p><p>无缓冲信道在通信时会同步交换数据，它能确保（两个 goroutine）计算处于确定状态。</p><p>接收者在收到数据前会一直阻塞。若信道是不带缓冲的，那么在接收者收到值前， 发送者会一直阻塞；若信道是带缓冲的，则发送者直到值被复制到缓冲区才开始阻塞； 若缓冲区已满，发送者会一直等待直到某个接收者取出一个值为止。</p><p>带缓冲的信道可被用作信号量，例如限制吞吐量。在此例中，进入的请求会被传递给 handle，它从信道中接收值，处理请求后将值发回该信道中，以便让该 “信号量” 准备迎接下一次请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sem = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, MaxOutstanding)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(r *Request)</span></span> &#123;</span><br><span class="line">sem &lt;- <span class="number">1</span> <span class="comment">// 等待活动队列清空。</span></span><br><span class="line">process(r)  <span class="comment">// 可能需要很长时间。</span></span><br><span class="line">&lt;-sem    <span class="comment">// 完成；使下一个请求可以运行。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">req := &lt;-queue</span><br><span class="line"><span class="keyword">go</span> handle(req)  <span class="comment">// 无需等待 handle 结束。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦有 MaxOutstanding 个 handlers  进入运行状态，其他的所有 handler 都会在试图发送值到信道缓冲区的时候阻塞，直到某个 handler 完成处理并从缓冲区取回一个值为止。</p><p>但是存在一个问题：尽管只有 MaxOutstanding 个 goroutine 能同时运行，但 Serve 还是为每个进入的请求都创建了新的 goroutine 。其结果就是，若请求来得很快，该程序就会无限地消耗资源。为了弥补这种不足，我们可以通过修改 Serve  来限制创建 Goroutine。</p><p><strong>！！！要注意这里出现的一个常见的 bug ！！！</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> req:=<span class="keyword">range</span> queue &#123;</span><br><span class="line">sem &lt;- <span class="number">1</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">process(req)   <span class="comment">// Bug !!!!</span></span><br><span class="line">&lt;-sem</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bug 出现在 Go 的 for 循环中，该循环变量在每次迭代时会被重用，因此 req 变量会在所有的 goroutine 间共享，这不是我们想要的。我们需要确保 req 对于每个 goroutine 来说都是唯一的。有一种方法能够做到，就是将 req 的值作为实参传入到该 goroutine 的闭包中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> req := <span class="keyword">range</span> queue &#123;</span><br><span class="line">sem &lt;- <span class="number">1</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(req *Request)</span></span> &#123;</span><br><span class="line">process(req)</span><br><span class="line">&lt;-sem</span><br><span class="line">&#125;(req)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种解决方案就是一相同的名字创建新的变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> req := <span class="keyword">range</span> queue &#123;</span><br><span class="line">req := req <span class="comment">// Create new instance of req for the goroutine.</span></span><br><span class="line">sem &lt;- <span class="number">1</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">process(req)</span><br><span class="line">&lt;-sem</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的写法看起来很奇怪</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req := req</span><br></pre></td></tr></table></figure><p>但在 Go 中这样的做法是合法且管用的。这里使用了相同的名字获得了这个变量的一个新的版本，以此来屏蔽循环变量，使 req 对每个 goroutine 唯一。</p><p>回到编写服务器的一般问题上。另一种管理资源的好方法就是启动固定数量的 hanlde goroutine，一起从请求信道中读取数据。Goroutine 的数量限制了同时调用 process 的数量。Serve 同样会收到一个通知退出的信道，在启动所有 goroutine 后，它将阻塞并暂时停止从信道中接收消息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> r := <span class="keyword">range</span> queue &#123;</span><br><span class="line">process(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(clientRequests <span class="keyword">chan</span> *Request, quit <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 启动处理程序</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; MaxOutstanding; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> handle(clientRequests)</span><br><span class="line">&#125;</span><br><span class="line">&lt;-quit  <span class="comment">// 等待通知退出。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信道的信道"><a href="#信道的信道" class="headerlink" title="信道的信道"></a>信道的信道</h3><p>Go 最重要的特性就是 channel 是一等值，它可以被分配并像其它值到处传递。这种特性通常被用来实现安全、并行的多路分解。</p><p>在上面的例子中，handle 是个非常理想化的请求处理程序，没有定义它所处理的请求类型。若该类型包含一个可用于回复的信道，那么每一个客户端都能为其响应提供自己的路径。以下为 Request  类的大概定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">args        []<span class="type">int</span></span><br><span class="line">f           <span class="function"><span class="keyword">func</span><span class="params">([]<span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line">resultChan  <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端提供一个函数及其实参，在请求对象中还有一个接收响应的信道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a []<span class="type">int</span>)</span></span> (s <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">s += v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request := &amp;Request&#123;[]<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, sum, <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)&#125;</span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">clientRequests &lt;- request</span><br><span class="line"><span class="comment">// 等待回应</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;answer: %d\n&quot;</span>, &lt;-request.resultChan)</span><br></pre></td></tr></table></figure><p>在服务端，只需改动 handle 函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> req := <span class="keyword">range</span> queue &#123;</span><br><span class="line">req.resultChan &lt;- req.f(req.args)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并行化"><a href="#并行化" class="headerlink" title="并行化"></a>并行化</h3><p>这些设计的另一个应用是在多 CPU 核心上实现并行计算。如果计算过程能够被分为几块可独立执行的过程，它就可以在每块计算结束时向信道发送信号，从而实现并行处理。</p><p>举一个理想化的例子。下面的代码在对一系列向量项进行极耗资源的操作， 而每个项的值计算是完全独立的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vector []<span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将此操应用至 v[i], v[i+1] ... 直到 v[n-1]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vector)</span></span> DoSome(i, n <span class="type">int</span>, u Vector, c <span class="keyword">chan</span> <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> ; i &lt; n; i++ &#123;</span><br><span class="line">v[i] += u.Op(v[i])</span><br><span class="line">&#125;</span><br><span class="line">c &lt;- <span class="number">1</span>    <span class="comment">// 发信号表示这一块计算完成。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在循环中启动了独立的处理块，每个 CPU 将执行一个处理。 它们有可能以乱序的形式完成并结束，但这没有关系； 我们只需在所有 goroutine 开始后接收，并统计信道中的完成信号即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NCPU = <span class="number">4</span>  <span class="comment">// CPU 核心数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vector)</span></span> DoAll(u Vector) &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, NCPU)  <span class="comment">// 缓冲区是可选的，但明显用上更好</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NCPU; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> v.DoSome(i*<span class="built_in">len</span>(v)/NCPU, (i+<span class="number">1</span>)*<span class="built_in">len</span>(v)/NCPU, u, c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 排空信道。</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NCPU; i++ &#123;</span><br><span class="line">&lt;-c    <span class="comment">// 等待任务完成</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一切完成。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可溢出的缓冲区"><a href="#可溢出的缓冲区" class="headerlink" title="可溢出的缓冲区"></a>可溢出的缓冲区</h3><p>并发编程的工具甚至能很容易地表达出非并发的思想。下面有一个提取自 RPC 包的例子。客户端 Goroutine 从某些来源，可能是网络手机数据。为了避免你分配和释放缓冲区，它维持一个空列表，使用一个带缓冲 channel 表示。若信道为空，就会分配新的缓冲区。一旦消息缓冲区就绪，将通过 serverChan 被发送到服务器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> freeList = <span class="built_in">make</span>(<span class="keyword">chan</span> *Buffer, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> serverChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *Buffer)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">client</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> b *Buffer</span><br><span class="line"><span class="comment">// 若缓冲区可用就用它，不可用就分配个新的。</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> b = &lt;-freeList:</span><br><span class="line"><span class="comment">// 获取一个，不做别的。</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// 非空闲，因此分配一个新的。</span></span><br><span class="line">b = <span class="built_in">new</span>(Buffer)</span><br><span class="line">&#125;</span><br><span class="line">load(b)              <span class="comment">// 从网络中读取下一条消息。</span></span><br><span class="line">serverChan &lt;- b   <span class="comment">// 发送至服务器。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端从客服端循环接收消息，并进行处理，再将缓冲区返回给空闲列表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">b := &lt;-serverChan    <span class="comment">// 等待工作。</span></span><br><span class="line">process(b)</span><br><span class="line"><span class="comment">// 若缓冲区有空间就重用它。</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> freeList &lt;- b:</span><br><span class="line"><span class="comment">// 将缓冲区放大空闲列表中，不做别的。</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// 空闲列表已满，保持就好。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端试图从 freeList 中获取缓冲区，若没有缓冲区可用，它将分配一个新的缓冲区。服务器及那个缓冲区 放回 freeList 直到列表已满。此时缓冲区将被丢弃，并被 gc 回收。（select 语句中的 default 子句在没有条件复合时执行，也就意味着 selects 永远不会被阻塞）依靠带缓冲的 channel 和 gc ，构建了一个可溢出的缓冲区的空闲列表。</p><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>错误的类型通常为 error ，这是一个简单的内建接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> interfact&#123;</span><br><span class="line">Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过更丰富的底层模型实现这个接口，这样不但能看见错误，还能提供一些上下文。例如，<code>os.Open</code> 除了返回一个 <code>*os.File</code> 返回值，<code>os.Open</code> 还返回一个 error 值。若该文件被成功打开，error 值就是 nil ，如果除了问题，这个值就是一个 <code>os.PathError</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PathError 记录一个错误以及产生该错误的路径和操作。</span></span><br><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">Op <span class="type">string</span>    <span class="comment">// &quot;open&quot;、&quot;unlink&quot; 等等。</span></span><br><span class="line">Path <span class="type">string</span>  <span class="comment">// 相关联的文件。</span></span><br><span class="line">Err <span class="type">error</span>    <span class="comment">// 由系统调用返回。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.Op + <span class="string">&quot; &quot;</span> + e.Path + <span class="string">&quot;: &quot;</span> + e.Err.Error()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PathError 的 Error 会生成如下错误信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open /etc/passwx: no such file or directory</span><br></pre></td></tr></table></figure><p>这种错误包含了出错的文件名、操作和触发的操作系统错误。</p><p>错误字符串应尽可能地指名它们的来源，例如产生该错误的包名前缀。例如在 image 包中，由于位置格式导致解码错误的字符串为”image：unknown format“</p><p>若调用者关心错误的完整细节，可使用类型选择或者类型断言来查看特定错误，并抽取其细节。 对于 PathErrors，它应该还包含检查内部的 Err 字段以进行可能的错误恢复。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> try := <span class="number">0</span>; try &lt; <span class="number">2</span>; try++ &#123;</span><br><span class="line">file, err = os.Create(filename)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> e, ok := err.(*os.PathError); ok &amp;&amp; e.Err == syscall.ENOSPC &#123;</span><br><span class="line">deleteTempFiles()  <span class="comment">// Recover some space.</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的第二条 if 是另一种类型断言。若它失败， ok 将为 false，而 e 则为 nil. 若它成功，ok 将为 true，这意味着该错误属于 <code>*os.PathError</code> 类型，而 e 能够检测关于该错误的更多信息。</p><h3 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a>Panic</h3><p>Go 提供了内建的 panic 函数，它会产生一个运行时错误并终止程序。该函数接受一个任意类型的实参（一般为字符串），并在程序终止时打印。 它还能表明发生了意料之外的事情，比如从无限循环中退出了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A toy implementation of cube root using Newton&#x27;s method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CubeRoot</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">z := x/<span class="number">3</span>   <span class="comment">// Arbitrary initial value</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1e6</span>; i++ &#123;</span><br><span class="line">prevz := z</span><br><span class="line">z -= (z*z*z-x) / (<span class="number">3</span>*z*z)</span><br><span class="line"><span class="keyword">if</span> veryClose(z, prevz) &#123;</span><br><span class="line"><span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A million iterations has not converged; something is wrong.</span></span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;CubeRoot(%g) did not converge&quot;</span>, x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际的库函数应该避免 panic 。如果问题可以被忽略或解决，最好就是让程序继续运行而不是终止整个程序。</p><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>当 panic 被调用后（包括不明确的运行时错误，例如切片检索越界或类型断言失败），程序将立即终止当前函数的执行，并开始回溯 goroutine 的栈，运行任何 defer 的函数。若回溯到达 goroutine 栈的顶端，程序就会终止。不过我们可以用内建的 recover 函数来重新取回 goroutine 的控制权限并使其恢复正常执行。</p><p>调用 recover 将停止回溯过程，并返回传入 panic 的实参。<strong>由于在回溯时只有被推迟函数中的代码在运行，因此 recover 只能在被推迟的函数中才有效。</strong></p><p>recover 的一个应用就是在服务器中终止失败的 goroutine 而无需杀死其它正在执行 goroutine 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">(workChan &lt;-<span class="keyword">chan</span> *Work)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> work := <span class="keyword">range</span> workChan &#123;</span><br><span class="line"><span class="keyword">go</span> safelyDo(work)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safelyDo</span><span class="params">(work *Work)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;work failed:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">do(work)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，若 <code>do(work)</code> 触发了 panic ，其结果就会被日志记录，而该 goroutine 会被结束而不会干扰到其他的 goroutine 。 我们无需在 defer 的闭包函数中做任何事情， 一切交给 recover 处理。</p><p>由于直接从 defer 函数中调用 recover 时不会返回 nil，因此被推迟的代码能够调用本身使用了 panic 和 recover 的库函数而不会失败。例如在 safelyDo 中，被推迟的函数可能在调用 recover 前先调用日志记录，而日志函数应当不受 panic 状态的代码的影响。</p><p>通过恰当地使用恢复模式，do 函数（及其调用的任何代码）可通过调用 panic 来避免更坏的结果。我们可以利用这种思想来简化复杂软件中的错误处理。下面是简化版的 regexp 包的理想化版本，它会以局部的错误类型调用 panic 来报告解析错误。以下是一个 error 类型的 Error 方法和一个 Compile 函数的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error 是解析错误的类型，它满足 error 接口。</span></span><br><span class="line"><span class="keyword">type</span> Error <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Error)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">string</span>(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error 是 *Regexp 的方法，它通过用一个 Error 触发 Panic 来报告解析错误。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(regexp *Regexp)</span></span> <span class="type">error</span>(err <span class="type">string</span>) &#123;</span><br><span class="line"><span class="built_in">panic</span>(Error(err))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile 返回该正则表达式解析后的表示。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compile</span><span class="params">(str <span class="type">string</span>)</span></span> (regexp *Regexp, err <span class="type">error</span>) &#123;</span><br><span class="line">regexp = <span class="built_in">new</span>(Regexp)</span><br><span class="line"><span class="comment">// doParse will panic if there is a parse error.</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">regexp = <span class="literal">nil</span>    <span class="comment">// 清理返回值。</span></span><br><span class="line">err = e.(Error) <span class="comment">// 若它不是解析错误，将重新触发 Panic。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> regexp.doParse(str), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 若 doParse 触发了 panic  ，recover 块会将返回值设为 nil（defer 的函数能够修改已命名的返回值）。在 err 赋值过程中，通过断言它是否拥有局部类型 Error 。若它没有，类型断言将会失败，此时将会产生运行时的错误，并继续栈的回溯，就像没有被 recover 中断过一样。该检查意味着若发生了一些像索引越界之类的意外，那么即使使用了 panic 和 recover 来处理解析错误，代码仍然会崩溃。</p><p>通过适当的错误处理，error 方法（由于它是个绑定到具体类型的方法，因此即使与内建的 error 类型名字相同也没关系）能让报错解析报告变得更容易，而无需手动处理回溯的栈：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pos == <span class="number">0</span> &#123;</span><br><span class="line">re.<span class="type">error</span>(<span class="string">&quot;&#x27;*&#x27; illegal at start of expression&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管这种模式很有用，但它应当仅在包内使用。Parse 会将其内部的 panic 调用转为 error 值，它并不会向调用者暴露出 panic。这是个值得遵守的良好规则。</p><p>顺便一提，这种重新触发Panic的惯用法会在产生实际错误时改变Panic的值。 然而，不管是原始的还是新的错误都会在崩溃报告中显示，因此问题的根源仍然是可见的。 这种简单的重新触发Panic的模型已经够用了，毕竟只是一次崩溃。 但是如果只想显示原始的值，也可以多写一点代码来进行过滤，然后用原来的 error 再次触发 Panic。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>正向代理、反向代理、CDN</title>
      <link href="/2023/05/09/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81CDN/"/>
      <url>/2023/05/09/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81CDN/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>要理解什么是反向代理，首先要知道什么是正向代理。</p><h2 id="网关-gateway"><a href="#网关-gateway" class="headerlink" title="网关(gateway)"></a>网关(gateway)</h2><p>网关可以看作是一个网络的入口或出口，它连接两个不同的网络。通常，网关是由一个或多个路由器组成的。它的作用是将数据从一个网络传输到另一个网络。当客户端请求访问另一个网络的资源时，网关就会将请求转发到目标服务器。网关可以是一种网络设备或软件。</p><h2 id="正向代理-forward-proxy"><a href="#正向代理-forward-proxy" class="headerlink" title="正向代理(forward proxy)"></a>正向代理(forward proxy)</h2><p>正向代理通常直接称为**代理(proxy)**，无需强调他是正向的。</p><p>在正向代理模式下，客户端通过代理服务器向目标服务器发出请求，而不是直接与目标服务器进行通信。代理服务器接收到客户端的请求后，会将请求转发给目标服务器，然后将目标服务器的响应返回给客户端。</p><p>值得注意的是，客户端是没有办法知道这个代理服务器的地址的。这也就需要你手动配置它。</p><p><strong>那么为什么要使用代理呢？</strong></p><ol><li>隐藏客户端的真实IP地址：正向代理可以屏蔽客户端的真实IP地址，从而保护客户端的隐私和安全。</li><li>访问受限资源：正向代理可以代表客户端访问受限资源，例如某些国家或地区被封锁的网站。</li><li>缓存静态内容：正向代理可以缓存静态内容，例如图片、视频等，从而提高访问速度。</li></ol><p><strong>国家或地区封锁网站的方式：</strong></p><ol><li>DNS污染：这种方式是通过修改国家或地区的DNS服务器的记录，将被封锁的网站域名指向一个错误的IP地址，从而使该网站无法访问。这种方式容易被绕过，用户可以通过修改本地DNS服务器的记录或使用其他公共DNS服务器来访问被封锁的网站。</li><li>IP封锁：这种方式是通过在国家或地区的防火墙上设置规则，禁止所有访问被封锁网站的IP地址。这种方式比DNS污染更难以绕过，但是它可能会影响其他网站的访问，因为被封锁网站可能与其他网站共享IP地址。</li></ol><h2 id="反向代理-reverse-proxy"><a href="#反向代理-reverse-proxy" class="headerlink" title="反向代理(reverse proxy)"></a>反向代理(reverse proxy)</h2><p>反向代理是充当Web服务器网关的代理服务器。当请求发向Web服务器时，将先转到反向代理，由该代理确定是将其路由到Web服务器上还是将其阻止。如果说正向代理是主动配置, 主动走代理, 那么反向代理则是”<strong>被代理</strong>“, 从这点上看, 反向代理有时又称为”<strong>透明代理</strong>“, 也即是浏览器都不知道自己被代理了, 浏览器以为发给它响应的就是最终的网页服务器, 其实不过是个”代理”。</p><p>这意味着，客户端不会和Web服务器进行直接通信。</p><p>通过负载均衡和缓存，还可以保护Web服务器免受攻击，并提供更好的性能。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>代理的位置不同：正向代理是代表客户端向服务器发送请求。反向代理是代表服务器向客户端发送响应。</li><li>核心目的不同：正向代理隐藏客户端，反向代理隐藏服务器。</li></ul><h1 id="反向代理服务器端技术"><a href="#反向代理服务器端技术" class="headerlink" title="反向代理服务器端技术"></a>反向代理服务器端技术</h1><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>高流量的网站通常每分钟处理大量请求，这可能会减慢其系统性能并破坏相应时间。为了确保更好的用户体验和更快的相应，此类高流量网站使用了反向代理。</p><p>假如现在有一组执行相同功能的服务器。使用反向代理，将请求在服务器之间进行分配，从而缩短了相应时间，并且不会使任何服务器工作过度。、</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>一些反向代理可以充当缓存机。如果在一分钟内发送上千个请求相同资源的请求，请求将一遍又一遍地到达服务器，请求相同资源，从而浪费了资源和宝贵的空间。这时一种低效的处理方式。但是，在反向代理的帮助下，首次请求资源时，它将缓存该资源，后续请求将不会终极到服务器，而是从反向代理的缓存中提取所需的资源，是保存静态文件副本的完美工具。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>如果使用反向代理，则请求不会直接到达Web服务器。将有助于保护Web服务器免受已知漏洞的侵害。如果是恶意请求，则代理会拦截该请求并将其阻止。</p><h1 id="CDN-Content-Delivery-Network"><a href="#CDN-Content-Delivery-Network" class="headerlink" title="CDN(Content Delivery Network)"></a>CDN(Content Delivery Network)</h1><p>CDN( Content Delivery Network ，内容分发网络)，就是采用更多的缓存服务器(CDN边缘节点)，布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上。</p><p><strong>具体步骤</strong></p><ol><li>客户端请求资源，根据 url 地址去本地DNS寻求IP地址解析</li><li>本地DNS系统会将域名的解析全交给CDN专用DNS服务器</li><li>CDN专用DNS服务器将CDN的全局负载均衡设备IP地址返回客户端</li><li>客户端向CDN的负载均衡设备发起内容 url 访问请求</li><li>、CDN负载均衡设备根据客户端IP地址，以及客户端请求的内容URL，选择一台客户端所属区域的<strong>缓存服务器</strong>。</li><li>负载均衡设备告诉用户端这台缓存服务器的IP地址，让用户向所选择的缓存服务器发起请求</li><li>客户端向缓存服务器发起请求，缓存服务器响应客户端请求，将用户所需内容传送到客户端</li><li>如果这台缓存服务器上并没有用户想要的内容，那么这台缓存服务器就要网站的<strong>源服务器</strong>请求内容</li><li>源服务器返回内容给缓存服务器，缓存服务器发给客户端，并根据客户端自定义的缓存策略，判断要不要把内容缓存到缓存服务器上</li></ol><p><strong>使用CDN的好处：</strong></p><ol><li>加速网站加载速度：</li><li>提高网站的可用性</li><li>减轻网站的负载压力</li><li>节省带宽费用</li><li>提高安全性</li></ol><h1 id="Nginx实现反向代理"><a href="#Nginx实现反向代理" class="headerlink" title="Nginx实现反向代理"></a>Nginx实现反向代理</h1><p>在Nginx中实现反向代理非常简单。只需要在Nginx配置文件中添加一个<code>proxy_pass</code>指令即可。例如，要将所有<code>/api</code>请求代理到<code>http://localhost:3000</code>，可以使用以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /api &#123;</span><br><span class="line">    proxy_pass &lt;http://localhost:3000&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将使Nginx将所有<code>/api</code>请求代理到<code>http://localhost:3000</code>。在这个例子中，Nginx充当了客户端和服务器之间的中转站，将所有请求代理到真实的服务器上，然后将响应返回给客户端。</p><p>除了<code>proxy_pass</code>指令之外，Nginx还提供了许多其他的反向代理指令，包括：</p><ul><li><code>proxy_set_header</code>：设置HTTP请求头。</li><li><code>proxy_redirect</code>：重定向代理请求。</li><li><code>proxy_cache</code>：缓存代理请求的响应。</li><li><code>proxy_connect_timeout</code>：设置代理连接超时时间。</li></ul><p>通过使用这些指令，可以轻松地配置Nginx作为反向代理服务器，并提供高性能、可扩展的Web应用程序。</p><h1 id="Nginx实现负载均衡"><a href="#Nginx实现负载均衡" class="headerlink" title="Nginx实现负载均衡"></a>Nginx实现负载均衡</h1><p>在Nginx中实现负载均衡非常简单。只需要在Nginx配置文件中添加一个<code>upstream</code>指令即可。例如，要将所有<code>/api</code>请求代理到三个服务器上，可以使用以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        server backend1.example.com;</span><br><span class="line">        server backend2.example.com;</span><br><span class="line">        server backend3.example.com;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  example.com;</span><br><span class="line"></span><br><span class="line">        location /api &#123;</span><br><span class="line">            proxy_pass  &lt;http://backend&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Nginx配置虚拟主机"><a href="#Nginx配置虚拟主机" class="headerlink" title="Nginx配置虚拟主机"></a>Nginx配置虚拟主机</h1><p><strong>什么是虚拟主机？</strong></p><p>虚拟主机是一种特殊的软件技术，它可以将网络上的每一台计算机分成多个虚拟主机，每个虚拟主机可以独立对外提供web服务，这样就可以实现一台主机对外提供多个web服务，每个虚拟主机之间是独立的，互不影响。使用虚拟主机技术，可以将多个网站运行在同一台服务其上。还允许通过不同的域名或IP地址来访问不同的网站，并提供 了更好的网站隔离性和管理性。</p><p><strong>nginx可以实现虚拟主机的配置，nginx支持三种类型的虚拟主机配置:</strong></p><ol><li>基于域名的虚拟主机</li><li>基于IP的虚拟主机</li><li>基于端口的虚拟主机</li></ol><h3 id="基于IP"><a href="#基于IP" class="headerlink" title="基于IP"></a>基于IP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       192.168.1.100:80;</span><br><span class="line">    server_name  example.com;</span><br><span class="line">    root   /var/www/example.com;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用场景：</strong>一台主机绑定多个IP地址</p><p>域名可以相同</p><h3 id="基于域名"><a href="#基于域名" class="headerlink" title="基于域名"></a>基于域名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  example.com;</span><br><span class="line">    root   /var/www/example.com;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  blog.example.com;</span><br><span class="line">    root   /var/www/blog.example.com;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于它们共享同一个 IP 地址和端口号，所以需要使用不同的域名来区分它们。</p><p><strong>应用场景：</strong>外部网站</p><h3 id="基于端口"><a href="#基于端口" class="headerlink" title="基于端口"></a>基于端口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;  # 监听端口 80</span><br><span class="line">        server_name  www.example.com;</span><br><span class="line">        root         /var/www/example.com;</span><br><span class="line">        # 其他配置项</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8080;  # 监听端口 8080</span><br><span class="line">        server_name  www.example.com;</span><br><span class="line">        root         /var/www/another-example.com;</span><br><span class="line">        # 其他配置项</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用场景：</strong>公司内部网站，外部网站的管理后台</p><h1 id="Traefik配合docker使用"><a href="#Traefik配合docker使用" class="headerlink" title="Traefik配合docker使用"></a>Traefik配合docker使用</h1><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><ol><li><p>在 Docker Compose 文件中，配置 Traefik 服务。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">traefik:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">traefik:v2.5</span></span><br><span class="line">    <span class="comment"># enable dash board and use docker as providers</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">--api.insecure=true</span> <span class="string">--providers.docker</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="comment"># The HTTP port</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span>   </span><br><span class="line">      <span class="comment"># The dashboard (enabled by --api.insecure=true)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;443:443&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># So that Traefik can lisent to the Docker events</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/var/run/docker.sock:/var/run/docker.sock:ro&quot;</span></span><br></pre></td></tr></table></figure><p>这里定义了 Traefik 服务，并将其绑定到 80 和 443 端口上。这里 Traefik 使用 docker 作为 <code>providers</code> ，因此需要将其挂载到容器中。</p></li><li><p>Docker Compose 中配置需要代理的服务。下面是一个简单的例子。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">whoami:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">containous/whoami</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.enable=true&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.whoami.rule=Host(`whoami.docker.localhost`)&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.services.whoami.loadbalancer.server.port=80&quot;</span></span><br></pre></td></tr></table></figure><p>​这个例子中，定义了一个名为<code>whoami</code>的服务。还添加了一些标签，以告诉 Traefik 如何将该服务与反向代理路由器和服务联系起来。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">-&quot;traefik.http.routers.whoami.rule=Host(`whoami.docker.localhost`)&quot;</span></span><br></pre></td></tr></table></figure><p>表示将<code>whoami.docker.localhost</code>的所有 请求路由到<code>whoami</code>服务</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">&quot;traefik.http.services.whoami.loadbalancer.server.port=80&quot;</span></span><br></pre></td></tr></table></figure><p>表示将流量负载均衡到<code>whoami</code>服务的 80 端口</p></li></ol><p>​</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Sentinel限流、熔断、降级</title>
      <link href="/2023/05/09/sentinel/"/>
      <url>/2023/05/09/sentinel/</url>
      
        <content type="html"><![CDATA[<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="引入Sentinel依赖"><a href="#引入Sentinel依赖" class="headerlink" title="引入Sentinel依赖"></a>引入Sentinel依赖</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/alibaba/sentinel-golang v1.0.4</span><br></pre></td></tr></table></figure><h2 id="通用配置及初始化"><a href="#通用配置及初始化" class="headerlink" title="通用配置及初始化"></a>通用配置及初始化</h2><p>使用 Sentinel 需要在应用启动时对 Sentinel 运行环境进行相关配置并触发初始化。</p><ul><li><code>InitDefault</code>：从环境变量指定的配置文件以及环境变量中读取相应配置来初始化 Sentinel，若环境变量不存在则使用默认值。</li><li><code>Init(configpath string)</code>：从给定的 YAML 文件中读取相应配置来初始化 Sentinel。</li><li><code>InitWithConfig(configEntity *config.Entity)</code>：用户硬编码配置对象<code>*config.Entity</code>来初始化Sentinel。</li></ul><p>示例代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">sentinel &quot;github.com/alibaba/sentinel-golang/api&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func initSentinel() &#123;</span><br><span class="line">err := sentinel.Init(confPath)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">// 初始化 Sentinel 失败</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须成功调用 Sentinel 初始化函数以后再调用埋点 API 。</p><h2 id="定义资源"><a href="#定义资源" class="headerlink" title="定义资源"></a>定义资源</h2><p><code>资源(sentinel)</code>是sentinel中最核心的概念之一，Sentinel中所有的限流熔断机制都是基于资源生效的，<strong>不同的限流熔断规则互相隔离互不影响</strong>。</p><p>在 Sentinel 中，用户可以灵活的定义资源埋点。资源可以是应用、接口、函数、甚至是一段代码。</p><h3 id="埋点"><a href="#埋点" class="headerlink" title="埋点"></a>埋点</h3><p>用户通过Sentinel api 包里面的接口可以把资源访问包起来，这一步称为”埋点”。每个埋点都有一个资源名称(resource),用于区分不同的资源，并针对资源买点配置流量配置规则。即使没有配置任何规则，资源埋点仍然会产生 metric 统计</p><p>下面示例，将<code>fmt.Println(&quot;hello world&quot;)</code>作为资源</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Entry 方法用于埋点</span></span><br><span class="line">e, b := sentinel.Entry(<span class="string">&quot;some-test&quot;</span>, sentinel.WithTrafficType(base.Inbound))</span><br><span class="line"><span class="keyword">if</span> b != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 熔断 可以从 BlockError 中获得熔断的原因</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 资源被保护起来</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="comment">// 确保最后退出 entry</span></span><br><span class="line">e.Exit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="规则配置"><a href="#规则配置" class="headerlink" title="规则配置"></a>规则配置</h3><h3 id="硬编码方式"><a href="#硬编码方式" class="headerlink" title="硬编码方式"></a>硬编码方式</h3><p>Sentinel 支持原始的硬编码方式加载规则，可以通过各个模块的<code>LoadRule(rules)</code>函数加载规则。以流控规则为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_, err = flow.LoadRules([]*flow.Rule&#123;</span><br><span class="line">&#123;</span><br><span class="line">Resource:               <span class="string">&quot;some-test&quot;</span>,</span><br><span class="line">Threshold:              <span class="number">10</span>,</span><br><span class="line">TokenCalculateStrategy: flow.Direct,</span><br><span class="line">ControlBehavior:        flow.Reject,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 加载规则失败，进行相关处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态数据源"><a href="#动态数据源" class="headerlink" title="动态数据源"></a>动态数据源</h3><p>Sentinel 提供动态数据源接口进行扩展，用户可以通过动态文件、etcd、consul、nacos 等配置中心来动态地配置规则。</p><h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>流量控制(flow control)，其原理是监控<code>资源(Resource)</code>的统计指标，然后根据token计算策略来计算资源的可用token，然后根据流量控制策略对请求进行控制，避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。</p><p>Sentinel 通过定义流控规则来实现对 <code>Resource</code> 的流量控制。在 Sentinel 内部会在加载流控规则时候将每个 flow.Rule 都会被转换成流量控制器(TrafficShapingController)。 每个流量控制器实例都会有自己独立的统计结构，这里统计结构是一个滑动窗口。Sentinel 内部会尽可能复用 Resource 级别的全局滑动窗口，如果流控规则的统计设置没法复用Resource的全局统计结构，那么Sentinel会为流量控制器创建一个全新的私有的滑动窗口，然后通过 flow.StandaloneStatSlot 这个统计Slot(槽)来维护统计指标。</p><h2 id="流控规则"><a href="#流控规则" class="headerlink" title="流控规则"></a>流控规则</h2><p>定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Rule <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// ID represents the unique ID of the rule (optional).</span></span><br><span class="line">ID <span class="type">string</span> <span class="string">`json:&quot;id,omitempty&quot;`</span></span><br><span class="line"><span class="comment">// Resource represents the resource name.</span></span><br><span class="line">Resource               <span class="type">string</span>                 <span class="string">`json:&quot;resource&quot;`</span></span><br><span class="line">TokenCalculateStrategy TokenCalculateStrategy <span class="string">`json:&quot;tokenCalculateStrategy&quot;`</span></span><br><span class="line">ControlBehavior        ControlBehavior        <span class="string">`json:&quot;controlBehavior&quot;`</span></span><br><span class="line"><span class="comment">// Threshold means the threshold during StatIntervalInMs</span></span><br><span class="line"><span class="comment">// If StatIntervalInMs is 1000(1 second), Threshold means QPS</span></span><br><span class="line">Threshold         <span class="type">float64</span>          <span class="string">`json:&quot;threshold&quot;`</span></span><br><span class="line">RelationStrategy  RelationStrategy <span class="string">`json:&quot;relationStrategy&quot;`</span></span><br><span class="line">RefResource       <span class="type">string</span>           <span class="string">`json:&quot;refResource&quot;`</span></span><br><span class="line">MaxQueueingTimeMs <span class="type">uint32</span>           <span class="string">`json:&quot;maxQueueingTimeMs&quot;`</span></span><br><span class="line">WarmUpPeriodSec   <span class="type">uint32</span>           <span class="string">`json:&quot;warmUpPeriodSec&quot;`</span></span><br><span class="line">WarmUpColdFactor  <span class="type">uint32</span>           <span class="string">`json:&quot;warmUpColdFactor&quot;`</span></span><br><span class="line"><span class="comment">// StatIntervalInMs indicates the statistic interval and it&#x27;s the optional setting for flow Rule.</span></span><br><span class="line"><span class="comment">// If user doesn&#x27;t set StatIntervalInMs, that means using default metric statistic of resource.</span></span><br><span class="line"><span class="comment">// If the StatIntervalInMs user specifies can not reuse the global statistic of resource,</span></span><br><span class="line"><span class="comment">// sentinel will generate independent statistic structure for this rule.</span></span><br><span class="line">StatIntervalInMs <span class="type">uint32</span> <span class="string">`json:&quot;statIntervalInMs&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只介绍一些重点，详情看[流控规则](<a href="https://sentinelguard.io/zh-cn/docs/golang/flow-control.html">flow-control | Sentinel (sentinelguard.io)</a>)</p><ul><li><code>Resource</code>：资源名，即规则的作用目标。</li><li><code>TokenCalculateStrategy</code>: 当前流量控制器的Token计算策略。Direct表示直接使用字段 Threshold 作为阈值；WarmUp表示使用预热方式计算Token的阈值。</li><li><code>ControlBehavior</code>: 表示流量控制器的控制策略；Reject表示超过阈值直接拒绝，Throttling表示匀速排队。</li><li><code>Threshold</code>: 表示流控阈值；如果字段 StatIntervalInMs 是1000(也就是1秒)，那么Threshold就表示<code>QPS(Queries Per Second)</code>，流量控制器也就会依据资源的QPS来做流控。</li><li><code>StatIntervalInMs</code>: 规则对应的流量控制器的独立统计结构的统计周期。如果StatIntervalInMs是1000，也就是统计QPS。</li></ul><h2 id="流量控制器的统计结构"><a href="#流量控制器的统计结构" class="headerlink" title="流量控制器的统计结构"></a>流量控制器的统计结构</h2><p> 每个流量控制器都有自己独立的统计结构。流量控制器的统计结构由规则中的<code>StatIntervalInMs</code>字段设置，<code>StatIntervalInMs</code>表示统计结构的统计周期。</p><p>Sentinel 默认会为每个Resource创建一个全局的滑动窗口统计结构，这个全局的统计结构默认是一个间隔为10s,20个格子的滑动窗口，也就是每个统计窗口长度是500ms。</p><p>流量控制器实例会尽可能复用这个Resource级别的全局统计结构，复用逻辑原则是：优先复用Resource级别的全局统计结构，如果不可复用，就重新创建一个独立的滑动窗口统计结构(BucketLeapArray)，具体的逻辑细节如下：</p><ol><li>如果<code>StatIntervalInMs</code>大于全局滑动窗口的间隔(默认10s)，那么将不可复用全局统计结构。Sentinel会给流量控制器创建一个长度是<code>StatIntervalInMs</code>，格子数是1的全新统计结构，这个全新的统计结构由Sentinel内部的<code>StandaloneStatSlot</code>来维护统计。</li><li>如果<code>StatIntervalInMs</code>小于全局滑动窗口的窗口长度(默认是500ms), 那么将不可复用全局统计结构。Sentinel会给流量控制器创建一个长度是<code>StatIntervalInMs</code>，格子数是1的全新统计结构，这个全新的统计结构由Sentinel内部的<code>StandaloneStatSlot</code>来维护统计。</li><li>如果<code>StatIntervalInMs</code>在集合[全局滑动窗口的窗口长度，全局滑动窗口的间隔]之间，首先需要计算格子数：如果<code>StatIntervalInMs</code>可以被全局滑动窗口的窗口长度(默认是500ms)整除，那么格子数就为 <code>StatIntervalInMs</code>&#x2F;<code>GlobalStatisticBucketLengthInMs</code>，如果不可整除，格子数是1。然后会调用 <code>core/base/CheckValidityForReuseStatistic</code>函数来判断当前统计结构间隔和格子数是否可以复用全局统计结构。如果可以复用，就会基于resource级别的全局统计结构<code>ResourceNode</code>创建<code>SlidingWindow</code>，SlidingWindow是一个虚拟结构，SlidingWindow只可读，而且读的数据是通过聚合<code>ResourceNode</code>数据得到的。如果不可复用，就使用统计结构间隔和格子数创建全新的滑动窗口(BucketLeapArray)。</li></ol><h2 id="常见场景的规则配置"><a href="#常见场景的规则配置" class="headerlink" title="常见场景的规则配置"></a>常见场景的规则配置</h2><h3 id="基于QPS对某个资源限流"><a href="#基于QPS对某个资源限流" class="headerlink" title="基于QPS对某个资源限流"></a>基于QPS对某个资源限流</h3><p>基于对某个资源访问的QPS来做流控，这个是非常常见的场景。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">Resource:                <span class="string">&quot;some-test&quot;</span>,</span><br><span class="line">    TokenCalculateStrategy:  flow.Direct, <span class="comment">//可选</span></span><br><span class="line">ControlBehavior:         flow.Reject,  <span class="comment">//可选</span></span><br><span class="line">Threshold:               <span class="number">500</span>,<span class="comment">//表示QPS的阈值</span></span><br><span class="line">    StatIntervalInMs:        <span class="number">1000</span>,   <span class="comment">//必须是1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于一定统计间隔时间来控制总的请求数"><a href="#基于一定统计间隔时间来控制总的请求数" class="headerlink" title="基于一定统计间隔时间来控制总的请求数"></a>基于一定统计间隔时间来控制总的请求数</h3><p>这个场景就是想在一定统计周期内控制请求的总量。比如<code>StatIntervalInMs</code>配置10000，<code>Threshold</code>配置10000，这种配置意思就是控制10s内最大请求数是10000。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">Resource:                <span class="string">&quot;some-test&quot;</span>,</span><br><span class="line">    TokenCalculateStrategy:  flow.Direct,</span><br><span class="line">ControlBehavior:         flow.Reject,</span><br><span class="line">Threshold:               <span class="number">10000</span>,</span><br><span class="line">    StatIntervalInMs:        <span class="number">10000</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>这种流控配置对于脉冲类型的流量抵抗力很弱，有极大潜在风险压垮系统。比如流量表现形式是10s内请求数最大是9800，实际上流量可能是脉冲形式。</p><p>这种大周期的配置其实也有好处，就是能够做到流量的无损，前提是保证系统能够抗住这种周期内的脉冲流量，当然如果流量曲线在秒级别比较平顺，也就不存在脉冲问题，我们是建议统计周期可以稍微调大。</p><h3 id="毫秒级别流控"><a href="#毫秒级别流控" class="headerlink" title="毫秒级别流控"></a>毫秒级别流控</h3><p>针对一些流量曲在毫秒级别波动非常大的场景(类似于脉冲)，建议<code>StatIntervalInMs</code>的配置在毫秒级别，除非特殊场景，建议配置的值为100ms的倍数，比如100，200这种。这种相当于缩小了统计周期，将QPS的周期缩小了10倍，控制周期降低到了100ms。这种配置能够很好的应对脉冲流量，保障系统稳定性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">Resource:                <span class="string">&quot;some-test&quot;</span>,</span><br><span class="line">    TokenCalculateStrategy:  flow.Direct,</span><br><span class="line">ControlBehavior:         flow.Reject,</span><br><span class="line">Threshold:               <span class="number">80</span>,</span><br><span class="line">    StatIntervalInMs:        <span class="number">100</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面限制了100ms的阈值是80，实际QPS大概是800。</p><p>注意：这种配置也是有缺点的，脉冲流量很大可能造成有损(会拒绝很多流量)。</p><h1 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h1><h2 id="Overview-1"><a href="#Overview-1" class="headerlink" title="Overview"></a>Overview</h2><p>在高可用设计中，除了流控外，对分布式系统调用链路中不稳定的资源(比如RPC服务等)进行熔断降级也是保障高可用的重要措施之一。现在的分布式架构中一个服务常常会调用第三方服务，这个第三方服务可能是另外的一个RPC接口、数据库，或者第三方 API 等等。</p><p>然而，除了自身服务外，依赖的外部服务的稳定性是不能绝对保证的。如果依赖的第三方服务出现了不稳定的情况，比如请求的响应时间变长，那么服务自身调用第三方服务的响应时间也会响应变长，也就是<strong>级联效应</strong>，服务自身的线程可能会产生堆积，最终可能耗尽业务自身的线程池，最终服务本身也变得不可用。</p><p>前面描述的问题在分布式链路调用中会产生放大的效果。整个复杂链路中的某一环如果不稳定，就可能会层层级联，最终可能导致整个链路全部挂掉。因此我们需要对不稳定的 <strong>弱依赖服务调用</strong> 进行 <strong>熔断降级</strong>，暂时切断不稳定的服务调用，避免局部不稳定因素导致整个分布式系统的雪崩。</p><p>熔断降级作为保护服务自身的手段，通常在客户端（调用端）进行配置。</p><h2 id="熔断器模型"><a href="#熔断器模型" class="headerlink" title="熔断器模型"></a>熔断器模型</h2><p>Sentinel 熔断降级基于熔断器模式 (circuit breaker pattern) 实现。熔断器内部维护了一个熔断器的状态机，状态机的转换关系如下图所示：</p><p><img src="https://user-images.githubusercontent.com/9434884/82635455-ca075f00-9c32-11ea-9e99-d67518923e0d.png"></p><p>熔断器有三种状态：</p><ol><li>Closed 状态：也是初始状态，该状态下，熔断器会保持闭合，对资源的访问直接通过熔断器的检查。</li><li>Open 状态：断开状态，熔断器处于开启状态，对资源的访问会被切断。熔断器规则中会配置一个熔断超时重试的时间，经过熔断超时重试时长后熔断器会将状态置为 Half-Open 状态，从而进行探测机制。</li><li>Half-Open 状态：半开状态，该状态下除了探测流量，其余对资源的访问也会被切断。探测流量指熔断器处于半开状态时，会周期性的允许一定数目的探测请求通过，如果探测请求能够正常的返回，代表探测成功，此时熔断器会重置状态到 Closed 状态，结束熔断；如果探测失败，则回滚到 Open 状态。</li></ol><p>Sentinel 提供了监听器去监听熔断器状态机的三种状态的转换，方便用户去自定义扩展：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StateChangeListener listens on the circuit breaker state change event.</span></span><br><span class="line"><span class="keyword">type</span> StateChangeListener <span class="keyword">interface</span> &#123;</span><br><span class="line">        <span class="comment">// 熔断器切换到 Closed 状态时候会调用改函数, prev代表切换前的状态，rule表示当前熔断器对应的规则</span></span><br><span class="line">OnTransformToClosed(prev State, rule Rule)</span><br><span class="line">        <span class="comment">// 熔断器切换到 Open 状态时候会调用改函数, prev代表切换前的状态，rule表示当前熔断器对应的规则， snapshot表示触发熔断的值</span></span><br><span class="line">OnTransformToOpen(prev State, rule Rule, snapshot <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">        <span class="comment">// 熔断器切换到 HalfOpen 状态时候会调用改函数, prev代表切换前的状态，rule表示当前熔断器对应的规则</span></span><br><span class="line">OnTransformToHalfOpen(prev State, rule Rule)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用 hook 函数，拿到熔断器每次状态切换的事件，以及熔断器对应的 Rule。</p><p>注意：</p><ul><li>监听器 hook 里面携带的规则是基于 copy 的，也就是用户在监听器里面更改 Rule 不会影响到熔断器。此外这里基于拷贝是有一定性能开销的，用户要尽可能减少无效的监听器注册。</li><li>熔断器监听器的注册和清除是非线程安全的，用户必须要在服务启动时配置 Sentinel 时候就注册对应的监听器，应用运行中禁止更改熔断器状态机的监听器。</li></ul><h2 id="熔断器的设计"><a href="#熔断器的设计" class="headerlink" title="熔断器的设计"></a>熔断器的设计</h2><p>衡量下游服务质量时，常用的指标有：RT(response time)、异常数量以及异常比例等等。</p><p>用户通过设置熔断规则(Rule)来给资源添加熔断器。Sentinel会将每一个熔断规则转换成对应的熔断器，熔断器对用户是不可见的。Sentinel 的每个熔断器都会有自己独立的统计结构。</p><p>熔断器的整体检查逻辑可以用几点来精简概括：</p><ol><li>基于熔断器的状态机来判断对资源是否可以访问；</li><li>对不可访问的资源会有探测机制，探测机制保障了对资源访问的弹性恢复；</li><li>熔断器会在对资源访问的完成态去更新统计，然后基于熔断规则更新熔断器状态机。</li></ol><h2 id="熔断策略"><a href="#熔断策略" class="headerlink" title="熔断策略"></a>熔断策略</h2><p>Sentinel 熔断器的三种熔断策略都支持静默期 (规则中通过MinRequestAmount字段表示)。</p><p>静默期是指一个最小的静默请求数，在一个统计周期内，如果对资源的请求数小于设置的静默数，那么熔断器将不会基于其统计值去更改熔断器的状态。</p><p><strong>为什么设置静默期？</strong></p><p>假设在一个统计周期刚刚开始时候，第 1 个请求碰巧是个慢请求，这个时候这个时候的慢调用比例就会是 100%，很明显是不合理，所以存在一定的巧合性。所以静默期提高了熔断器的精准性以及降低误判可能性。</p><p>Sentinel 支持一下几种熔断策略：</p><ul><li>慢调用比例策略 (SlowRequestRatio)：Sentinel 的熔断器不在静默期，并且慢调用的比例大于设置的阈值，则接下来的熔断周期内对资源的访问会自动地被熔断。该策略下需要设置允许的调用 RT 临界值（即最大的响应时间），对该资源访问的响应时间大于该阈值则统计为慢调用。</li><li>错误比例策略 (ErrorRatio)：Sentinel 的熔断器不在静默期，并且在统计周期内资源请求访问异常的比例大于设定的阈值，则接下来的熔断周期内对资源的访问会自动地被熔断。</li><li>错误计数策略 (ErrorCount)：Sentinel 的熔断器不在静默期，并且在统计周期内资源请求访问异常数大于设定的阈值，则接下来的熔断周期内对资源的访问会自动地被熔断。</li></ul><h2 id="熔断降级的规则"><a href="#熔断降级的规则" class="headerlink" title="熔断降级的规则"></a>熔断降级的规则</h2><p>定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rule encompasses the fields of circuit breaking rule.</span></span><br><span class="line"><span class="keyword">type</span> Rule <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// unique id</span></span><br><span class="line">Id <span class="type">string</span> <span class="string">`json:&quot;id,omitempty&quot;`</span></span><br><span class="line"><span class="comment">// resource name</span></span><br><span class="line">Resource <span class="type">string</span>   <span class="string">`json:&quot;resource&quot;`</span></span><br><span class="line">Strategy Strategy <span class="string">`json:&quot;strategy&quot;`</span></span><br><span class="line"><span class="comment">// RetryTimeoutMs represents recovery timeout (in milliseconds) before the circuit breaker opens.</span></span><br><span class="line"><span class="comment">// During the open period, no requests are permitted until the timeout has elapsed.</span></span><br><span class="line"><span class="comment">// After that, the circuit breaker will transform to half-open state for trying a few &quot;trial&quot; requests.</span></span><br><span class="line">RetryTimeoutMs <span class="type">uint32</span> <span class="string">`json:&quot;retryTimeoutMs&quot;`</span></span><br><span class="line"><span class="comment">// MinRequestAmount represents the minimum number of requests (in an active statistic time span)</span></span><br><span class="line"><span class="comment">// that can trigger circuit breaking.</span></span><br><span class="line">MinRequestAmount <span class="type">uint64</span> <span class="string">`json:&quot;minRequestAmount&quot;`</span></span><br><span class="line"><span class="comment">// StatIntervalMs represents statistic time interval of the internal circuit breaker (in ms).</span></span><br><span class="line">StatIntervalMs <span class="type">uint32</span> <span class="string">`json:&quot;statIntervalMs&quot;`</span></span><br><span class="line"><span class="comment">// MaxAllowedRtMs indicates that any invocation whose response time exceeds this value (in ms)</span></span><br><span class="line"><span class="comment">// will be recorded as a slow request.</span></span><br><span class="line"><span class="comment">// MaxAllowedRtMs only takes effect for SlowRequestRatio strategy</span></span><br><span class="line">MaxAllowedRtMs <span class="type">uint64</span> <span class="string">`json:&quot;maxAllowedRtMs&quot;`</span></span><br><span class="line"><span class="comment">// Threshold represents the threshold of circuit breaker.</span></span><br><span class="line"><span class="comment">// for SlowRequestRatio, it represents the max slow request ratio</span></span><br><span class="line"><span class="comment">// for ErrorRatio, it represents the max error request ratio</span></span><br><span class="line"><span class="comment">// for ErrorCount, it represents the max error request count</span></span><br><span class="line">Threshold <span class="type">float64</span> <span class="string">`json:&quot;threshold&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Id</code>: 表示 Sentinel 规则的全局唯一ID，可选项。</li><li><code>Resource</code>: 熔断器规则生效的埋点资源的名称；</li><li><code>Strategy</code>: 熔断策略，目前支持<code>SlowRequestRatio</code>、<code>ErrorRatio</code>、<code>ErrorCount</code>三种；<ul><li>选择以<strong>慢调用比例</strong> (SlowRequestRatio) 作为阈值，需要设置允许的<strong>最大响应时间</strong>（MaxAllowedRtMs），请求的响应时间大于该值则统计为慢调用。通过 <code>Threshold</code> 字段设置触发熔断的慢调用比例，取值范围为 [0.0, 1.0]。规则配置后，在单位统计时长内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态，若接下来的一个请求响应时间小于设置的最大 RT 则结束熔断，若大于设置的最大 RT 则会再次被熔断。</li><li>选择以<strong>错误比例</strong> (ErrorRatio) 作为阈值，需要设置触发熔断的异常比例（<code>Threshold</code>），取值范围为 [0.0, 1.0]。规则配置后，在单位统计时长内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态，若接下来的一个请求没有错误则结束熔断，否则会再次被熔断。代码中可以通过 <code>api.TraceError(entry, err)</code> 函数来记录 error。</li></ul></li><li><code>RetryTimeoutMs</code>: 即熔断触发后持续的时间（单位为 ms）。资源进入熔断状态后，在配置的熔断时长内，请求都会快速失败。熔断结束后进入探测恢复模式（HALF-OPEN）。</li><li><code>MinRequestAmount</code>: 静默数量，如果当前统计周期内对资源的访问数量小于静默数量，那么熔断器就处于静默期。换言之，也就是触发熔断的最小请求数目，若当前统计周期内的请求数小于此值，即使达到熔断条件规则也不会触发。</li><li><code>StatIntervalMs</code>: 统计的时间窗口长度（单位为 ms）。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>分布式系统中降级：假设存在应用A需要调用应用B的接口(特别是一些对接外部公司或者业务的接口时候)，那么一般用于A调用B的接口时的防护；</li><li>数据库慢调用的防护： 假设应用需要读&#x2F;写数据库，但是该读写SQL存在潜在慢SQL的可能性，那么可以对该读写接口做防护，当接口不稳定时候(存在慢SQL)，那么基于熔断器做降级。</li><li>也可以是应用中任意弱依赖接口做降级防护（即自动降级后不影响业务核心链路）</li></ul><h1 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h1><h2 id="服务降级和服务熔断的区别"><a href="#服务降级和服务熔断的区别" class="headerlink" title="服务降级和服务熔断的区别"></a>服务降级和服务熔断的区别</h2><p>服务熔断和服务降级是在分布式系统中常用的两种容错机制。都是为了提高系统的可用性(availity)和可靠性(reliability)，但他们的实现方式和目的不同。</p><p>服务熔断是一种基于故障检测的<strong>被动</strong>容错机制，它可以在服务出现故障时快速地断开服务调用，以避免故障的扩散，导致不可用性在系统中扩散，从而保护服务的下游应用免受故障的影响。也便于上游服务回复正常。服务熔断由链路上的某个服务引起，并对框架层次进行处理。</p><p>服务降级是一种<strong>主动</strong>的容错机制。它可以在系统出现压力或负载过大的情况下，通过降低服务的功能或性能来保证系统的可用性。当系统负载过高或资源不足时，会关闭一些不必要的服务或削减服务的功能或性能，以保证核心服务的正常运行。服务降级是从整个系统的负荷情况出发和考虑的，并对业务层次进行处理。</p><p><strong>限流</strong>：限制并发的请求访问量，超过阈值则拒绝；</p><p><strong>降级</strong>：服务分优先级，牺牲非核心服务（不可用），保证核心服务稳定；从整体负荷考虑；通常是一个预防措施；</p><p><strong>熔断</strong>：依赖的上游服务故障触发熔断，避免引发本系统崩溃；系统自动执行和恢复</p><h2 id="服务降级的实现"><a href="#服务降级的实现" class="headerlink" title="服务降级的实现"></a>服务降级的实现</h2><ol><li>熔断降级：在系统压力达到一定阈值时，通过熔断机制将请求转发到备用服务或者返回预先设定的默认值，以避免系统崩溃或出现过载。</li><li>限流降级：通过限制并发请求的数量或者每秒请求的速率，来控制系统的负载，从而保证系统的稳定性和可用性。</li><li>异步处理：将某些请求转为异步处理，不影响主流程的执行速度，从而避免因为某些业务需求导致整个系统的性能下降。</li><li>动态降级：通过动态调整系统的服务质量和响应速度来适应系统的负载情况，例如当系统负载过高时，可以将响应速度设置为低速，来减少系统资源的消耗。</li><li>服务优先级降级：对不同的服务设置不同的优先级，当系统负载过高时，优先处理高优先级的服务，降低低优先级服务的响应速度或者降级处理。</li><li>静态降级：预先设置系统的响应速度和服务质量等级，当系统负载过高时，直接按照预设的降级级别进行处理，例如直接返回默认值或者错误码等。</li></ol><p>至少在现在看来，服务降级更像是一个更抽象的的概念，他包含一部分限流或者熔断的措施。但是考量的尺度要比限流和熔断要大（限流和熔断更像是为了保护某一个细分的业务，而降级则是从系统的性能上考虑）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gorm</title>
      <link href="/2023/03/30/Gorm/"/>
      <url>/2023/03/30/Gorm/</url>
      
        <content type="html"><![CDATA[<h1 id="Gorm"><a href="#Gorm" class="headerlink" title="Gorm"></a>Gorm</h1><ul><li><strong>gorm</strong></li></ul><p>GORM时Go编程语言的一种流行的（对象关系映射）库，它可以帮助开发人员使用面向对象的方式来操作关系型数据库。</p><p>GORM提供了许多方便的功能，例如<strong>自动迁移</strong>，<strong>查询构建器</strong>，<strong>预加载</strong>，<strong>事务处理</strong>等等，它还支持多种数据库，如MySQL，PostgreSQL，SQLite等</p><ul><li><strong>orm</strong></li></ul><p>ORM是一种技术，可以将<strong>关系型数据库</strong>的表和行<strong>映射</strong>为编程语言中的<strong>对象</strong>和<strong>属性</strong>，使开发人员可以使用<strong>面向对象</strong>的方式来处理数据，而不需要直接使用SQL语句。使用ORM库可以<strong>简化</strong>数据库操作的代码，提高开发效率，并且可以减少开发人员需要了解数据库的细节和语法的负担。</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="声明模型"><a href="#声明模型" class="headerlink" title="声明模型"></a>声明模型</h2><h3 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h3><p>模型时标准的<code>struct</code>，由Go的基本数据类型、实现了<code>Scanner</code>和<code>Valuer</code>接口的自定义类型及其指针或别名组成。</p><p>例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID           <span class="type">uint</span></span><br><span class="line">  Name         <span class="type">string</span></span><br><span class="line">  Email        *<span class="type">string</span></span><br><span class="line">  Age          <span class="type">uint8</span></span><br><span class="line">  Birthday     *time.Time</span><br><span class="line">  MemberNumber sql.NullString</span><br><span class="line">  ActivatedAt  sql.NullTime</span><br><span class="line">  CreatedAt    time.Time</span><br><span class="line">  UpdatedAt    time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><p>GORM倾向于约定优于配置，默认情况下，GORM使用<code>ID</code>作为主键，使用结构体名的<code>蛇形复数</code>作为表明，字段名的蛇形作为列名，并使用<code>CreateAt</code>、<code>UpdateAt</code>字段追踪创建、更新时间。</p><p>如果遵循GORM的约定，就可以少写配置、代码。如果约定不符合实际需要，可以手动配置它们。</p><h3 id="gorm-Model"><a href="#gorm-Model" class="headerlink" title="gorm.Model"></a>gorm.Model</h3><p>GORM定义一个<code>gorm.Model</code>结构体，其包括字段<code>ID</code>、<code>CreateAt</code>、<code>UpdateAt</code>、<code>DeleteAt</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gorm.Model 的定义</span></span><br><span class="line"><span class="keyword">type</span> Model <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">uint</span>           <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">  CreatedAt time.Time</span><br><span class="line">  UpdatedAt time.Time</span><br><span class="line">  DeletedAt gorm.DeletedAt <span class="string">`gorm:&quot;index&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于一个预先配置好的结构体，可以将这个结构体嵌入到自己的结构体中，以包含这几个字段。</p><h3 id="高级选项"><a href="#高级选项" class="headerlink" title="高级选项"></a>高级选项</h3><h4 id="字段级权限控制"><a href="#字段级权限控制" class="headerlink" title="字段级权限控制"></a>字段级权限控制</h4><p>可导出字段在使用GORM进行CRUD时，拥有全部的权限，此外，GORM允许用标签控制字段级别的权限。可以设置一个字段的权限是只读、只写、只创建、只更新或者被忽略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;&lt;-:create&quot;`</span> <span class="comment">// 允许读和创建</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;&lt;-:update&quot;`</span> <span class="comment">// 允许读和更新</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;&lt;-&quot;`</span>        <span class="comment">// 允许读和写（创建和更新）</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;&lt;-:false&quot;`</span>  <span class="comment">// 允许读，禁止写</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-&gt;&quot;`</span>        <span class="comment">// 只读（除非有自定义配置，否则禁止写）</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-&gt;;&lt;-:create&quot;`</span> <span class="comment">// 允许读和写</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-&gt;:false;&lt;-:create&quot;`</span> <span class="comment">// 仅创建（禁止从 db 读）</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-&quot;`</span>  <span class="comment">// 通过 struct 读写会忽略该字段</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-:all&quot;`</span>        <span class="comment">// 通过 struct 读写、迁移会忽略该字段</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-:migration&quot;`</span>  <span class="comment">// 通过 struct 迁移会忽略该字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong> 这时候使用GORM Migrator 创建表时，不会创建被忽略的字段</p><h4 id="创建更新时间"><a href="#创建更新时间" class="headerlink" title="创建更新时间"></a>创建更新时间</h4><p>GORM约定使用<code>CreateAt</code>、<code>UpdateAt</code>追踪创建&#x2F;更新时间。如果定义了这种字段，GORM在创建、更新时会自动填充当前的时间。</p><p>要使用不同名称的字段，可以设置<code>autoCreateTime</code>、<code>autoUpdateTime</code>标签</p><p>如果想要保存时间戳，而不是time，只需要将<code>time.Time</code>修改为<code>int/int64</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type User struct &#123;</span><br><span class="line">  CreatedAt time.Time // 在创建时，如果该字段值为零值，则使用当前时间填充</span><br><span class="line">  UpdatedAt int       // 在创建时该字段值为零值或者在更新时，使用当前时间戳秒数填充</span><br><span class="line">  Updated   int64 `gorm:&quot;autoUpdateTime:nano&quot;` // 使用时间戳纳秒数填充更新时间</span><br><span class="line">  Updated   int64 `gorm:&quot;autoUpdateTime:milli&quot;` // 使用时间戳毫秒数填充更新时间</span><br><span class="line">  Created   int64 `gorm:&quot;autoCreateTime&quot;`      // 使用时间戳秒数填充创建时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="嵌入结构体"><a href="#嵌入结构体" class="headerlink" title="嵌入结构体"></a>嵌入结构体</h4><p>对于<strong>匿名字段</strong>，GORM 会将其字段包含在父结构体中，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">uint</span>           <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">  CreatedAt time.Time</span><br><span class="line">  UpdatedAt time.Time</span><br><span class="line">  DeletedAt gorm.DeletedAt <span class="string">`gorm:&quot;index&quot;`</span></span><br><span class="line">  Name strin</span><br></pre></td></tr></table></figure><p>对于<strong>正常的结构体</strong>字段，你也可以通过标签 <code>embedded</code> 将其嵌入，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Author <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="type">string</span></span><br><span class="line">    Email <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Blog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID      <span class="type">int</span></span><br><span class="line">  Author  Author <span class="string">`gorm:&quot;embedded&quot;`</span></span><br><span class="line">  Upvotes <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">type</span> Blog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID    <span class="type">int64</span></span><br><span class="line">  Name  <span class="type">string</span></span><br><span class="line">  Email <span class="type">string</span></span><br><span class="line">  Upvotes  <span class="type">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且，您可以使用标签 <code>embeddedPrefix</code> 来为 db 中的字段名<strong>添加前缀</strong>，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Blog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID      <span class="type">int</span></span><br><span class="line">  Author  Author <span class="string">`gorm:&quot;embedded;embeddedPrefix:author_&quot;`</span></span><br><span class="line">  Upvotes <span class="type">int32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">type</span> Blog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID          <span class="type">int64</span></span><br><span class="line">  AuthorName <span class="type">string</span></span><br><span class="line">  AuthorEmail <span class="type">string</span></span><br><span class="line">  Upvotes     <span class="type">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字段标签"><a href="#字段标签" class="headerlink" title="字段标签"></a>字段标签</h4><p>声明 model 时，tag 是可选的，GORM 支持以下 tag： tag 名大小写不敏感，但建议使用 <code>camelCase</code> 风格</p><table><thead><tr><th>标签名</th><th>说明</th></tr></thead><tbody><tr><td>column</td><td>指定db列名</td></tr><tr><td>type</td><td>列数据类型，推荐使用兼容性好的通用类型，例如：所有数据库都支持 bool、int、uint、float、string、time、bytes 并且可以和其他标签一起使用，例如：<code>not null</code>、<code>size</code>, <code>autoIncrement</code>… 像 <code>varbinary(8)</code> 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：<code>MEDIUMINT UNSIGNED not NULL</code>,<code>AUTO_INCREMENT</code></td></tr><tr><td>serializer</td><td>指定将数据序列化或反序列化到数据库中的序列化器，如：<code>serializer:json/gob/unixtime</code></td></tr><tr><td>size</td><td>定义列数据的大小或长度，例如<code>size:256</code></td></tr><tr><td>primaryKey</td><td>将列定义为主键</td></tr><tr><td>unique</td><td>将列定义为唯一键</td></tr><tr><td>precision</td><td>指定列的精度</td></tr><tr><td>scale</td><td>指定列的大小</td></tr><tr><td>not null</td><td>指定列为NOT NULL</td></tr><tr><td>autoIncrement</td><td>指定列为自动增长</td></tr><tr><td>autoIncrementIncrement</td><td>自动步长，控制连续记录之间的间隔</td></tr><tr><td>embedded</td><td>嵌套字段</td></tr><tr><td>embeddedPrefix</td><td>嵌入字段的列名前缀</td></tr><tr><td>autoCreateTime</td><td>创建时追踪当前的时间，对于<code>int</code>字段，它会追踪时间戳秒数，<code>nano/milli</code>追踪纳秒、毫秒时间戳，例如：<code>qutoCreateTIme:nano</code></td></tr><tr><td>index</td><td>根据参数创建索引，多个字段使用相同的名称则创建复合索引</td></tr><tr><td>uniqueIndex</td><td>与<code>index</code>相同，但创建的是唯一索引</td></tr><tr><td>check</td><td>创建检查约束，例如<code>check:age&gt;13</code></td></tr><tr><td>&lt;-</td><td>设置字段写入的权限，<code>&lt;-:create</code>只创建、<code>&lt;-:update</code>只更新、<code>&lt;-:false</code>无写入权限、<code>&lt;-</code>创建和更新权限</td></tr><tr><td>-&gt;</td><td>设置字段读的权限，<code>-&gt;:false</code>无读权限</td></tr><tr><td>-</td><td>忽略该字段，<code>-</code>表示无读写，<code>-:migration</code>表示无迁移权限，<code>-:all</code>表示无读写迁移权限</td></tr><tr><td>comment</td><td>迁移时为字段添加注释</td></tr></tbody></table><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>GORM官方支持对的数据库类型有:MySQL，PostgreSQL，SQLite，SQL Server 和 TiDB</p><h3 id="MySQL连接"><a href="#MySQL连接" class="headerlink" title="MySQL连接"></a>MySQL连接</h3><ul><li><p><strong>官方的驱动</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line">  <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  dsn := <span class="string">&quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">  db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>自定义驱动</strong></p><p>可以通过<code>DriverName</code>选项自定义MySQL驱动，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  _ <span class="string">&quot;example.com/my_mysql_driver&quot;</span></span><br><span class="line">  <span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line">  <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">db, err := gorm.Open(mysql.New(mysql.Config&#123;</span><br><span class="line">  DriverName: <span class="string">&quot;my_mysql_driver&quot;</span>,</span><br><span class="line">  DSN: <span class="string">&quot;gorm:gorm@tcp(localhost:9910)/gorm?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>, <span class="comment">// data source name, 详情参考：https://github.com/go-sql-driver/mysql#dsn-data-source-name</span></span><br><span class="line">&#125;), &amp;gorm.Config&#123;&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>现有的数据库连接</strong></p><p>可以通过一个现有的数据化连接来初始化<code>*gorm.DB</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">  <span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line">  <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">sqlDB, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;mydb_dsn&quot;</span>)</span><br><span class="line">gormDB, err := gorm.Open(mysql.New(mysql.Config&#123;</span><br><span class="line">  Conn: sqlDB,</span><br><span class="line">&#125;), &amp;gorm.Config&#123;&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>GORM使用<code>database/sql</code>维护连接池</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sqlDB, err := db.DB()</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetMaxIdleConns sets the maximum number of connections in the idle connection pool.</span></span><br><span class="line">sqlDB.SetMaxIdleConns(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetMaxOpenConns sets the maximum number of open connections to the database.</span></span><br><span class="line">sqlDB.SetMaxOpenConns(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetConnMaxLifetime sets the maximum amount of time a connection may be reused.</span></span><br><span class="line">sqlDB.SetConnMaxLifetime(time.Hour)</span><br></pre></td></tr></table></figure><h1 id="CRUD接口"><a href="#CRUD接口" class="headerlink" title="CRUD接口"></a>CRUD接口</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="创建记录"><a href="#创建记录" class="headerlink" title="创建记录"></a>创建记录</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>, Age: <span class="number">18</span>, Birthday: time.Now()&#125;</span><br><span class="line"></span><br><span class="line">result := db.Create(&amp;user) <span class="comment">// 通过数据的指针来创建</span></span><br><span class="line"></span><br><span class="line">user.ID             <span class="comment">// 返回插入数据的主键</span></span><br><span class="line">result.Error        <span class="comment">// 返回 error</span></span><br><span class="line">result.RowsAffected <span class="comment">// 返回插入记录的条数</span></span><br></pre></td></tr></table></figure><h3 id="用指定的字段创建记录"><a href="#用指定的字段创建记录" class="headerlink" title="用指定的字段创建记录"></a>用指定的字段创建记录</h3><p>创建记录并更新给出的字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;CreatedAt&quot;</span>).Create(&amp;user)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`,`age`,`created_at`) VALUES (&quot;jinzhu&quot;, 18, &quot;2020-07-04 11:05:21.775&quot;)</span></span><br></pre></td></tr></table></figure><p>创建一个记录且一同忽略传递给略去的字段值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Omit(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;CreatedAt&quot;</span>).Create(&amp;user)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`birthday`,`updated_at`) VALUES (&quot;2020-01-01 00:00:00.000&quot;, &quot;2020-07-04 11:05:21.775&quot;)</span></span><br></pre></td></tr></table></figure><h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><p>将一个<code>slice</code>传递给<code>Create</code>方法，GORM将生成单独一条SQL语句来插入所有数据，并回填主键的值，狗子方法也会被的调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;Name: <span class="string">&quot;jinzhu1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu2&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu3&quot;</span>&#125;&#125;</span><br><span class="line">db.Create(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> users &#123;</span><br><span class="line">  user.ID <span class="comment">// 1,2,3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>CreateInBatches</code>分批创建时，你可以指定每批的数量，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;name: <span class="string">&quot;jinzhu_1&quot;</span>&#125;, ...., &#123;Name: <span class="string">&quot;jinzhu_10000&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数量为 100</span></span><br><span class="line">db.CreateInBatches(users, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h3 id="创建钩子"><a href="#创建钩子" class="headerlink" title="创建钩子"></a>创建钩子</h3><p>GORM允许用户定义的钩子有<code>BeforeSave</code>、<code>BeforeCreate</code>、<code>AfterSave</code>、<code>AfterCreate</code>创建记录时将调用这些钩子方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> BeforeCreate(tx *gorm.DB) (err <span class="type">error</span>) &#123;</span><br><span class="line">  u.UUID = uuid.New()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> u.Role == <span class="string">&quot;admin&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;invalid role&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要跳过<code>钩子</code>方法，您可以使用<code>SkipHools</code>会话模式例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DB.Session(&amp;gorm.Session&#123;SkipHooks: <span class="literal">true</span>&#125;).Create(&amp;user)</span><br><span class="line"></span><br><span class="line">DB.Session(&amp;gorm.Session&#123;SkipHooks: <span class="literal">true</span>&#125;).Create(&amp;users)</span><br><span class="line"></span><br><span class="line">DB.Session(&amp;gorm.Session&#123;SkipHooks: <span class="literal">true</span>&#125;).CreateInBatches(users, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h3 id="根据map创建"><a href="#根据map创建" class="headerlink" title="根据map创建"></a>根据map创建</h3><p>GORM 支持根据 <code>map[string]interface&#123;&#125;</code> 和 <code>[]map[string]interface&#123;&#125;&#123;&#125;</code> 创建记录，例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.Model(&amp;User&#123;&#125;).Create(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// batch insert from `&amp;[]map[string]interface&#123;&#125;&#123;&#125;`</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Create(&amp;[]<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu_1&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">18</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu_2&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">20</span>&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>注意</strong> 根据map创建记录时，association不会被调用，且主键也不会自动填充</p><h3 id="使用SQL表达式、Context-Valuer创建记录"><a href="#使用SQL表达式、Context-Valuer创建记录" class="headerlink" title="使用SQL表达式、Context Valuer创建记录"></a>使用SQL表达式、Context Valuer创建记录</h3><p>GORM允许使用SQL表达式插入数据，有两种方法实现这个目标。根据<code>map[string]interface&#123;&#125;</code>或自定义数据类型创建，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 map 创建记录</span></span><br><span class="line">db.Model(User&#123;&#125;).Create(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Location&quot;</span>: clause.Expr&#123;SQL: <span class="string">&quot;ST_PointFromText(?)&quot;</span>, Vars: []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;POINT(100 100)&quot;</span>&#125;&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`,`location`) VALUES (&quot;jinzhu&quot;,ST_PointFromText(&quot;POINT(100 100)&quot;));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过自定义类型创建记录</span></span><br><span class="line"><span class="keyword">type</span> Location <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scan 方法实现了 sql.Scanner 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(loc *Location)</span></span> Scan(v <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// Scan a value into struct from database driver</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(loc Location)</span></span> GormDataType() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;geometry&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(loc Location)</span></span> GormValue(ctx context.Context, db *gorm.DB) clause.Expr &#123;</span><br><span class="line">  <span class="keyword">return</span> clause.Expr&#123;</span><br><span class="line">    SQL:  <span class="string">&quot;ST_PointFromText(?)&quot;</span>,</span><br><span class="line">    Vars: []<span class="keyword">interface</span>&#123;&#125;&#123;fmt.Sprintf(<span class="string">&quot;POINT(%d %d)&quot;</span>, loc.X, loc.Y)&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name     <span class="type">string</span></span><br><span class="line">  Location Location</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Create(&amp;User&#123;</span><br><span class="line">  Name:     <span class="string">&quot;jinzhu&quot;</span>,</span><br><span class="line">  Location: Location&#123;X: <span class="number">100</span>, Y: <span class="number">100</span>&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`,`location`) VALUES (&quot;jinzhu&quot;,ST_PointFromText(&quot;POINT(100 100)&quot;))</span></span><br></pre></td></tr></table></figure><h3 id="高级选项-1"><a href="#高级选项-1" class="headerlink" title="高级选项"></a>高级选项</h3><h4 id="关联创建"><a href="#关联创建" class="headerlink" title="关联创建"></a>关联创建</h4><p>创建关联数据时，如果关联值是非零值，这些关联会被upsert，且它们的<code>hook</code>方法也会被调用</p><p>gorm默认使用第一个非空字段作为条件进行查询</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CreditCard <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Number   <span class="type">string</span></span><br><span class="line">  UserID   <span class="type">uint</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name       <span class="type">string</span></span><br><span class="line">  CreditCard CreditCard</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Create(&amp;User&#123;</span><br><span class="line">  Name: <span class="string">&quot;jinzhu&quot;</span>,</span><br><span class="line">  CreditCard: CreditCard&#123;Number: <span class="string">&quot;411111111111&quot;</span>&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// INSERT INTO `users` ...</span></span><br><span class="line"><span class="comment">// INSERT INTO `credit_cards` ...</span></span><br></pre></td></tr></table></figure><p>也可以通过<code>select</code>、<code>omit</code>跳过关联保存，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.Omit(<span class="string">&quot;CreditCard&quot;</span>).Create(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳过所有关联</span></span><br><span class="line">db.Omit(clause.Associations).Create(&amp;user)</span><br></pre></td></tr></table></figure><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>可以通过标签<code>default</code>为字段定义默认值，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">int64</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;default:galeone&quot;`</span></span><br><span class="line">  Age  <span class="type">int64</span>  <span class="string">`gorm:&quot;default:18&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入记录到数据库时，默认值会被用于填充值为零值的字段</p><p><strong>注意</strong> 对于声明了默认值的字段，像<code>0</code>、<code>&#39;&#39;</code>、<code>false</code>等零值不会被保存到数据库。需要使用指针类型或Scanner&#x2F;Valuer来避免这个问题，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age  *<span class="type">int</span>           <span class="string">`gorm:&quot;default:18&quot;`</span></span><br><span class="line">  Active sql.NullBool <span class="string">`gorm:&quot;default:true&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong> 若要数据库有默认、虚拟&#x2F;生成的值，你必须为字段设置 <code>default</code> 标签。若要在迁移时跳过默认值定义，你可以使用 <code>default:(-)</code>，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">string</span> <span class="string">`gorm:&quot;default:uuid_generate_v3()&quot;`</span> <span class="comment">// db func</span></span><br><span class="line">  FirstName <span class="type">string</span></span><br><span class="line">  LastName  <span class="type">string</span></span><br><span class="line">  Age       <span class="type">uint8</span></span><br><span class="line">  FullName  <span class="type">string</span> <span class="string">`gorm:&quot;-&gt;;type:GENERATED ALWAYS AS (concat(firstname,&#x27; &#x27;,lastname));default:(-);&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用虚拟&#x2F;生成的值时，可能需要禁用它的创建、更新权限</p><h4 id="Upsert及冲突"><a href="#Upsert及冲突" class="headerlink" title="*Upsert及冲突"></a>*Upsert及冲突</h4><p>GORM为不同数据库提供了兼容的Upsert支持</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;gorm.io/gorm/clause&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Do nothing on conflict</span></span><br><span class="line">db.Clauses(clause.OnConflict&#123;DoNothing: <span class="literal">true</span>&#125;).Create(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update columns to default value on `id` conflict</span></span><br><span class="line">db.Clauses(clause.OnConflict&#123;</span><br><span class="line">  Columns:   []clause.Column&#123;&#123;Name: <span class="string">&quot;id&quot;</span>&#125;&#125;,</span><br><span class="line">  DoUpdates: clause.Assignments(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>&#125;),</span><br><span class="line">&#125;).Create(&amp;users)</span><br><span class="line"><span class="comment">// MERGE INTO &quot;users&quot; USING *** WHEN NOT MATCHED THEN INSERT *** WHEN MATCHED THEN UPDATE SET ***; SQL Server</span></span><br><span class="line"><span class="comment">// INSERT INTO `users` *** ON DUPLICATE KEY UPDATE ***; MySQL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use SQL expression</span></span><br><span class="line">db.Clauses(clause.OnConflict&#123;</span><br><span class="line">  Columns:   []clause.Column&#123;&#123;Name: <span class="string">&quot;id&quot;</span>&#125;&#125;,</span><br><span class="line">  DoUpdates: clause.Assignments(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;count&quot;</span>: gorm.Expr(<span class="string">&quot;GREATEST(count, VALUES(count))&quot;</span>)&#125;),</span><br><span class="line">&#125;).Create(&amp;users)</span><br><span class="line"><span class="comment">// INSERT INTO `users` *** ON DUPLICATE KEY UPDATE `count`=GREATEST(count, VALUES(count));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update columns to new value on `id` conflict</span></span><br><span class="line">db.Clauses(clause.OnConflict&#123;</span><br><span class="line">  Columns:   []clause.Column&#123;&#123;Name: <span class="string">&quot;id&quot;</span>&#125;&#125;,</span><br><span class="line">  DoUpdates: clause.AssignmentColumns([]<span class="type">string</span>&#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>&#125;),</span><br><span class="line">&#125;).Create(&amp;users)</span><br><span class="line"><span class="comment">// MERGE INTO &quot;users&quot; USING *** WHEN NOT MATCHED THEN INSERT *** WHEN MATCHED THEN UPDATE SET &quot;name&quot;=&quot;excluded&quot;.&quot;name&quot;; SQL Server</span></span><br><span class="line"><span class="comment">// INSERT INTO &quot;users&quot; *** ON CONFLICT (&quot;id&quot;) DO UPDATE SET &quot;name&quot;=&quot;excluded&quot;.&quot;name&quot;, &quot;age&quot;=&quot;excluded&quot;.&quot;age&quot;; PostgreSQL</span></span><br><span class="line"><span class="comment">// INSERT INTO `users` *** ON DUPLICATE KEY UPDATE `name`=VALUES(name),`age`=VALUES(age); MySQL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update all columns to new value on conflict except primary keys and those columns having default values from sql func</span></span><br><span class="line">db.Clauses(clause.OnConflict&#123;</span><br><span class="line">  UpdateAll: <span class="literal">true</span>,</span><br><span class="line">&#125;).Create(&amp;users)</span><br><span class="line"><span class="comment">// INSERT INTO &quot;users&quot; *** ON CONFLICT (&quot;id&quot;) DO UPDATE SET &quot;name&quot;=&quot;excluded&quot;.&quot;name&quot;, &quot;age&quot;=&quot;excluded&quot;.&quot;age&quot;, ...;</span></span><br><span class="line"><span class="comment">// INSERT INTO `users` *** ON DUPLICATE KEY UPDATE `name`=VALUES(name),`age`=VALUES(age), ...; MySQL</span></span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="检索单个对象"><a href="#检索单个对象" class="headerlink" title="检索单个对象"></a>检索单个对象</h3><p>GORM提供了<code>First</code>、<code>Take</code>、<code>Last</code>方法，以便从数据库中检索单个对象。当查询数据库时它添加了<code>LIMIT 1</code>条件，且没有找到记录时，会返回<code>ErrRecordNotFound</code>错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取第一条记录（主键升序）</span></span><br><span class="line">db.First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一条记录，没有指定排序字段</span></span><br><span class="line">db.Take(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最后一条记录（主键降序）</span></span><br><span class="line">db.Last(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY id DESC LIMIT 1;</span></span><br><span class="line"></span><br><span class="line">result := db.First(&amp;user)</span><br><span class="line">result.RowsAffected <span class="comment">// 返回找到的记录数</span></span><br><span class="line">result.Error        <span class="comment">// returns error or nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 ErrRecordNotFound 错误</span></span><br><span class="line">errors.Is(result.Error, gorm.ErrRecordNotFound)</span><br></pre></td></tr></table></figure><p>如果想要避免<code>ErrRecordNotFound</code>错误，可以使用<code>Find</code>，比如<code>db.Limit(1).Find(&amp;user)</code>，<code>Find</code>方法可以接受struct和slice的数据。</p><p>对单个对象使用<code>Find</code>而不带limit，<code>db.Find(&amp;user)</code>将会查询整个表并且只返回第一个对象，这是<strong>性能不高且不确定的</strong>。</p><p><code>Last</code>和<code>First</code>方法会根据主键 顺序获取第一条或最后一条记录。只有当一个结构体指针被传递给这个方法或者使用<code>db.model</code>指定一个模型。当相关的模型没有指定主键时，会按照第一个字段进行排序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user User</span><br><span class="line"><span class="keyword">var</span> users []User</span><br><span class="line"></span><br><span class="line"><span class="comment">// works because destination struct is passed in</span></span><br><span class="line">db.First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM `users` ORDER BY `users`.`id` LIMIT 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// works because model is specified using `db.Model()`</span></span><br><span class="line">result := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line">db.Model(&amp;User&#123;&#125;).First(&amp;result)</span><br><span class="line"><span class="comment">// SELECT * FROM `users` ORDER BY `users`.`id` LIMIT 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// doesn&#x27;t work</span></span><br><span class="line">result := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).First(&amp;result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// works with Take</span></span><br><span class="line">result := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Take(&amp;result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// no primary key defined, results will be ordered by first field (i.e., `Code`)</span></span><br><span class="line"><span class="keyword">type</span> Language <span class="keyword">struct</span> &#123;</span><br><span class="line">  Code <span class="type">string</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">db.First(&amp;Language&#123;&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM `languages` ORDER BY `languages`.`code` LIMIT 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="根据主键检索"><a href="#根据主键检索" class="headerlink" title="根据主键检索"></a>根据主键检索</h4><p>如果主键是一个<code>number</code>时，对象可以通过主键检索。如果使用<code>strings</code>，要小心SQL注入。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.First(&amp;user, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.First(&amp;user, <span class="string">&quot;10&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Find(&amp;users, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id IN (1,2,3);</span></span><br></pre></td></tr></table></figure><p>如果主键是一个字符串（比如uuid）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.First(&amp;user, <span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;1b74413f-f3b8-409f-ac47-e8c062e3472a&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = &quot;1b74413f-f3b8-409f-ac47-e8c062e3472a&quot;;</span></span><br></pre></td></tr></table></figure><p>当目标对象有一个主键值时，将使用主键构建查询条件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = User&#123;ID: <span class="number">10</span>&#125;</span><br><span class="line">db.First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result User</span><br><span class="line">db.Model(User&#123;ID: <span class="number">10</span>&#125;).First(&amp;result)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br></pre></td></tr></table></figure><h3 id="检索全部对象"><a href="#检索全部对象" class="headerlink" title="检索全部对象"></a><strong>检索全部对象</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get all records</span></span><br><span class="line">result := db.Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users;</span></span><br><span class="line"></span><br><span class="line">result.RowsAffected <span class="comment">// returns found records count, equals `len(users)`</span></span><br><span class="line">result.Error        <span class="comment">// returns error</span></span><br></pre></td></tr></table></figure><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><h4 id="String条件"><a href="#String条件" class="headerlink" title="String条件"></a>String条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get first matched record</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get all matched records</span></span><br><span class="line">db.Where(<span class="string">&quot;name &lt;&gt; ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name &lt;&gt; &#x27;jinzhu&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IN</span></span><br><span class="line">db.Where(<span class="string">&quot;name IN ?&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name IN (&#x27;jinzhu&#x27;,&#x27;jinzhu 2&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LIKE</span></span><br><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jin%&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name LIKE &#x27;%jin%&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AND</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ? AND age &gt;= ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;22&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; AND age &gt;= 22;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Time</span></span><br><span class="line">db.Where(<span class="string">&quot;updated_at &gt; ?&quot;</span>, lastWeek).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE updated_at &gt; &#x27;2000-01-01 00:00:00&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BETWEEN</span></span><br><span class="line">db.Where(<span class="string">&quot;created_at BETWEEN ? AND ?&quot;</span>, lastWeek, today).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE created_at BETWEEN &#x27;2000-01-01 00:00:00&#x27; AND &#x27;2000-01-08 00:00:00&#x27;;</span></span><br></pre></td></tr></table></figure><p>如果对象的主键已经设置了，那么条件查询不会覆盖主键的值而将它作为一个<code>and</code>条件，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = User&#123;ID: <span class="number">10</span>&#125;</span><br><span class="line">db.Where(<span class="string">&quot;id = ?&quot;</span>, <span class="number">20</span>).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10 and id = 20 ORDER BY id ASC LIMIT 1</span></span><br></pre></td></tr></table></figure><p>查询会返回一个<code>error not found</code>的错误。所以使用条件查询时最好把对象的主键值设为<code>nil</code>。</p><h4 id="Struct-amp-Map-条件"><a href="#Struct-amp-Map-条件" class="headerlink" title="Struct &amp; Map 条件"></a>Struct &amp; Map 条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">20</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20 ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Where(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Slice of primary keys</span></span><br><span class="line">db.Where([]<span class="type">int64</span>&#123;<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id IN (20, 21, 22);</span></span><br></pre></td></tr></table></figure><p>当使用<code>Struct</code>查询时，GORM只会使用非零的字段作为查询的条件。</p><p>如果想在查询条件使用零值，可以使用map，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">0</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 0;</span></span><br></pre></td></tr></table></figure><h4 id="指定结构体查询字段"><a href="#指定结构体查询字段" class="headerlink" title="指定结构体查询字段"></a>指定结构体查询字段</h4><p>当使用结构体查询时，可以通过传递结构体字段名或数据库中列名给<code>where()</code>，指定结构体中特定的值作为查询条件，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 0;</span></span><br><span class="line"></span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;Age&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 0;</span></span><br></pre></td></tr></table></figure><h4 id="内联条件"><a href="#内联条件" class="headerlink" title="内联条件"></a>内联条件</h4><p>查询条件能被内联到<code>First</code>或<code>Find</code></p><p>和<code>where</code>的作用类似</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get by primary key if it were a non-integer type</span></span><br><span class="line">db.First(&amp;user, <span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;string_primary_key&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = &#x27;string_primary_key&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Plain SQL</span></span><br><span class="line">db.Find(&amp;user, <span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot;;</span></span><br><span class="line"></span><br><span class="line">db.Find(&amp;users, <span class="string">&quot;name &lt;&gt; ? AND age &gt; ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; AND age &gt; 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Find(&amp;users, User&#123;Age: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Find(&amp;users, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 20;</span></span><br></pre></td></tr></table></figure><h4 id="Not条件"><a href="#Not条件" class="headerlink" title="Not条件"></a>Not条件</h4><p>和<code>where</code>的作用类似</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db.Not(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE NOT name = &quot;jinzhu&quot; ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Not In</span></span><br><span class="line">db.Not(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name NOT IN (&quot;jinzhu&quot;, &quot;jinzhu 2&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Not(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">18</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; AND age &lt;&gt; 18 ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Not In slice of primary keys</span></span><br><span class="line">db.Not([]<span class="type">int64</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id NOT IN (1,2,3) ORDER BY id LIMIT 1;</span></span><br></pre></td></tr></table></figure><h4 id="Or条件"><a href="#Or条件" class="headerlink" title="Or条件"></a>Or条件</h4><p>和<code>where</code>的作用类似</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;admin&quot;</span>).Or(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;super_admin&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE role = &#x27;admin&#x27; OR role = &#x27;super_admin&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Where(<span class="string">&quot;name = &#x27;jinzhu&#x27;&quot;</span>).Or(User&#123;Name: <span class="string">&quot;jinzhu 2&quot;</span>, Age: <span class="number">18</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; OR (name = &#x27;jinzhu 2&#x27; AND age = 18);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Where(<span class="string">&quot;name = &#x27;jinzhu&#x27;&quot;</span>).Or(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu 2&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; OR (name = &#x27;jinzhu 2&#x27; AND age = 18);</span></span><br></pre></td></tr></table></figure><h3 id="选择特定字段"><a href="#选择特定字段" class="headerlink" title="选择特定字段"></a>选择特定字段</h3><p><code>Select</code>方法可以指定想要从数据库中获得的字段</p><p>如果不适用<code>Select</code>方法，GORM默认选择全部字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.Select(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT name, age FROM users;</span></span><br><span class="line"></span><br><span class="line">db.Select([]<span class="type">string</span>&#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT name, age FROM users;</span></span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;COALESCE(age,?)&quot;</span>, <span class="number">42</span>).Rows()</span><br><span class="line"><span class="comment">// SELECT COALESCE(age,&#x27;42&#x27;) FROM users;</span></span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><code>Order</code>方法可以指定排序的规则</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.Order(<span class="string">&quot;age desc, name&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY age desc, name;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiple orders</span></span><br><span class="line">db.Order(<span class="string">&quot;age desc&quot;</span>).Order(<span class="string">&quot;name&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY age desc, name;</span></span><br><span class="line"></span><br><span class="line">db.Clauses(clause.OrderBy&#123;</span><br><span class="line">  Expression: clause.Expr&#123;SQL: <span class="string">&quot;FIELD(id,?)&quot;</span>, Vars: []<span class="keyword">interface</span>&#123;&#125;&#123;[]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;&#125;, WithoutParentheses: <span class="literal">true</span>&#125;,</span><br><span class="line">&#125;).Find(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY FIELD(id,1,2,3)</span></span><br></pre></td></tr></table></figure><h3 id="Limit-amp-Offset"><a href="#Limit-amp-Offset" class="headerlink" title="Limit &amp; Offset"></a>Limit &amp; Offset</h3><p><code>Limit</code>方法可以指定一次能获得的最大记录数</p><p><code>offset</code>方法可以指定返回记录前跳过的的记录条数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">db.Limit(<span class="number">3</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users LIMIT 3;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cancel limit condition with -1</span></span><br><span class="line">db.Limit(<span class="number">10</span>).Find(&amp;users1).Limit(<span class="number">-1</span>).Find(&amp;users2)</span><br><span class="line"><span class="comment">// SELECT * FROM users LIMIT 10; (users1)</span></span><br><span class="line"><span class="comment">// SELECT * FROM users; (users2)</span></span><br><span class="line"></span><br><span class="line">db.Offset(<span class="number">3</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users OFFSET 3;</span></span><br><span class="line"></span><br><span class="line">db.Limit(<span class="number">10</span>).Offset(<span class="number">5</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users OFFSET 5 LIMIT 10;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cancel offset condition with -1</span></span><br><span class="line">db.Offset(<span class="number">10</span>).Find(&amp;users1).Offset(<span class="number">-1</span>).Find(&amp;users2)</span><br><span class="line"><span class="comment">// SELECT * FROM users OFFSET 10; (users1)</span></span><br><span class="line"><span class="comment">// SELECT * FROM users; (users2)</span></span><br></pre></td></tr></table></figure><h3 id="Group-By-amp-Having"><a href="#Group-By-amp-Having" class="headerlink" title="Group By &amp; Having"></a>Group By &amp; Having</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">  Date  time.Time</span><br><span class="line">  Total <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Select(<span class="string">&quot;name, sum(age) as total&quot;</span>).Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;group%&quot;</span>).Group(<span class="string">&quot;name&quot;</span>).First(&amp;result)</span><br><span class="line"><span class="comment">// SELECT name, sum(age) as total FROM `users` WHERE name LIKE &quot;group%&quot; GROUP BY `name` LIMIT 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Select(<span class="string">&quot;name, sum(age) as total&quot;</span>).Group(<span class="string">&quot;name&quot;</span>).Having(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;group&quot;</span>).Find(&amp;result)</span><br><span class="line"><span class="comment">// SELECT name, sum(age) as total FROM `users` GROUP BY `name` HAVING name = &quot;group&quot;</span></span><br><span class="line"></span><br><span class="line">rows, err := db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;date(created_at) as date, sum(amount) as total&quot;</span>).Group(<span class="string">&quot;date(created_at)&quot;</span>).Rows()</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rows, err := db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;date(created_at) as date, sum(amount) as total&quot;</span>).Group(<span class="string">&quot;date(created_at)&quot;</span>).Having(<span class="string">&quot;sum(amount) &gt; ?&quot;</span>, <span class="number">100</span>).Rows()</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">  Date  time.Time</span><br><span class="line">  Total <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line">db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;date(created_at) as date, sum(amount) as total&quot;</span>).Group(<span class="string">&quot;date(created_at)&quot;</span>).Having(<span class="string">&quot;sum(amount) &gt; ?&quot;</span>, <span class="number">100</span>).Scan(&amp;results)</span><br></pre></td></tr></table></figure><h3 id="Distinct"><a href="#Distinct" class="headerlink" title="Distinct"></a>Distinct</h3><p>这里，<code>DISTINCT</code> 关键字用于去除查询结果集中 <code>name</code>和<code>age</code> 字段中的重复值。如果 <code>users</code> 表中有多个相同的 <code>name</code>或<code>age</code> 类型，则只返回其中一个。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Distinct(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>).Order(<span class="string">&quot;name, age desc&quot;</span>).Find(&amp;results)</span><br></pre></td></tr></table></figure><h3 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h3><h2 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h2><h3 id="智能选择字段"><a href="#智能选择字段" class="headerlink" title="智能选择字段"></a>智能选择字段</h3><p>GORM允许通过<code>Select</code>方法选择特定的字段，如果在应用程序中经常使用此功能，你也可以定义一个较小对的结构体，以实现调用API时自动选择特定的字段，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID     <span class="type">uint</span></span><br><span class="line">  Name   <span class="type">string</span></span><br><span class="line">  Age    <span class="type">int</span></span><br><span class="line">  Gender <span class="type">string</span></span><br><span class="line">  <span class="comment">// 假设后面还有几百个字段...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> APIUser <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">uint</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询时会自动选择 `id`, `name` 字段</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Limit(<span class="number">10</span>).Find(&amp;APIUser&#123;&#125;)</span><br><span class="line"><span class="comment">// SELECT `id`, `name` FROM `users` LIMIT 10</span></span><br></pre></td></tr></table></figure><h3 id="Locking（FOR-UPDATE）"><a href="#Locking（FOR-UPDATE）" class="headerlink" title="Locking（FOR UPDATE）"></a>Locking（FOR UPDATE）</h3><p>GORM支持多种类型的锁，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db.Clauses(clause.Locking&#123;Strength: <span class="string">&quot;UPDATE&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM `users` FOR UPDATE</span></span><br><span class="line"></span><br><span class="line">db.Clauses(clause.Locking&#123;</span><br><span class="line">  Strength: <span class="string">&quot;SHARE&quot;</span>,</span><br><span class="line">  Table: clause.Table&#123;Name: clause.CurrentTable&#125;,</span><br><span class="line">&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM `users` FOR SHARE OF `users`</span></span><br><span class="line"></span><br><span class="line">db.Clauses(clause.Locking&#123;</span><br><span class="line">  Strength: <span class="string">&quot;UPDATE&quot;</span>,</span><br><span class="line">  Options: <span class="string">&quot;NOWAIT&quot;</span>,</span><br><span class="line">&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM `users` FOR UPDATE NOWAIT</span></span><br></pre></td></tr></table></figure><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>子查询可以嵌套在查询中，GORM允许在使用<code>*gorm.DB</code>对象作为参数时生成子查询</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;amount &gt; (?)&quot;</span>, db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;AVG(amount)&quot;</span>)).Find(&amp;orders)</span><br><span class="line"><span class="comment">// SELECT * FROM &quot;orders&quot; WHERE amount &gt; (SELECT AVG(amount) FROM &quot;orders&quot;);</span></span><br><span class="line"></span><br><span class="line">subQuery := db.Select(<span class="string">&quot;AVG(age)&quot;</span>).Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;name%&quot;</span>).Table(<span class="string">&quot;users&quot;</span>)</span><br><span class="line">db.Select(<span class="string">&quot;AVG(age) as avgage&quot;</span>).Group(<span class="string">&quot;name&quot;</span>).Having(<span class="string">&quot;AVG(age) &gt; (?)&quot;</span>, subQuery).Find(&amp;results)</span><br><span class="line"><span class="comment">// SELECT AVG(age) as avgage FROM `users` GROUP BY `name` HAVING AVG(age) &gt; (SELECT AVG(age) FROM `users` WHERE name LIKE &quot;name%&quot;)</span></span><br></pre></td></tr></table></figure><h3 id="From子查询"><a href="#From子查询" class="headerlink" title="From子查询"></a>From子查询</h3><p>GORM允许在<code>Table</code>方法中通过<code>FROM</code>子句使用子查询，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.Table(<span class="string">&quot;(?) as u&quot;</span>, db.Model(&amp;User&#123;&#125;).Select(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>)).Where(<span class="string">&quot;age = ?&quot;</span>, <span class="number">18</span>).Find(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM (SELECT `name`,`age` FROM `users`) as u WHERE `age` = 18</span></span><br><span class="line"></span><br><span class="line">subQuery1 := db.Model(&amp;User&#123;&#125;).Select(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">subQuery2 := db.Model(&amp;Pet&#123;&#125;).Select(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">db.Table(<span class="string">&quot;(?) as u, (?) as p&quot;</span>, subQuery1, subQuery2).Find(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM (SELECT `name` FROM `users`) as u, (SELECT `name` FROM `pets`) as p</span></span><br></pre></td></tr></table></figure><h3 id="Group条件"><a href="#Group条件" class="headerlink" title="Group条件"></a>Group条件</h3><p>使用Group条件可以编写复杂的SQL</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.Where(</span><br><span class="line">    db.Where(<span class="string">&quot;pizza = ?&quot;</span>, <span class="string">&quot;pepperoni&quot;</span>).Where(db.Where(<span class="string">&quot;size = ?&quot;</span>, <span class="string">&quot;small&quot;</span>).Or(<span class="string">&quot;size = ?&quot;</span>, <span class="string">&quot;medium&quot;</span>)),</span><br><span class="line">).Or(</span><br><span class="line">    db.Where(<span class="string">&quot;pizza = ?&quot;</span>, <span class="string">&quot;hawaiian&quot;</span>).Where(<span class="string">&quot;size = ?&quot;</span>, <span class="string">&quot;xlarge&quot;</span>),</span><br><span class="line">).Find(&amp;Pizza&#123;&#125;).Statement</span><br><span class="line"></span><br><span class="line"><span class="comment">// SELECT * FROM `pizzas` WHERE (pizza = &quot;pepperoni&quot; AND (size = &quot;small&quot; OR size = &quot;medium&quot;)) OR (pizza = &quot;hawaiian&quot; AND size = &quot;xlarge&quot;）</span></span><br></pre></td></tr></table></figure><h3 id="带多个列的In查询"><a href="#带多个列的In查询" class="headerlink" title="带多个列的In查询"></a>带多个列的In查询</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;(name, age, role) IN ?&quot;</span>, [][]<span class="keyword">interface</span>&#123;&#125;&#123;&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="number">18</span>, <span class="string">&quot;admin&quot;</span>&#125;, &#123;<span class="string">&quot;jinzhu2&quot;</span>, <span class="number">19</span>, <span class="string">&quot;user&quot;</span>&#125;&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE (name, age, role) IN ((&quot;jinzhu&quot;, 18, &quot;admin&quot;), (&quot;jinzhu 2&quot;, 19, &quot;user&quot;));</span></span><br></pre></td></tr></table></figure><h3 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h3><p>GORM支持<code>sql.NamedArg</code>和<code>map[string]interface&#123;&#125;&#123;&#125;</code>形式的命名参数，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;name1 = @name OR name2 = @name&quot;</span>, sql.Named(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>)).Find(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM `users` WHERE name1 = &quot;jinzhu&quot; OR name2 = &quot;jinzhu&quot;</span></span><br><span class="line"></span><br><span class="line">db.Where(<span class="string">&quot;name1 = @name OR name2 = @name&quot;</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM `users` WHERE name1 = &quot;jinzhu&quot; OR name2 = &quot;jinzhu&quot; ORDER BY `users`.`id` LIMIT 1</span></span><br></pre></td></tr></table></figure><h3 id="Find至Map"><a href="#Find至Map" class="headerlink" title="Find至Map"></a>Find至Map</h3><p>GORM允许扫描结果至<code>map[string]interface()</code>或<code>[]map[string]interface&#123;&#125;</code>，此时要指定<code>Model</code>或<code>Table</code>，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line">db.Model(&amp;User&#123;&#125;).First(&amp;result, <span class="string">&quot;id = ?&quot;</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> results []<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Find(&amp;results)</span><br></pre></td></tr></table></figure><h3 id="FirstOrInit"><a href="#FirstOrInit" class="headerlink" title="FirstOrInit"></a>FirstOrInit</h3><p>获取第一条匹配的记录，或者根据给定的条件初始化一个实例（<strong>仅支持 sturct 和 map 条件</strong>）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未找到 user，则根据给定的条件初始化一条记录</span></span><br><span class="line">db.FirstOrInit(&amp;user, User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// user -&gt; User&#123;Name: &quot;non_existing&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到了 `name` = `jinzhu` 的 user</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">// user -&gt; User&#123;ID: 111, Name: &quot;Jinzhu&quot;, Age: 18&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到了 `name` = `jinzhu` 的 user</span></span><br><span class="line">db.FirstOrInit(&amp;user, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// user -&gt; User&#123;ID: 111, Name: &quot;Jinzhu&quot;, Age: 18&#125;</span></span><br></pre></td></tr></table></figure><p>如果没有找到记录，可以使用包含更多的属性的结构体初始化user，<code>Attrs</code>不会用于生成查询SQL</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未找到 user，则根据给定的条件以及 Attrs 初始化 user</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;).Attrs(User&#123;Age: <span class="number">20</span>&#125;).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM USERS WHERE name = &#x27;non_existing&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"><span class="comment">// user -&gt; User&#123;Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 未找到 user，则根据给定的条件以及 Attrs 初始化 user</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;).Attrs(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM USERS WHERE name = &#x27;non_existing&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"><span class="comment">// user -&gt; User&#123;Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到了 `name` = `jinzhu` 的 user，则忽略 Attrs</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>&#125;).Attrs(User&#123;Age: <span class="number">20</span>&#125;).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM USERS WHERE name = jinzhu&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"><span class="comment">// user -&gt; User&#123;ID: 111, Name: &quot;Jinzhu&quot;, Age: 18&#125;</span></span><br></pre></td></tr></table></figure><p>不管是否找到记录，<code>Assign</code> 都会将属性赋值给 struct，但这些属性不会被用于生成查询 SQL，也<strong>不会被保存到数据库</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未找到 user，根据条件和 Assign 属性初始化 struct</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;).Assign(User&#123;Age: <span class="number">20</span>&#125;).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">// user -&gt; User&#123;Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到 `name` = `jinzhu` 的记录，依然会更新 Assign 相关的属性</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>&#125;).Assign(User&#123;Age: <span class="number">20</span>&#125;).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM USERS WHERE name = jinzhu&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"><span class="comment">// user -&gt; User&#123;ID: 111, Name: &quot;Jinzhu&quot;, Age: 20&#125;</span></span><br></pre></td></tr></table></figure><h3 id="FirstOrCreate"><a href="#FirstOrCreate" class="headerlink" title="FirstOrCreate"></a>FirstOrCreate</h3><p>获取匹配的第一条记录或者根据给定条件创建一条新纪录（仅 struct, map 条件有效），<code>RowsAffected</code> 返回<strong>创建、更新</strong>的记录数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未找到 User，根据给定条件创建一条新纪录</span></span><br><span class="line">result := db.FirstOrCreate(&amp;user, User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// INSERT INTO &quot;users&quot; (name) VALUES (&quot;non_existing&quot;);</span></span><br><span class="line"><span class="comment">// user -&gt; User&#123;ID: 112, Name: &quot;non_existing&quot;&#125;</span></span><br><span class="line"><span class="comment">// result.RowsAffected // =&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到 `name` = `jinzhu` 的 User</span></span><br><span class="line">result := db.Where(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">// user -&gt; User&#123;ID: 111, Name: &quot;jinzhu&quot;, &quot;Age&quot;: 18&#125;</span></span><br><span class="line"><span class="comment">// result.RowsAffected // =&gt; 0</span></span><br></pre></td></tr></table></figure><p>如果没有找到记录，可以使用包含更多的属性的结构体创建记录，<code>Attrs</code> 不会被用于生成查询 SQL </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未找到 user，根据条件和 Attrs 属性创建记录</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;).Attrs(User&#123;Age: <span class="number">20</span>&#125;).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;non_existing&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"><span class="comment">// INSERT INTO &quot;users&quot; (name, age) VALUES (&quot;non_existing&quot;, 20);</span></span><br><span class="line"><span class="comment">// user -&gt; User&#123;ID: 112, Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到了 `name` = `jinzhu` 的 user，则忽略 Attrs</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).Attrs(User&#123;Age: <span class="number">20</span>&#125;).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"><span class="comment">// user -&gt; User&#123;ID: 111, Name: &quot;jinzhu&quot;, Age: 18&#125;</span></span><br></pre></td></tr></table></figure><p>不管是否找到记录，<code>Assign</code> 都会将属性赋值给 struct，并将<strong>结果写回数据库</strong>（update）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未找到 user，根据条件和 Assign 属性创建记录</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;non_existing&quot;</span>&#125;).Assign(User&#123;Age: <span class="number">20</span>&#125;).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;non_existing&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"><span class="comment">// INSERT INTO &quot;users&quot; (name, age) VALUES (&quot;non_existing&quot;, 20);</span></span><br><span class="line"><span class="comment">// user -&gt; User&#123;ID: 112, Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到了 `name` = `jinzhu` 的 user，依然会根据 Assign 更新记录</span></span><br><span class="line">db.Where(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).Assign(User&#123;Age: <span class="number">20</span>&#125;).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"><span class="comment">// UPDATE users SET age=20 WHERE id = 111;</span></span><br><span class="line"><span class="comment">// user -&gt; User&#123;ID: 111, Name: &quot;jinzhu&quot;, Age: 20&#125;</span></span><br></pre></td></tr></table></figure><h3 id="优化器、索引提示"><a href="#优化器、索引提示" class="headerlink" title="优化器、索引提示"></a>优化器、索引提示</h3><p>优化器提示用于控制查询优化器选择某个查询执行计划，GORM 通过 <code>gorm.io/hints</code> 提供支持，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;gorm.io/hints&quot;</span></span><br><span class="line"></span><br><span class="line">db.Clauses(hints.New(<span class="string">&quot;MAX_EXECUTION_TIME(10000)&quot;</span>)).Find(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// SELECT * /*+ MAX_EXECUTION_TIME(10000) */ FROM `users`</span></span><br></pre></td></tr></table></figure><p>索引提示允许传递索引提示到数据库，以防查询计划器出现混乱。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;gorm.io/hints&quot;</span></span><br><span class="line"></span><br><span class="line">db.Clauses(hints.UseIndex(<span class="string">&quot;idx_user_name&quot;</span>)).Find(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM `users` USE INDEX (`idx_user_name`)</span></span><br><span class="line"></span><br><span class="line">db.Clauses(hints.ForceIndex(<span class="string">&quot;idx_user_name&quot;</span>, <span class="string">&quot;idx_user_id&quot;</span>).ForJoin()).Find(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM `users` FORCE INDEX FOR JOIN (`idx_user_name`,`idx_user_id`)&quot;</span></span><br></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>GORM支持通过行进行迭代</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rows, err := db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Rows()</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">  <span class="keyword">var</span> user User</span><br><span class="line">  <span class="comment">// ScanRows 方法用于将一行记录扫描至结构体</span></span><br><span class="line">  db.ScanRows(rows, &amp;user)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 业务逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FindInBatches"><a href="#FindInBatches" class="headerlink" title="FindInBatches"></a>FindInBatches</h3><p>用于批量查询并处理记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次批量处理 100 条</span></span><br><span class="line">result := db.Where(<span class="string">&quot;processed = ?&quot;</span>, <span class="literal">false</span>).FindInBatches(&amp;results, <span class="number">100</span>, <span class="function"><span class="keyword">func</span><span class="params">(tx *gorm.DB, batch <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> _, result := <span class="keyword">range</span> results &#123;</span><br><span class="line">    <span class="comment">// 批量处理找到的记录</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tx.Save(&amp;results)</span><br><span class="line"></span><br><span class="line">  tx.RowsAffected <span class="comment">// 本次批量操作影响的记录数</span></span><br><span class="line"></span><br><span class="line">  batch <span class="comment">// Batch 1, 2, 3</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果返回错误会终止后续批量操作</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">result.Error <span class="comment">// returned error</span></span><br><span class="line">result.RowsAffected <span class="comment">// 整个批量操作影响的记录数</span></span><br></pre></td></tr></table></figure><h3 id="查询钩子"><a href="#查询钩子" class="headerlink" title="查询钩子"></a>查询钩子</h3><p>对于查询操作，GORM支持<code>AfterFind</code>钩子，查询记录后会被调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> AfterFind(tx *gorm.DB) (err <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> u.Role == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    u.Role = <span class="string">&quot;user&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pluck"><a href="#Pluck" class="headerlink" title="Pluck"></a>Pluck</h3><p>Pluck用于从数据库查询单个列，并将结果扫描到切片。如果想要查询多列，应该使用<code>Select</code>和<code>Scan</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ages []<span class="type">int64</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Pluck(<span class="string">&quot;age&quot;</span>, &amp;ages)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names []<span class="type">string</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Pluck(<span class="string">&quot;name&quot;</span>, &amp;names)</span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;deleted_users&quot;</span>).Pluck(<span class="string">&quot;name&quot;</span>, &amp;names)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Distinct Pluck</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Distinct().Pluck(<span class="string">&quot;Name&quot;</span>, &amp;names)</span><br><span class="line"><span class="comment">// SELECT DISTINCT `name` FROM `users`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 超过一列的查询，应该使用 `Scan` 或者 `Find`，例如：</span></span><br><span class="line">db.Select(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>).Scan(&amp;users)</span><br><span class="line">db.Select(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>).Find(&amp;users)</span><br></pre></td></tr></table></figure><h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><p><code>scope</code>允许指定常用的查询，可以在调用方法时引用这些查询</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AmountGreaterThan1000</span><span class="params">(db *gorm.DB)</span></span> *gorm.DB &#123;</span><br><span class="line">  <span class="keyword">return</span> db.Where(<span class="string">&quot;amount &gt; ?&quot;</span>, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PaidWithCreditCard</span><span class="params">(db *gorm.DB)</span></span> *gorm.DB &#123;</span><br><span class="line">  <span class="keyword">return</span> db.Where(<span class="string">&quot;pay_mode_sign = ?&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PaidWithCod</span><span class="params">(db *gorm.DB)</span></span> *gorm.DB &#123;</span><br><span class="line">  <span class="keyword">return</span> db.Where(<span class="string">&quot;pay_mode_sign = ?&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OrderStatus</span><span class="params">(status []<span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span> <span class="params">(db *gorm.DB)</span></span> *gorm.DB &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">(db *gorm.DB)</span></span> *gorm.DB &#123;</span><br><span class="line">    <span class="keyword">return</span> db.Where(<span class="string">&quot;status IN (?)&quot;</span>, status)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Scopes(AmountGreaterThan1000, PaidWithCreditCard).Find(&amp;orders)</span><br><span class="line"><span class="comment">// 查找所有金额大于 1000 的信用卡订单</span></span><br><span class="line"></span><br><span class="line">db.Scopes(AmountGreaterThan1000, PaidWithCod).Find(&amp;orders)</span><br><span class="line"><span class="comment">// 查找所有金额大于 1000 的货到付款订单</span></span><br><span class="line"></span><br><span class="line">db.Scopes(AmountGreaterThan1000, OrderStatus([]<span class="type">string</span>&#123;<span class="string">&quot;paid&quot;</span>, <span class="string">&quot;shipped&quot;</span>&#125;)).Find(&amp;orders)</span><br><span class="line"><span class="comment">// 查找所有金额大于 1000 且已付款或已发货的订单</span></span><br></pre></td></tr></table></figure><h3 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h3><p>Count用于获取匹配的记录数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count <span class="type">int64</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Or(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">// SELECT count(1) FROM users WHERE name = &#x27;jinzhu&#x27; OR name = &#x27;jinzhu 2&#x27;</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">// SELECT count(1) FROM users WHERE name = &#x27;jinzhu&#x27;; (count)</span></span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;deleted_users&quot;</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">// SELECT count(1) FROM deleted_users;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Count with Distinct</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Distinct(<span class="string">&quot;name&quot;</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">// SELECT COUNT(DISTINCT(`name`)) FROM `users`</span></span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;deleted_users&quot;</span>).Select(<span class="string">&quot;count(distinct(name))&quot;</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">// SELECT count(distinct(name)) FROM deleted_users</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Count with Group</span></span><br><span class="line">users := []User&#123;</span><br><span class="line">  &#123;Name: <span class="string">&quot;name1&quot;</span>&#125;,</span><br><span class="line">  &#123;Name: <span class="string">&quot;name2&quot;</span>&#125;,</span><br><span class="line">  &#123;Name: <span class="string">&quot;name3&quot;</span>&#125;,</span><br><span class="line">  &#123;Name: <span class="string">&quot;name3&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Group(<span class="string">&quot;name&quot;</span>).Count(&amp;count)</span><br><span class="line">count <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="保存所有字段"><a href="#保存所有字段" class="headerlink" title="保存所有字段"></a>保存所有字段</h3><p><code>Save</code>会保存所有字段，即使字段是零值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.First(&amp;user)</span><br><span class="line"></span><br><span class="line">user.Name = <span class="string">&quot;jinzhu 2&quot;</span></span><br><span class="line">user.Age = <span class="number">100</span></span><br><span class="line">db.Save(&amp;user)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;jinzhu 2&#x27;, age=100, birthday=&#x27;2016-01-01&#x27;, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br></pre></td></tr></table></figure><p>如果要保存的值中不包含主键，会执行<code>Create</code>操作</p><p>如果包含主键就执行<code>Update</code>操作（所有字段的update）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Save(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">100</span>&#125;)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`,`age`,`birthday`,`update_at`) VALUES (&quot;jinzhu&quot;,100,&quot;0000-00-00 00:00:00&quot;,&quot;0000-00-00 00:00:00&quot;)</span></span><br><span class="line"></span><br><span class="line">db.Save(&amp;User&#123;ID: <span class="number">1</span>, Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">100</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE `users` SET `name`=&quot;jinzhu&quot;,`age`=100,`birthday`=&quot;0000-00-00 00:00:00&quot;,`update_at`=&quot;0000-00-00 00:00:00&quot; WHERE `id` = 1</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong> 使用<code>Save</code>时不要使用<code>Model</code></p><h3 id="更新单列-Update"><a href="#更新单列-Update" class="headerlink" title="更新单列(Update)"></a>更新单列(Update)</h3><p>当使用<code>Update</code>更新单列时，需要至少一个条件，否则会报错<code>ErrMissingWhereClause</code></p><p>当使用<code>Model</code>方法时，如果要保存的值中包含主键，那么这个主键将会作为条件，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update with conditions</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE active=true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// User&#x27;s ID is `111`:</span></span><br><span class="line">db.Model(&amp;user).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update with conditions and model value</span></span><br><span class="line">db.Model(&amp;user).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111 AND active=true;</span></span><br></pre></td></tr></table></figure><h3 id="更新多列-Updates"><a href="#更新多列-Updates" class="headerlink" title="更新多列(Updates)"></a>更新多列(Updates)</h3><p>可以使用<code>struct</code>或者<code>map[string]interface&#123;&#125;</code>来进行<code>updates</code>操作，当使用<code>struct</code>更新时，默认只更新非零值，如果要更新零值，需要使用<code>map</code>或者用<code>Select</code>来指定</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update attributes with `struct`, will only update non-zero fields</span></span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>, Active: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update attributes with `map`</span></span><br><span class="line">db.Model(&amp;user).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18, active=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br></pre></td></tr></table></figure><h3 id="更新选定字段"><a href="#更新选定字段" class="headerlink" title="更新选定字段"></a>更新选定字段</h3><p><code>Update</code>操作可以使用<code>Select</code>、<code>Omit</code>来选择或忽略指定字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Select with Map</span></span><br><span class="line"><span class="comment">// User&#x27;s ID is `111`:</span></span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;name&quot;</span>).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).Omit(<span class="string">&quot;name&quot;</span>).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET age=18, active=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Select with Struct (select zero value fields)</span></span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;new_name&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;new_name&#x27;, age=0 WHERE id=111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Select all fields (select all fields include zero value fields)</span></span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;*&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Role: <span class="string">&quot;admin&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Select all fields but omit Role (select all fields include zero value fields)</span></span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;*&quot;</span>).Omit(<span class="string">&quot;Role&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Role: <span class="string">&quot;admin&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="更新hook"><a href="#更新hook" class="headerlink" title="更新hook"></a>更新hook</h3><p>GORM支持<code>BeforeSave</code>、<code>BeforeUpdate</code>、<code>AfterSave</code>、<code>AfterUpdate</code>的Hook</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> BeforeUpdate(tx *gorm.DB) (err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> u.Role == <span class="string">&quot;admin&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;admin user not allowed to update&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h3><p>如果没有用<code>Model</code>指定一个包含主键的记录，GORM会执行批量更新</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update with struct</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;admin&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE role = &#x27;admin&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update with map</span></span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Where(<span class="string">&quot;id IN ?&quot;</span>, []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">11</span>&#125;).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE id IN (10, 11);</span></span><br></pre></td></tr></table></figure><h3 id="阻止全局更新"><a href="#阻止全局更新" class="headerlink" title="阻止全局更新"></a>阻止全局更新</h3><p>如果没有设置任何条件而执行批量更新，GORM默认不会执行它，并且返回<code>ErrMissingClause</code>错误</p><p>如果想要实现<code>AllowGlobalUpdate</code>，需要设置条件(where 1&#x3D;1)或者使用原生SQL语句，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.Model(&amp;User&#123;&#125;).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Error <span class="comment">// gorm.ErrMissingWhereClause</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;1 = 1&quot;</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET `name` = &quot;jinzhu&quot; WHERE 1=1</span></span><br><span class="line"></span><br><span class="line">db.Exec(<span class="string">&quot;UPDATE users SET name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name = &quot;jinzhu&quot;</span></span><br><span class="line"></span><br><span class="line">db.Session(&amp;gorm.Session&#123;AllowGlobalUpdate: <span class="literal">true</span>&#125;).Model(&amp;User&#123;&#125;).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET `name` = &quot;jinzhu&quot;</span></span><br></pre></td></tr></table></figure><h3 id="更新对的记录数"><a href="#更新对的记录数" class="headerlink" title="更新对的记录数"></a>更新对的记录数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/ Get updated records count with <span class="string">`RowsAffected`</span></span><br><span class="line">result := db.Model(User&#123;&#125;).Where(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;admin&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE role = &#x27;admin&#x27;;</span></span><br><span class="line"></span><br><span class="line">result.RowsAffected <span class="comment">// returns updated records count</span></span><br><span class="line">result.Error        <span class="comment">// returns updating error</span></span><br></pre></td></tr></table></figure><h3 id="根据子查询进行更新"><a href="#根据子查询进行更新" class="headerlink" title="根据子查询进行更新"></a>根据子查询进行更新</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.Model(&amp;user).Update(<span class="string">&quot;company_name&quot;</span>, db.Model(&amp;Company&#123;&#125;).Select(<span class="string">&quot;name&quot;</span>).Where(<span class="string">&quot;companies.id = users.company_id&quot;</span>))</span><br><span class="line"><span class="comment">// UPDATE &quot;users&quot; SET &quot;company_name&quot; = (SELECT name FROM companies WHERE companies.id = users.company_id);</span></span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;users as u&quot;</span>).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Update(<span class="string">&quot;company_name&quot;</span>, db.Table(<span class="string">&quot;companies as c&quot;</span>).Select(<span class="string">&quot;name&quot;</span>).Where(<span class="string">&quot;c.id = u.company_id&quot;</span>))</span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;users as u&quot;</span>).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;company_name&quot;</span>: db.Table(<span class="string">&quot;companies as c&quot;</span>).Select(<span class="string">&quot;name&quot;</span>).Where(<span class="string">&quot;c.id = u.company_id&quot;</span>)&#125;)</span><br></pre></td></tr></table></figure><h3 id="不使用Hook和时间追踪"><a href="#不使用Hook和时间追踪" class="headerlink" title="不使用Hook和时间追踪"></a>不使用Hook和时间追踪</h3><p>如果想跳过钩子函数和事件追踪，可以使用<code>UpdateColumn</code>、<code>UpdateColumns</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update single column</span></span><br><span class="line">db.Model(&amp;user).UpdateColumn(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update multiple columns</span></span><br><span class="line">db.Model(&amp;user).UpdateColumns(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update selected columns</span></span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>).UpdateColumns(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=0 WHERE id = 111;</span></span><br></pre></td></tr></table></figure><h3 id="检查字段是否变更"><a href="#检查字段是否变更" class="headerlink" title="检查字段是否变更"></a>检查字段是否变更</h3><p>可以在<code>Before Update Hooks</code>中使用<code>Changed</code>方法，并检查更新的值是否等于模型的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> BeforeUpdate(tx *gorm.DB) (err <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="comment">// if Role changed</span></span><br><span class="line">    <span class="keyword">if</span> tx.Statement.Changed(<span class="string">&quot;Role&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;role not allowed to change&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> tx.Statement.Changed(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Admin&quot;</span>) &#123; <span class="comment">// if Name or Role changed</span></span><br><span class="line">    tx.Statement.SetColumn(<span class="string">&quot;Age&quot;</span>, <span class="number">18</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if any fields changed</span></span><br><span class="line">    <span class="keyword">if</span> tx.Statement.Changed() &#123;</span><br><span class="line">        tx.Statement.SetColumn(<span class="string">&quot;RefreshedAt&quot;</span>, time.Now())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Model(&amp;User&#123;ID: <span class="number">1</span>, Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu2&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// Changed(&quot;Name&quot;) =&gt; true</span></span><br><span class="line">db.Model(&amp;User&#123;ID: <span class="number">1</span>, Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// Changed(&quot;Name&quot;) =&gt; false, `Name` not changed</span></span><br><span class="line">db.Model(&amp;User&#123;ID: <span class="number">1</span>, Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).Select(<span class="string">&quot;Admin&quot;</span>).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu2&quot;</span>, <span class="string">&quot;admin&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// Changed(&quot;Name&quot;) =&gt; false, `Name` not selected to update</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;User&#123;ID: <span class="number">1</span>, Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).Updates(User&#123;Name: <span class="string">&quot;jinzhu2&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// Changed(&quot;Name&quot;) =&gt; true</span></span><br><span class="line">db.Model(&amp;User&#123;ID: <span class="number">1</span>, Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).Updates(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// Changed(&quot;Name&quot;) =&gt; false, `Name` not changed</span></span><br><span class="line">db.Model(&amp;User&#123;ID: <span class="number">1</span>, Name: <span class="string">&quot;jinzhu&quot;</span>&#125;).Select(<span class="string">&quot;Admin&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;jinzhu2&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// Changed(&quot;Name&quot;) =&gt; false, `Name` not selected to update</span></span><br></pre></td></tr></table></figure><h3 id="在Update时修改值"><a href="#在Update时修改值" class="headerlink" title="在Update时修改值"></a>在Update时修改值</h3><p>如果想在<code>Before Update Hook</code>时修改值，要使用<code>SetColumn</code>方法，否则会使用<code>Save</code>保存全部字段，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(user *User)</span></span> BeforeSave(tx *gorm.DB) (err <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> pw, err := bcrypt.GenerateFromPassword(user.Password, <span class="number">0</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    tx.Statement.SetColumn(<span class="string">&quot;EncryptedPassword&quot;</span>, pw)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> tx.Statement.Changed(<span class="string">&quot;Code&quot;</span>) &#123;</span><br><span class="line">    user.Age += <span class="number">20</span></span><br><span class="line">    tx.Statement.SetColumn(<span class="string">&quot;Age&quot;</span>, user.Age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).Update(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="删除一条记录"><a href="#删除一条记录" class="headerlink" title="删除一条记录"></a>删除一条记录</h3><p>删除一条记录时，删除对象要包含主键，否则会触发批量删除，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Email 的 ID 是 `10`</span></span><br><span class="line">db.Delete(&amp;email)</span><br><span class="line"><span class="comment">// DELETE from emails where id = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带额外条件的删除</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Delete(&amp;email)</span><br><span class="line"><span class="comment">// DELETE from emails where id = 10 AND name = &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure><h3 id="根据主键删除"><a href="#根据主键删除" class="headerlink" title="根据主键删除"></a>根据主键删除</h3><p>GORM可以通过主键和内联条件来删除对象，可以使用数字，也可以使用字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.Delete(&amp;User&#123;&#125;, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;User&#123;&#125;, <span class="string">&quot;10&quot;</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;users, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id IN (1,2,3);</span></span><br></pre></td></tr></table></figure><h3 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h3><p>如果指定的值不包含主键，那么GORM会执行批量删除</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;email LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>).Delete(&amp;Email&#123;&#125;)</span><br><span class="line"><span class="comment">// DELETE from emails where email LIKE &quot;%jinzhu%&quot;;</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;Email&#123;&#125;, <span class="string">&quot;email LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>)</span><br><span class="line"><span class="comment">// DELETE from emails where email LIKE &quot;%jinzhu%&quot;;</span></span><br></pre></td></tr></table></figure><p>为了高效的删除大量的记录，可以传递一个主键的切片给<code>Delete</code>方法，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;ID: <span class="number">1</span>&#125;, &#123;ID: <span class="number">2</span>&#125;, &#123;ID: <span class="number">3</span>&#125;&#125;</span><br><span class="line">db.Delete(&amp;users)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id IN (1,2,3);</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;users, <span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE name LIKE &quot;%jinzhu%&quot; AND id IN (1,2,3); </span></span><br></pre></td></tr></table></figure><h3 id="Delete-Hook"><a href="#Delete-Hook" class="headerlink" title="Delete Hook"></a>Delete Hook</h3><p>对于删除操作，GORM支持<code>BeforeDelete</code>、<code>AfterDelete</code>，在删除记录时会调用这些方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> BeforeDelete(tx *gorm.DB) (err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> u.Role == <span class="string">&quot;admin&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;admin user not allowed to delete&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻止全局删除"><a href="#阻止全局删除" class="headerlink" title="阻止全局删除"></a>阻止全局删除</h3><p>如果执行批量删除时没有配置任何的条件，那么默认情况下GORM不会执行它，并返回一个<code>ErrMissingWhereClause</code>错误</p><p>要想使用<code>AllowGlobalUDelete</code>，需要配置条件（where 1&#x3D;1）或者使用原生SQL语句，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">db.Delete(&amp;User&#123;&#125;).Error <span class="comment">// gorm.ErrMissingWhereClause</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;[]User&#123;&#123;Name: <span class="string">&quot;jinzhu1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu2&quot;</span>&#125;&#125;).Error <span class="comment">// gorm.ErrMissingWhereClause</span></span><br><span class="line"></span><br><span class="line">db.Where(<span class="string">&quot;1 = 1&quot;</span>).Delete(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// DELETE FROM `users` WHERE 1=1</span></span><br><span class="line"></span><br><span class="line">db.Exec(<span class="string">&quot;DELETE FROM users&quot;</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users</span></span><br><span class="line"></span><br><span class="line">db.Session(&amp;gorm.Session&#123;AllowGlobalUpdate: <span class="literal">true</span>&#125;).Delete(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// DELETE FROM users</span></span><br></pre></td></tr></table></figure><h3 id="返回删除行的数据"><a href="#返回删除行的数据" class="headerlink" title="返回删除行的数据"></a>返回删除行的数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return all columns</span></span><br><span class="line"><span class="keyword">var</span> users []User</span><br><span class="line">DB.Clauses(clause.Returning&#123;&#125;).Where(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;admin&quot;</span>).Delete(&amp;users)</span><br><span class="line"><span class="comment">// DELETE FROM `users` WHERE role = &quot;admin&quot; RETURNING *</span></span><br><span class="line"><span class="comment">// users =&gt; []User&#123;&#123;ID: 1, Name: &quot;jinzhu&quot;, Role: &quot;admin&quot;, Salary: 100&#125;, &#123;ID: 2, Name: &quot;jinzhu.2&quot;, Role: &quot;admin&quot;, Salary: 1000&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// return specified columns</span></span><br><span class="line">DB.Clauses(clause.Returning&#123;Columns: []clause.Column&#123;&#123;Name: <span class="string">&quot;name&quot;</span>&#125;, &#123;Name: <span class="string">&quot;salary&quot;</span>&#125;&#125;&#125;).Where(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;admin&quot;</span>).Delete(&amp;users)</span><br><span class="line"><span class="comment">// DELETE FROM `users` WHERE role = &quot;admin&quot; RETURNING `name`, `salary`</span></span><br><span class="line"><span class="comment">// users =&gt; []User&#123;&#123;ID: 0, Name: &quot;jinzhu&quot;, Role: &quot;&quot;, Salary: 100&#125;, &#123;ID: 0, Name: &quot;jinzhu.2&quot;, Role: &quot;&quot;, Salary: 1000&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="软删除"><a href="#软删除" class="headerlink" title="软删除"></a>软删除</h3><p>如果模型中包含<code>gorm.Delete</code>字段（包含在<code>gorm.Model</code>中），那么这个模型可以以自动被软删除</p><p>当调用<code>Delete</code>时，记录不会从数据库中移除，GORM会设置<code>DeleteAt</code>为当前时间，而这个数据不再能通过普通的查询方法获取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user&#x27;s ID is `111`</span></span><br><span class="line">db.Delete(&amp;user)</span><br><span class="line"><span class="comment">// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Batch Delete</span></span><br><span class="line">db.Where(<span class="string">&quot;age = ?&quot;</span>, <span class="number">20</span>).Delete(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Soft deleted records will be ignored when querying</span></span><br><span class="line">db.Where(<span class="string">&quot;age = 20&quot;</span>).Find(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL;</span></span><br></pre></td></tr></table></figure><p>如果不想包含<code>gorm.Model</code>，可以这样使用软删除的特性</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID      <span class="type">int</span></span><br><span class="line">  Deleted gorm.DeletedAt</span><br><span class="line">  Name    <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找被软删除的记录"><a href="#查找被软删除的记录" class="headerlink" title="查找被软删除的记录"></a>查找被软删除的记录</h3><p>可以使用<code>Unscoped</code>方法获得被软删除的记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Unscoped().Where(<span class="string">&quot;age = 20&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 20;</span></span><br></pre></td></tr></table></figure><h3 id="永久删除"><a href="#永久删除" class="headerlink" title="永久删除"></a>永久删除</h3><p>可以使用<code>Unscoped</code>方法永久删除记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Unscoped().Delete(&amp;order)</span><br><span class="line"><span class="comment">// DELETE FROM orders WHERE id=10;</span></span><br></pre></td></tr></table></figure><h3 id="Delete标签"><a href="#Delete标签" class="headerlink" title="Delete标签"></a>Delete标签</h3><p><code>gorm.Model</code>使用<code>time.Time</code>作为<code>DeleteAt</code>的值，可以通过插件<code>gorm.io/plugin/soft_delete</code>使用其他类型的数据</p><p><strong>注意</strong> 为<code>DeleteAt</code>创建唯一性符合索引时，必须使用其他数据类型，比如unix second&#x2F;flag</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;gorm.io/plugin/soft_delete&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">uint</span></span><br><span class="line">  Name      <span class="type">string</span>                <span class="string">`gorm:&quot;uniqueIndex:udx_name&quot;`</span></span><br><span class="line">  DeletedAt soft_delete.DeletedAt <span class="string">`gorm:&quot;uniqueIndex:udx_name&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Unix时间戳"><a href="#Unix时间戳" class="headerlink" title="Unix时间戳"></a>Unix时间戳</h4><p>使用秒级时间戳作为<code>delete</code>的标签</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;gorm.io/plugin/soft_delete&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">uint</span></span><br><span class="line">  Name      <span class="type">string</span></span><br><span class="line">  DeletedAt soft_delete.DeletedAt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Query</span></span><br><span class="line">SELECT * FROM users WHERE deleted_at = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete</span></span><br><span class="line">UPDATE users SET deleted_at = <span class="comment">/* current unix second */</span> WHERE ID = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>还可以使用<code>milli</code>或<code>nano</code>作为值，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID    <span class="type">uint</span></span><br><span class="line">  Name  <span class="type">string</span></span><br><span class="line">  DeletedAt soft_delete.DeletedAt <span class="string">`gorm:&quot;softDelete:milli&quot;`</span></span><br><span class="line">  <span class="comment">// DeletedAt soft_delete.DeletedAt `gorm:&quot;softDelete:nano&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Query</span></span><br><span class="line">SELECT * FROM users WHERE deleted_at = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete</span></span><br><span class="line">UPDATE users SET deleted_at = <span class="comment">/* current unix milli second or nano second */</span> WHERE ID = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="使用1-x2F-0作为Delete标签"><a href="#使用1-x2F-0作为Delete标签" class="headerlink" title="使用1&#x2F;0作为Delete标签"></a>使用1&#x2F;0作为Delete标签</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;gorm.io/plugin/soft_delete&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID    <span class="type">uint</span></span><br><span class="line">  Name  <span class="type">string</span></span><br><span class="line">  IsDel soft_delete.DeletedAt <span class="string">`gorm:&quot;softDelete:flag&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Query</span></span><br><span class="line">SELECT * FROM users WHERE is_del = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete</span></span><br><span class="line">UPDATE users SET is_del = <span class="number">1</span> WHERE ID = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h4><p>顾名思义，既有时间戳，也有1&#x2F;0</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">uint</span></span><br><span class="line">  Name      <span class="type">string</span></span><br><span class="line">  DeletedAt time.Time</span><br><span class="line">  IsDel     soft_delete.DeletedAt <span class="string">`gorm:&quot;softDelete:flag,DeletedAtField:DeletedAt&quot;`</span> <span class="comment">// use `1` `0`</span></span><br><span class="line">  <span class="comment">// IsDel     soft_delete.DeletedAt `gorm:&quot;softDelete:,DeletedAtField:DeletedAt&quot;` // use `unix second`</span></span><br><span class="line">  <span class="comment">// IsDel     soft_delete.DeletedAt `gorm:&quot;softDelete:nano,DeletedAtField:DeletedAt&quot;` // use `unix nano second`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Query</span></span><br><span class="line">SELECT * FROM users WHERE is_del = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete</span></span><br><span class="line">UPDATE users SET is_del = <span class="number">1</span>, deleted_at = <span class="comment">/* current unix second */</span> WHERE ID = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h1 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>GORM可以通过<code>index</code>、<code>uniqueIndex</code>标签创建索引，这些索引将在GORM进行AutoMigrate或Createtable时创建的</p><h3 id="索引标签"><a href="#索引标签" class="headerlink" title="索引标签"></a>索引标签</h3><p>GORM可以接受很多索引设置，例如<code>class</code>、<code>type</code>、<code>where</code>、<code>comment</code>、<code>expression</code>、<code>sort</code>、<code>collate</code>、<code>option</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="type">string</span> <span class="string">`gorm:&quot;index&quot;`</span></span><br><span class="line">    Name2 <span class="type">string</span> <span class="string">`gorm:&quot;index:idx_name,unique&quot;`</span></span><br><span class="line">    Name3 <span class="type">string</span> <span class="string">`gorm:&quot;index:,sort:desc,collate:utf8,type:btree,length:10,where:name3 != &#x27;jinzhu&#x27;&quot;`</span></span><br><span class="line">    Name4 <span class="type">string</span> <span class="string">`gorm:&quot;uniqueIndex&quot;`</span></span><br><span class="line">    Age   <span class="type">int64</span>  <span class="string">`gorm:&quot;index:,class:FULLTEXT,comment:hello \\, world,where:age &gt; 10&quot;`</span></span><br><span class="line">    Age2  <span class="type">int64</span>  <span class="string">`gorm:&quot;index:,expression:ABS(age)&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MySQL 选项</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`gorm:&quot;index:,class:FULLTEXT,option:WITH PARSER ngram INVISIBLE&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostgreSQL 选项</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`gorm:&quot;index:,option:CONCURRENTLY&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p><code>uniqueIndex</code>标签的作用与<code>index</code>类似，它等效于<code>index:,unique</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name1 <span class="type">string</span> <span class="string">`gorm:&quot;uniqueIndex&quot;`</span></span><br><span class="line">    Name2 <span class="type">string</span> <span class="string">`gorm:&quot;uniqueIndex:idx_name,sort:desc&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><p>两个字段使用同一个索引名将创建符合索引，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create composite index `idx_member` with columns `name`, `number`</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name   <span class="type">string</span> <span class="string">`gorm:&quot;index:idx_member&quot;`</span></span><br><span class="line">    Number <span class="type">string</span> <span class="string">`gorm:&quot;index:idx_member&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字段优先级"><a href="#字段优先级" class="headerlink" title="字段优先级"></a>字段优先级</h3><p>复合索引列的顺序会影响其性能，必须仔细考虑</p><p>可以使用<code>priority</code>指定顺序，默认优先级是<code>10</code>，如果优先级值相同，则顺序取决于模型结构体字段的顺序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name   <span class="type">string</span> <span class="string">`gorm:&quot;index:idx_member&quot;`</span></span><br><span class="line">    Number <span class="type">string</span> <span class="string">`gorm:&quot;index:idx_member&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// column order: name, number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name   <span class="type">string</span> <span class="string">`gorm:&quot;index:idx_member,priority:2&quot;`</span></span><br><span class="line">    Number <span class="type">string</span> <span class="string">`gorm:&quot;index:idx_member,priority:1&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// column order: number, name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name   <span class="type">string</span> <span class="string">`gorm:&quot;index:idx_member,priority:12&quot;`</span></span><br><span class="line">    Number <span class="type">string</span> <span class="string">`gorm:&quot;index:idx_member&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// column order: number, name</span></span><br></pre></td></tr></table></figure><h3 id="共享复合索引"><a href="#共享复合索引" class="headerlink" title="共享复合索引"></a>共享复合索引</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go爬虫实战</title>
      <link href="/2023/03/30/Go%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98/"/>
      <url>/2023/03/30/Go%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Go爬虫实战"><a href="#Go爬虫实战" class="headerlink" title="Go爬虫实战"></a>Go爬虫实战</h1><p><img src="/.com//Users\Liang\Desktop\crawler.png" alt="crawler"></p><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><h3 id="构造客户端"><a href="#构造客户端" class="headerlink" title="构造客户端"></a>构造客户端</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client http.Client</span><br></pre></td></tr></table></figure><h3 id="构造get请求"><a href="#构造get请求" class="headerlink" title="构造get请求"></a>构造get请求</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reqList,err:=http.NewRequest(<span class="string">&quot;GET&quot;</span>,URL,<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h3 id="Cookie伪装"><a href="#Cookie伪装" class="headerlink" title="Cookie伪装"></a>Cookie伪装</h3><p>Go中提供一个<code>cookiejar.New</code>的函数，用于保存生成的Cookie信息，有一些网站要登陆后才能爬取，这时就要在请求头上加上cookie进行伪装</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jar,err:=cookiejar.New(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当发送完请求后，cookie就会保存在<code>client.Jar</code>这个包中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myStr:=fmt.Sprintf(<span class="string">&quot;%s&quot;</span>,client.Jar) <span class="comment">//强制类型转换指针到string</span></span><br></pre></td></tr></table></figure><p>打印出<code>client.Jar</code>这个包后，选出相应的cookie，放在请求头上面，就可以解决需要登录的问题了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.Header.Set(<span class="string">&quot;Cookie&quot;</span>, <span class="string">&quot;ASP.NET_SessionId=&quot;</span>+cook)</span><br></pre></td></tr></table></figure><h3 id="构造post请求"><a href="#构造post请求" class="headerlink" title="构造post请求"></a>构造post请求</h3><p>构造post请求时，把要传输的数据封装好，与<code>url</code>一起构造</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client http.Client</span><br><span class="line">Info :=<span class="string">&quot;muser=&quot;</span>+muserid+<span class="string">&quot;&amp;&quot;</span>+<span class="string">&quot;passwd&quot;</span>+password</span><br><span class="line"><span class="keyword">var</span> data = <span class="type">string</span>.NewReader(Info)</span><br><span class="line">req,err:=http.NewRequest(<span class="string">&quot;POST&quot;</span>,URL,data)</span><br></pre></td></tr></table></figure><p>添加请求头</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">req.Header.Set(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;keep-alive&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;Pragma&quot;</span>, <span class="string">&quot;no-cache&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;Upgrade-Insecure-Requests&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;</span>)</span><br><span class="line">req.Header.Set(<span class="string">&quot;Accept-Language&quot;</span>, <span class="string">&quot;zh-CN,zh;q=0.9&quot;</span>)</span><br></pre></td></tr></table></figure><p>发送请求</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resp, _:= client.Do(req)  <span class="comment">// 发送请求</span></span><br><span class="line">bodyText, _ := ioutil.ReadAll(resp.Body)  <span class="comment">// 使用缓冲区读取网页内容</span></span><br></pre></td></tr></table></figure><h2 id="解析网页"><a href="#解析网页" class="headerlink" title="解析网页"></a>解析网页</h2><h3 id="css选择器"><a href="#css选择器" class="headerlink" title="css选择器"></a>css选择器</h3><p><code>github.com/PuerkitoBio/goquery</code>提供了<code>NewDocumentFromReader</code>方法进行网页解析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doc, err := goquery.NewDocumentFromReader(resp.Body)</span><br></pre></td></tr></table></figure><h3 id="Xpath语法"><a href="#Xpath语法" class="headerlink" title="Xpath语法"></a>Xpath语法</h3><p><code>github.com/antchfx/htmlquery</code>提供了<code>Parse</code>方法进行网页解析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root, _ := htmlquery.Parse(resp.Body)</span><br></pre></td></tr></table></figure><h3 id="Regex正则"><a href="#Regex正则" class="headerlink" title="Regex正则"></a>Regex正则</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reId, _ := regexp.Compile(<span class="string">`id=(\d+)`</span>)  <span class="comment">// 正则匹配</span></span><br><span class="line">allId := reId.FindAll(bodyText,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> _,item := <span class="keyword">range</span> allId &#123;</span><br><span class="line">id=<span class="type">string</span>(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取节点信息"><a href="#获取节点信息" class="headerlink" title="获取节点信息"></a>获取节点信息</h2><h3 id="css选择器-1"><a href="#css选择器-1" class="headerlink" title="css选择器"></a>css选择器</h3><p>拿到上一步解析出来的<code>doc</code>后，可以进行css选择器语法，进行节点选择</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">doc.Find(<span class="string">&quot;#main &gt; div.right &gt; div.detail_main_content&quot;</span>).</span><br><span class="line">Each(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>, s *goquery.Selection)</span></span> &#123;</span><br><span class="line">Data.title = s.Find(<span class="string">&quot;p&quot;</span>).Text()</span><br><span class="line">Data.time = s.Find(<span class="string">&quot;#fbsj&quot;</span>).Text()</span><br><span class="line">Data.author = s.Find(<span class="string">&quot;#author&quot;</span>).Text()</span><br><span class="line">Data.count = Read_Count(Read_Id)</span><br><span class="line">fmt.Println(Data.title, Data.time, Data.author,Data.count)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">doc.Find(<span class="string">&quot;#news_content_display&quot;</span>).Each(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>, s *goquery.Selection)</span></span> &#123;</span><br><span class="line">Data.content = s.Find(<span class="string">&quot;p&quot;</span>).Text()</span><br><span class="line">fmt.Println(Data.content)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Xpath语法-1"><a href="#Xpath语法-1" class="headerlink" title="Xpath语法"></a>Xpath语法</h3><p>拿到上一步解析出来的root之后，可以进行Xpath语法的编写，进行节点的选择</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tr := htmlquery.Find(root, <span class="string">&quot;//*[@id=&#x27;LB_kb&#x27;]/table/tbody/tr/td&quot;</span>)   <span class="comment">//使用Xpath进行结点信息的获取</span></span><br><span class="line"><span class="keyword">for</span> _, row := <span class="keyword">range</span> tr &#123; <span class="comment">//len(tr)=13</span></span><br><span class="line">classNames := htmlquery.Find(row, <span class="string">&quot;./font&quot;</span>)</span><br><span class="line">classPosistions := htmlquery.Find(row,<span class="string">&quot;./text()[4]&quot;</span>)</span><br><span class="line">classTeachers := htmlquery.Find(row,<span class="string">&quot;./text()[5]&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(classNames)!=<span class="number">0</span> &#123;</span><br><span class="line">className = htmlquery.InnerText(classNames[<span class="number">0</span>])</span><br><span class="line">classPosistion = htmlquery.InnerText(classPosistions[<span class="number">0</span>])</span><br><span class="line">classTeacher = htmlquery.InnerText(classTeachers[<span class="number">0</span>])</span><br><span class="line">  fmt.Println(className)</span><br><span class="line">  fmt.Println(classPosistion)</span><br><span class="line">  fmt.Println(classTeacher)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="保存信息"><a href="#保存信息" class="headerlink" title="保存信息"></a>保存信息</h2><ol><li>原生SQL语句保存到Mysql中</li><li>使用gorm保存到Mysql中</li></ol><h2 id="Go核心爬虫框架Colly"><a href="#Go核心爬虫框架Colly" class="headerlink" title="Go核心爬虫框架Colly"></a>Go核心爬虫框架Colly</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>清晰明了的 API</li><li>速度快（单个内核上的请求数大于1k）</li><li>管理每个域的请求延迟和最大并发数</li><li>自动 cookie 和会话处理</li><li>同步&#x2F;异步&#x2F;并行抓取</li><li>高速缓存</li><li>自动处理非 Unicode 编码</li><li>支持 Robots.txt</li><li>支持 Google App Engine</li><li>通过环境变量配置</li><li>可扩展</li></ul><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><ul><li><p><strong>OnRequest</strong><br>在请求之前调用，这里只是简单打印请求的 URL。</p></li><li><p><strong>OnError</strong><br>如果请求期间发生错误则调用，这里简单打印 URL 和错误信息。</p></li><li><p><strong>OnResponseHeaders</strong><br>在收到响应标头后调用</p></li><li><p><strong>OnResponse</strong><br>收到回复后调用，这里也只是简单的打印 URL 和响应大小。</p></li><li><p><strong>OnHTML</strong><br>OnResponse如果收到的内容是HTML ,则在之后调用</p></li><li><p><strong>OnXML</strong><br>OnHTML如果接收到的内容是HTML或XML ,则在之后调用</p></li><li><p><strong>OnScraped</strong></p><p>OnXML回调后调用</p></li></ul><p><strong>回调顺序</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OnRequest—&gt;OnResponse—&gt;OnHTML-&gt;OnXML—&gt;OnScraped</span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>Attr(k string)</code>：返回当前元素的属性，上面示例中我们使用<code>e.Attr(&quot;href&quot;)</code>获取了<code>href</code>属性；</li><li><code>ChildAttr(goquerySelector, attrName string)</code>：返回<code>goquerySelector</code>选择的第一个子元素的<code>attrName</code>属性；</li><li><code>ChildAttrs(goquerySelector, attrName string)</code>：返回<code>goquerySelector</code>选择的所有子元素的<code>attrName</code>属性，以<code>[]string</code>返回；</li><li><code>ChildText(goquerySelector string)</code>：拼接<code>goquerySelector</code>选择的子元素的文本内容并返回；</li><li><code>ChildTexts(goquerySelector string)</code>：返回<code>goquerySelector</code>选择的子元素的文本内容组成的切片，以<code>[]string</code>返回。</li><li><code>ForEach(goquerySelector string, callback func(int, *HTMLElement))</code>：对每个<code>goquerySelector</code>选择的子元素执行回调<code>callback</code>；</li><li><code>Unmarshal(v interface&#123;&#125;)</code>：通过给结构体字段指定 goquerySelector 格式的 tag，可以将一个 HTMLElement 对象 Unmarshal 到一个结构体实例中。</li></ul><ol><li><p>通过id查找</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#t1</span><br></pre></td></tr></table></figure></li><li><p>通过class查找</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.c1</span><br></pre></td></tr></table></figure></li><li><p>通过标签查找</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titile</span><br></pre></td></tr></table></figure></li></ol><h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><p>设置<code>User-Agent</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c := colly.NewCollector()</span><br><span class="line"><span class="comment">//User-Agent</span></span><br><span class="line">c.UserAgent = (<span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.53 Safari/537.36 Edg/103.0.1264.37&quot;</span>)</span><br></pre></td></tr></table></figure><p>设置cookie</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.OnRequest(<span class="function"><span class="keyword">func</span><span class="params">(request *colly.Request)</span></span> &#123;</span><br><span class="line">   request.Headers.Add(<span class="string">&quot;Cookie&quot;</span>, <span class="string">&quot;_ga=GA1.2.927242199.1656415218; _gid=GA1.2.165227307.1656415218; __atuvc=4%7C26; __atuvs=62bb96de45b68598000&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>也可以使用刚获取到的url中的cookie</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cookie := c.Cookies(<span class="string">&quot;https://gorm.io/zh_CN/docs/&quot;</span>)</span><br><span class="line">c.SetCookies(<span class="string">&quot;&quot;</span>, cookie)</span><br></pre></td></tr></table></figure><h2 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h2><p>cholly爬虫爬到的网页是网站未进行JavaScript渲染时的网页源代码，很多想要的内容都在js文件里面，还没有渲染出来，也就爬不到</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>消息队列</title>
      <link href="/2023/03/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2023/03/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h3 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h3><p><strong>消息队列</strong>（Message Queue）简称<strong>MQ</strong>是一种先进先出的数据结构，实际上是系统内核中的一个内部链表。拥有权限的进程可以向消息队列中写入或读取消息，消息被顺序插入队列中，其中发送进程将消息添加导队列末尾，接受进程从队列头读取消息。</p><p>它是一种<strong>异步通信机制</strong>（本地or网络），通过将信息存储在队列中，使得生产者和消费者能够<strong>独立地</strong>处理消息，而不必实时进行通信。</p><p>消息队列可以用于许多不同的场景，例如：</p><ul><li>任务调度：将需要执行的任务发送到队列中，由消费者进行处理</li><li>异步通信：将消息发送到队列中，以便异步处理，避免实时通信带来的延迟和复杂性</li><li>解耦：将系统的不同组件解耦，使它们可以独立地演化和扩展</li></ul><p>消息队列通常包括以下组件:</p><ul><li>消息生产者：发送消息</li><li>消息队列：存储消息</li><li>消息消费者：从消息队列获取消息并处理</li><li>消息传递协议：定义和规范消息传递的格式和过程</li></ul><h3 id="使用消息队列的优点"><a href="#使用消息队列的优点" class="headerlink" title="使用消息队列的优点"></a>使用消息队列的优点</h3><ol><li><strong>解耦</strong>应用程序：通过将应用程序之间的通信加入到消息队列中，可以减少应用程序之间的直接依赖性，从而提高系统的<strong>可维护性</strong>和<strong>可扩展性</strong>。这在分布式系统中尤为重要。</li><li>提高<strong>系统性能</strong>：通过使用消息队列，可以将<strong>请求</strong>和<strong>响应</strong>解耦，使得生产者和消费者之间可以异步地进行通信。这种方法能够提高系统地<strong>吞吐量</strong>和<strong>并发性</strong>，从提高系统性能。</li><li>实现<strong>异步通信</strong>：通过使用消息队列，可以将应用程序中的消息异步地发送到另一个应用程序或进程。可以提高应用程序的性能，因为发送方不需要等待接收方处理完消息才能继续执行。</li><li>增加系统<strong>可靠性</strong>：即使消费者不可用，生产者可以继续发送消息到队列中，当消费者重新可用时，可以从队列中读取未处理的消息。</li></ol><p>总的来看：</p><ol><li>在特殊场景下，比如<strong>高并发</strong>、<strong>高可用</strong>、<strong>分布式</strong>等情况下，使用消息队列可以提高系统性能和稳定性</li><li>在<strong>事件驱动架构</strong>中，使用消息队列可以实现发布-订阅模式，让不同的模块之间可以相互通信和协作</li></ol><h3 id="消息传递协议（消息协议）"><a href="#消息传递协议（消息协议）" class="headerlink" title="消息传递协议（消息协议）"></a>消息传递协议（消息协议）</h3><p>如果消息队列要在网络中进行通行，那就需要采用一种通信协议。</p><p><strong>AMQP</strong>、<strong>MQTT</strong>和<strong>STOMP</strong>是三种最常见、最流行的基于TCP&#x2F;IP的消息传递协议。</p><p><strong>为什么使用TCP&#x2F;IP协议？</strong></p><p>首先，UDP是一种无连接的协议，而TCP是一种面向连接的协议。这意味着在使用TCP传输数据之前，需要先建立连接，而使用UDP则不需要建立连接就可以直接发送数据。</p><p>其次，TCP提供可靠的数据传输，它会对丢失或损坏的数据包进行重传，并且会对乱序的数据包进行重新排序。而UDP则不提供这些功能，它只负责将数据包从一端发送到另一端。</p><ul><li><h4 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h4></li></ul><p>高级消息队列协议，即Advanced Message Queuing Protocol，是一种开放的、标准化的消息传递协议。它提供了一个统一的消息格式和路由机制，支持不同类型的消息传递模型，包括点对点、发布&#x2F;订阅和工作队列等。</p><ul><li><h4 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h4></li></ul><p>消息队列遥测传输，即Message Queuing Telemetry Transport，是一种轻量级的、基于发布&#x2F;订阅模型的消息传递协议，旨在为低带宽、高延迟、不稳定网络的环境下进行通信提供解决方案。MQTT协议的设计目标是为传感器和移动设备等资源受限的设备提供一种高效的、可靠的消息传递机制。</p><ul><li><h4 id="STOMP"><a href="#STOMP" class="headerlink" title="STOMP"></a>STOMP</h4></li></ul><p>简单文本定向消息协议，即Simple Text Oriented Messaging Protocol，是一种基于文本的、卖你想消息的传输协议。STOMP协议采用类似HTTP协议的请求-响应模式进行通信，客户端通过发送STOMP命令来向服务器发送消息或订阅消息，服务器通过返回STOMP响应来向客户端发送消息或确认消息的接收。STOMP协议支持多种消息传递模型，包括点对点、发布&#x2F;订阅和事务等。</p><h3 id="消息队列模型"><a href="#消息队列模型" class="headerlink" title="消息队列模型"></a>消息队列模型</h3><ul><li><strong>点对点模型</strong></li></ul><p>点对点模型中，消息发送者将消息发送到一个队列，接收者从队列中接收消息。每个消息只能被一个接收者接收。这种模型通常用于任务分配、异步处理和日志记录等应用程序。</p><ul><li><strong>发布-订阅模型</strong></li></ul><p>发布-订阅模型中，消息发送者（也叫 <strong>发布者</strong> publisher）将消息发布到一个<strong>主题</strong>（topics），所有订阅该主题的接收者（也叫 <strong>订阅者</strong> Subscriber）都将收到该消息。这种模型通常用于实时数据分发、事件处理和广告推送等应用程序。如果只有一个订阅者，那么它和队列模型基本就是一样的。</p><ul><li><strong>管道模型</strong></li></ul><p>管道模型中，消息发送者将消息发送到一个管道，接收者从管道中接收消息。与点对点模型不同的是，<strong>多个接收者</strong>可以从同一个管道中接收消息。这种模型通常用于数据流处理、多路复用和并行计算等应用程序。</p><ul><li><strong>扇出模型</strong></li></ul><p>扇出模型中，一个消息发送到一个队列，然后被多个接收者处理。这种模型通常用于任务处理和广播通知等应用程序。</p><h2 id="常见的MQ"><a href="#常见的MQ" class="headerlink" title="常见的MQ"></a>常见的MQ</h2><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><h4 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h4><p>RabbitMQ是一种流行的开源消息代理软件，用于实现面向消息的中间件。基于高级消息队列协议（AMQP），使用Erlang编程语言编写。</p><p>RabbitMQ充当应用程序和需要相互通信的服务之间的中间人或代理。它从生产者接收消息，并根据应用程序定义的一组规则将它们路由到消费者。</p><h5 id="组成部分说明"><a href="#组成部分说明" class="headerlink" title="组成部分说明"></a><strong>组成部分说明</strong></h5><p><img src="/.com//.%5CRabbitMQComponents.png" alt="RabbitMQComponents"></p><ol><li><code>Broker</code>：消息队列服务进程，此进程包括两个部分：Exchange和Queue</li><li><code>Exchange</code>：消息队列交换机，接收来自 Producer 发送的消息的组件，根据特定的路由规则将消息路由到一个或多个队列中。</li><li><code>Queue</code>：消息队列，是 RabbitMQ 中的消息存储区域，用于保存等待被 Consumer 消费的消息。</li><li><code>Producer</code>：消息生产者，是将消息发送到 RabbitMQ 的应用程序。</li><li><code>Consumer</code>：消息消费者，即消费方客户端，接受MQ转发的消息。</li></ol><h5 id="基本工作历程"><a href="#基本工作历程" class="headerlink" title="基本工作历程"></a><strong>基本工作历程</strong></h5><ul><li><strong>生产者发送消息流程：</strong><ol><li>生产者和Broker建立TCP连接</li><li>生产者和Broker建立通道</li><li>生产者通过通道消息发送给Broker，由Exchange将信息进行转发</li><li>Exchange将消息转发到指定的队列Queue</li></ol></li><li><strong>消费者接受消息流程：</strong><ol><li>消费者和Broker建立TCP连接</li><li>消费者和Broker建立通道</li><li>消费者监听指定的Queue</li><li>当有消息到达Queue时Broker默认将消息推送给消费者</li><li>消费者接收到消息</li><li>ack回复</li></ol></li></ul><h5 id="消息传递模式"><a href="#消息传递模式" class="headerlink" title="消息传递模式"></a><strong>消息传递模式</strong></h5><p>消息传递模式注重消息的传递方式和目的地，强调消息的<strong>路由</strong>和<strong>分发</strong>。</p><p>RabbitMQ提供各种消息传递模式，例如：</p><ul><li>点对点（Point-to-Point）</li></ul><p>一个生产者向一个队列发送消息，一个消费者从该队列中接收并处理消息。这种模式类似于一个发送方和一个接收方之间的直接通信</p><ul><li>发布&#x2F;订阅（Publish&#x2F;Subscribe）</li></ul><p>一个生产者将消息发送到一个交换机（Exchange），多个消费者从该交换机关联的队列中接收并处理消息。这种模式类似于广播，一个发送方可以将消息发布到多个接收方。</p><ul><li>请求&#x2F;应答（Request&#x2F;Reply）</li></ul><p>一个客户端向一个服务端发送请求，服务端接收并处理请求，并将响应发送回客户端。这种模式类似于客户端和服务器之间的请求和响应。</p><ul><li>订阅&#x2F;发布（Subscribe&#x2F;Publish）</li></ul><p>多个消费者订阅一个主题，当一个生产者向该主题发送消息时，所有订阅该主题的消费者都会接收到该消息并进行处理。这种模式类似于广播，一个发送方可以将消息发布到多个接收方。</p><p>和发布&#x2F;订阅有啥区别？？没搞明白</p><h5 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a><strong>工作模式</strong></h5><p>工作模式注重消息的处理方式和消费者的并发能力，强调消息的<strong>处理</strong>和<strong>消费</strong>。</p><p>RabbitMQ提供的工作模式：</p><ul><li><strong>简单模式</strong>（Simple Mode）</li></ul><p>生产者将消息发送到一个队列，消费者从该队列中接收消息并处理。这是最基本的工作模式，但不适合高并发和大规模系统。</p><p><img src="/.com//.%5CsimpleMode.png" alt="simpleMode"></p><ul><li><strong>工作队列模式</strong>（Work Queues Mode）</li></ul><p>多个消费者同时从同一个队列中接收消息并进行处理，这种模式可以提高系统的并发能力和处理速度。</p><p><img src="/.com//.%5CworkQueueMode.png" alt="workQueueMode"></p><ul><li><strong>发布&#x2F;订阅模式</strong>（Publish&#x2F;Subscribe Mode）：</li></ul><p>生产者将消息发送到一个交换机，交换机将消息广播到所有订阅该交换机的队列，消费者从队列中接收消息并处理。这种模式适用于需要将消息广播到<strong>多个消费者</strong>的场景。</p><p><img src="/.com//.%5CsubscribeMode.png" alt="subscribeMode"></p><p>publish&#x2F;subscribe需要设置队列和交换机的绑定，work queues不需要设置，实际上work queues会将队列绑定到默认的交换机。</p><ul><li><strong>路由模式</strong>（Routing Mode）：</li></ul><p>生产者将消息发送到一个交换机，并指定一个<strong>路由键</strong>（routing key），交换机根据路由键将消息路由到对应的队列，消费者从队列中接收消息并处理。这种模式可以根据消息的内容进行有选择性的路由和消费。</p><p><img src="/.com//.%5CrouteMode.png" alt="routeMode"></p><p>如上图中，消费者c1所在队列制定了需要routing key 为 error 的消息，消费者c2所在队列制定了需要routing key为info、error、warning 的消息。</p><ul><li><strong>主题模式</strong>（Topic Mode）：</li></ul><p>生产者将消息发送到一个交换机，并指定一个<strong>主题</strong>（Topic），交换机根据主题将消息路由到对应的队列，消费者从队列中接收消息并处理。主题模式是路由模式的进一步扩展，可以根据消息的主题进行更加灵活的路由和消费。</p><p><img src="/.com//.%5CtopicMode.png" alt="topicMode"></p><p>路由键是一个字符串，它与队列之间的绑定关系由管理者进行配置。在路由模式中，<strong>队列的名称与路由键的绑定是一对一的关系</strong>。</p><p>主题是一个由一个或多个单词组成的字符串，单词之间用“.”（点号）分隔。主题中可以使用通配符“<em>”和“#”进行模糊匹配。“</em>”代表匹配一个单词，“#”代表匹配一个或多个单词。在主题模式中，队列的名称与主题的匹配关系由管理者进行配置。主题模式支持多对多的匹配关系，<strong>即一个队列可以绑定多个主题，一个主题也可以被多个队列绑定</strong>。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><strong>优点</strong><ol><li>高性能，能够处理大量的并发消息</li><li>易于配置和使用，提供了丰富的文档和管理界面</li><li>灵活的路由，能够根据不同的规则将消息分发到不同的队列</li><li>可靠性，支持持久化，确认机制，高可用等特性</li><li>多语言支持，提供了多种语言的客户端库</li></ol></li><li><strong>缺点</strong><ol><li>Erlang 依赖，需要安装 Erlang 环境才能运行 RabbitMQ</li><li>内存占用较高，当消息堆积时可能导致内存溢出或性能下降</li><li>集群管理复杂，需要手动配置集群节点和镜像队列</li><li>不支持延迟消息，需要借助死信队列或插件实现</li></ol></li></ul><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><h4 id="基本说明-1"><a href="#基本说明-1" class="headerlink" title="基本说明"></a>基本说明</h4><p>RocketMQ是一个纯Java、分布式、队列模型的开源消息中间件，前身是MetaQ，是阿里参考Kafka特点研发的一个队列模型的消息中间件，后开源给apache基金会成为了apache的顶级开源项目，具有高性能、高可靠、高实时、分布式特点。</p><h5 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h5><p><img src="/.com//.%5CRocketMQComponent.jpg" alt="RocketMQComponent"></p><p><strong>NameServer</strong>、<strong>Broker</strong>、<strong>Producer</strong>以及<strong>Consumer</strong>四部分</p><p>我们可以看到<strong>RocketMQ</strong>啥都是<strong>集群</strong>部署的，这是他<strong>吞吐量****大</strong>，<strong>高可用</strong>的原因之一，集群的模式也很花哨，可以支持多master 模式、多master多slave异步复制模式、多 master多slave同步双写模式。</p><p>由于其基于Kafaka 所以其模式和Kafaka差不多。</p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><strong>优点</strong><ol><li>支持事务消息，能够保证消息的最终一致性</li><li>支持顺序消息，能够按照指定的顺序消费消息</li><li>支持延迟消息，能够在指定的时间后发送或消费消息</li><li>支持批量发送和消费消息，提高吞吐量</li><li>支持多种部署模式，包括单机模式，集群模式和云原生模式</li></ol></li><li><strong>缺点</strong><ol><li>学习成本较高，需要掌握多种概念和组件</li><li>配置参数较多，需要根据业务场景进行调优</li><li>依赖外部存储系统（如Mysql）来存储元数据信息</li></ol></li></ul><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><h4 id="基本说明-2"><a href="#基本说明-2" class="headerlink" title="基本说明"></a>基本说明</h4><p>Kafka 是一个分布式的<strong>消息发布订阅系统</strong>，最初由 LinkedIn 公司开发，后来成为 Apache 项目的一部分。Kafka 可以处理高性能，高可靠性，高容量和高扩展性的数据流。支持多种消息模式，如发布&#x2F;订阅，请求&#x2F;响应和流式处理。提供了丰富的管理控制台来配置，监控和度量。</p><p><img src="/.com//.%5CkafkaComponents.png" alt="kafkaComponent"></p><h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><strong>优点</strong><ol><li>低延迟：Kafka 可以在 10 毫秒内处理消息，因为它解耦了消息，让消费者可以随时消费消息</li><li>高吞吐量：由于低延迟，Kafka 能够处理高速度和高容量的消息，每秒可以支持数千条消息</li><li>持久化：Kafka 可以将数据流持久化到磁盘中，并且可以根据需要保留数据一段时间</li><li>容错性：Kafka 可以通过分区和复制机制来实现容错性，并且可以在节点故障时自动恢复</li><li>零停机：Kafka 可以在不影响服务的情况下进行升级或扩展</li></ol></li><li><strong>缺点</strong><ol><li>学习成本较高：Kafka 需要掌握多种概念和组件，如生产者、消费者、主题、分区、偏移量、代理等</li><li>学习成本较高：Kafka 需要掌握多种概念和组件，如生产者、消费者、主题、分区、偏移量、代理等</li><li>依赖外部系统（如 ZooKeeper）来管理集群状态和元数据信息</li></ol></li></ul><h3 id="NSQ"><a href="#NSQ" class="headerlink" title="NSQ"></a>NSQ</h3><h4 id="基本说明-3"><a href="#基本说明-3" class="headerlink" title="基本说明"></a>基本说明</h4><p>NSQ 是一种基于 Go 语言的分布式实时消息平台，它具有分布式、去中心化的拓扑结构，支持无限水平扩展。无单点故障、故障容错、高可用性以及能够保证消息的可靠传递的特征</p><p><strong>NSQ组件</strong></p><ol><li><code>nqsd</code>：NSQ的主要组件，负责接收、排队和传递消息。nsqd在节点之间形成一个分布式的消息传递系统，并能够处理消息的持久化、重新排队、故障恢复等操作。一个守护进程。</li><li><code>nsqlookupd</code>：管理拓扑信息，其实就是围绕 nsqd 的<strong>发现服务</strong>，因为其存储了 nsqd 节点的注册信息，所以通过它就可以查询到指定 topic 主题的 nsqd 节点。（可选）</li><li><code>nsqadmin</code>：NSQ的Web管理界面，用于查看、管理和监控集群中的主题、通道、生产者和消费者等信息。nsqadmin提供了直观的界面和实用的功能，如停止、暂停和重启主题、通道等。</li><li><code>utilities</code>：封装好的常用的工具。</li></ol><p><img src="/.com//.%5CnsqCompononent.png" alt="nsqCompononent"></p><p>通过 nsqadmin 可以看到整个集群的统计信息并进行管理，多个 nsqd 节点组成集群并将其基本信息注册到 nsqlookupd 中，通过 nsqlookupd 可以寻址到具体的 nsqd 节点，而不论是消息的生产者还是消费者，其本质上都是与 nsqd 进行通信。</p><h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><strong>优点</strong><ol><li>部署简单，配置极简</li><li>支持无限水平扩展，无单点故障</li><li>支持多种消息协议，如http、tcp、websocket等</li><li>支持消息重试和延迟投递</li><li>支持数据备份和恢复</li></ol></li><li><strong>缺点</strong><ol><li>消费者端不好做流控，很难做批量推送</li><li>消费者可能经常有空 pull，即 pull 不到消息，造成浪费</li><li>不支持事务和顺序消费</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在消息队列系统中，空pull通常指消费者向消息队列发送拉取消息的请求，但由于当前没有可用的消息，消息队列会返回一个空响应。消费者接收到空响应后，会重新发送拉取消息的请求，直到有新消息可用为止</span><br></pre></td></tr></table></figure><h2 id="RabbitMQ-Go"><a href="#RabbitMQ-Go" class="headerlink" title="RabbitMQ+Go"></a>RabbitMQ+Go</h2><h3 id="“Hello-World”"><a href="#“Hello-World”" class="headerlink" title="“Hello World”"></a>“Hello World”</h3><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><ul><li><p><strong>辅助函数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助函数用来检查每个amqp调用的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">failOnError</span><span class="params">(err <span class="type">error</span>, msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">&quot;%s: %s&quot;</span>, msg, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>连接</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 尝试连接RabbitMQ，建立连接</span></span><br><span class="line"><span class="comment">// 该连接抽象了套接字连接，并为我们处理协议版本协商和认证等。</span></span><br><span class="line">conn, err := amqp.Dial(<span class="string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to connect to RabbitMQ&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br></pre></td></tr></table></figure></li><li><p><strong>创建通道</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 创建一个通道，大多数API都是用过该通道操作的。</span></span><br><span class="line">ch, err := conn.Channel()</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to open a channel&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> ch.Close()</span><br></pre></td></tr></table></figure></li><li><p><strong>声明队列</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 声明消息要发送到的队列</span></span><br><span class="line">q, err := ch.QueueDeclare(</span><br><span class="line">  <span class="string">&quot;hello&quot;</span>, <span class="comment">// name</span></span><br><span class="line">  <span class="literal">false</span>,   <span class="comment">// durable</span></span><br><span class="line">  <span class="literal">false</span>,   <span class="comment">// delete when unused</span></span><br><span class="line">  <span class="literal">false</span>,   <span class="comment">// exclusive</span></span><br><span class="line">  <span class="literal">false</span>,   <span class="comment">// no-wait</span></span><br><span class="line">  <span class="literal">nil</span>,     <span class="comment">// arguments</span></span><br><span class="line">)</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to declare a queue&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>发送消息</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.将消息发布到声明的队列</span></span><br><span class="line">body := <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line"></span><br><span class="line">err = ch.Publish(</span><br><span class="line">  <span class="string">&quot;&quot;</span>,     <span class="comment">// exchange</span></span><br><span class="line">  q.Name, <span class="comment">// routing key</span></span><br><span class="line">  <span class="literal">false</span>,  <span class="comment">// mandatory</span></span><br><span class="line">  <span class="literal">false</span>,  <span class="comment">// immediate</span></span><br><span class="line">  amqp.Publishing &#123;</span><br><span class="line">    ContentType: <span class="string">&quot;text/plain&quot;</span>,</span><br><span class="line">    Body:        []<span class="type">byte</span>(body),</span><br><span class="line">  &#125;)</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to publish a message&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>连接、创建通道和声明队列的操作相同</p><ul><li><p><strong>接受消息</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收消息</span></span><br><span class="line">msgs, err := ch.Consume(</span><br><span class="line">  q.Name, <span class="comment">// queue</span></span><br><span class="line">  <span class="string">&quot;&quot;</span>,     <span class="comment">// consumer</span></span><br><span class="line">  <span class="literal">true</span>,   <span class="comment">// auto-ack</span></span><br><span class="line">  <span class="literal">false</span>,  <span class="comment">// exclusive</span></span><br><span class="line">  <span class="literal">false</span>,  <span class="comment">// no-local</span></span><br><span class="line">  <span class="literal">false</span>,  <span class="comment">// no-wait</span></span><br><span class="line">  <span class="literal">nil</span>,    <span class="comment">// args</span></span><br><span class="line">)</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to register a consumer&quot;</span>)</span><br><span class="line"></span><br><span class="line">forever := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;Received a message: %s&quot;</span>, d.Body)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>)</span><br><span class="line">&lt;-forever</span><br></pre></td></tr></table></figure></li></ul><h3 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h3><p>工作队列（又称任务队列）的主要思想是避免立即执行某些<strong>资源密集型任务</strong>并且不得不等待这些任务完成。相反，我们安排任务<strong>异步</strong>地同时或在当前任务之后完成。我们将任务封装为消息并将其发送到队列，在后台运行的工作进程将取出消息并最终执行任务。当你运行多个工作进程时，任务将在他们之间共享。</p><p>这里借助<code>time.Sleep</code>函数模拟一些比较耗时的任务。我们会将一些包含<code>.</code>的字符串封装为消息发送到队列中，其中每有一个<code>.</code>就表示需要耗费1秒钟的工作，例如，<code>hello...</code>表示一个将花费三秒钟的假任务。</p><h4 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h4><ul><li><strong>send.go—&gt;new_task.go</strong></li></ul><p><code>DeliveryMode</code>表示消息的持久化级别。 1-消息进保存在内存中 2-消息将持久化到硬盘上</p><p>如果设置了消息的<code>DeliveryMode</code>为2，即使RabbitMQ服务器在发送消息之前崩溃，消息也不会丢失，并在服务器重新启动后重新加载到队列中。</p><p>但是将<code>DeliveryMode</code>设置为2可能会影响RabbitMQ的性能，因为需要将小心写入磁盘。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">body := bodyFrom(os.Args)  <span class="comment">// 从参数中获取要发送的消息正文</span></span><br><span class="line">err = ch.Publish(</span><br><span class="line">  <span class="string">&quot;&quot;</span>,           <span class="comment">// exchange</span></span><br><span class="line">  q.Name,       <span class="comment">// routing key</span></span><br><span class="line">  <span class="literal">false</span>,        <span class="comment">// mandatory</span></span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  amqp.Publishing &#123;</span><br><span class="line">    DeliveryMode: amqp.Persistent,  </span><br><span class="line">    ContentType:  <span class="string">&quot;text/plain&quot;</span>,</span><br><span class="line">    Body:         []<span class="type">byte</span>(body),</span><br><span class="line">  &#125;)</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to publish a message&quot;</span>)</span><br><span class="line">log.Printf(<span class="string">&quot; [x] Sent %s&quot;</span>, body)</span><br></pre></td></tr></table></figure><ul><li><strong>bodyFrom函数</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bodyFrom</span><span class="params">(args []<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(args) &lt; <span class="number">2</span>) || os.Args[<span class="number">1</span>] == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        s = <span class="string">&quot;hello&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s = strings.Join(args[<span class="number">1</span>:], <span class="string">&quot; &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>receive.go—&gt;worker.go</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">msgs, err := ch.Consume(</span><br><span class="line">  q.Name, <span class="comment">// queue</span></span><br><span class="line">  <span class="string">&quot;&quot;</span>,     <span class="comment">// consumer</span></span><br><span class="line">  <span class="literal">true</span>,   <span class="comment">// auto-ack</span></span><br><span class="line">  <span class="literal">false</span>,  <span class="comment">// exclusive</span></span><br><span class="line">  <span class="literal">false</span>,  <span class="comment">// no-local</span></span><br><span class="line">  <span class="literal">false</span>,  <span class="comment">// no-wait</span></span><br><span class="line">  <span class="literal">nil</span>,    <span class="comment">// args</span></span><br><span class="line">)</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to register a consumer&quot;</span>)</span><br><span class="line"></span><br><span class="line">forever := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;Received a message: %s&quot;</span>, d.Body)</span><br><span class="line">    dot_count := bytes.Count(d.Body, []<span class="type">byte</span>(<span class="string">&quot;.&quot;</span>))  <span class="comment">// 数一下有几个.</span></span><br><span class="line">    t := time.Duration(dot_count)</span><br><span class="line">    time.Sleep(t * time.Second)  <span class="comment">// 模拟耗时的任务</span></span><br><span class="line">    log.Printf(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>)</span><br><span class="line">&lt;-forever</span><br></pre></td></tr></table></figure><h4 id="循环调度"><a href="#循环调度" class="headerlink" title="循环调度"></a>循环调度</h4><p>使用任务队列的优点之一是能够轻松并行化工作。如果我们的工作正在积压，我们可以增加更多的工人，这样就可以轻松扩展。</p><p>现在，同时运行两个<code>worker.go</code>脚本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">shell 1</span></span><br><span class="line">go run worker.go</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=&gt; [*] Waiting <span class="keyword">for</span> messages. To <span class="built_in">exit</span> press CTRL+C</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">shell 2</span></span><br><span class="line">go run worker.go</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=&gt; [*] Waiting <span class="keyword">for</span> messages. To <span class="built_in">exit</span> press CTRL+C</span></span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">shell 1</span></span><br><span class="line">go run worker.go</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=&gt; [*] Waiting <span class="keyword">for</span> messages. To <span class="built_in">exit</span> press CTRL+C</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=&gt; [x] Received a message: msg1.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=&gt; [x] Received a message: msg3...</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=&gt; [x] Received a message: msg5.....</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">shell 2</span></span><br><span class="line">go run worker.go</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=&gt; [*] Waiting <span class="keyword">for</span> messages. To <span class="built_in">exit</span> press CTRL+C</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=&gt; [x] Received a message: msg2..</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=&gt; [x] Received a message: msg4....</span></span><br></pre></td></tr></table></figure><p>默认情况下，RabbitMQ将按顺序将每个消息发送给下一个消费者。平均而言，每个消费者都会收到相同数量的消息。这种分发消息的方式称为轮询。</p><h4 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h4><p>worker完成惹怒我可能需要耗费几秒钟，如果一个<code>worker</code>在任务执行过程中宕机，在当前的代码中RabbitMQ一旦向消费者传递消息，便立即将其标记为删除。这种情况下，如果终止一个<code>worker</code>那么就可能丢失这个任务，还将丢失所有已经交付给这个<code>worker</code>的尚未处理的消息。</p><p>如果我们不想丢失任何一个任务，如果一个<code>worker</code>挂了，我们希望将任务交付给其他<code>worker</code>来处理</p><p>为了确保消息永不丢失。RabbitMQ支持<strong>消息确认</strong>。消费者返回一个确认（acknowledge），以告知RabbitMQ已经接受，处理了特定的消息，并且RabbitMQ可以自由的删除它。</p><p>如果使用者在不发送确认的情况下死亡（其通道关闭，连接关闭或者TCP连接丢失）RabbitMQ将了解消息未完全处理，并将对其重新排队。如果同时有其他消费者在线，它将很快将其重新分发给另一个消费者。</p><p>消费者返回消息确认强制实施超时（默认30分钟），有助于检测不返回消息确认的异常的消费者。</p><p>这里使用手动消息确认，方法是为”<strong>auto-ack</strong>“参数传递一个false，然后在完成任务后，使用<code>d.Ack(fakse)</code>从<code>worker</code>发送一个正确的确认。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">msgs, err := ch.Consume(</span><br><span class="line">  q.Name, <span class="comment">// queue</span></span><br><span class="line">  <span class="string">&quot;&quot;</span>,     <span class="comment">// consumer</span></span><br><span class="line">  <span class="literal">false</span>,  <span class="comment">// auto-ack</span></span><br><span class="line">  <span class="literal">false</span>,  <span class="comment">// exclusive</span></span><br><span class="line">  <span class="literal">false</span>,  <span class="comment">// no-local</span></span><br><span class="line">  <span class="literal">false</span>,  <span class="comment">// no-wait</span></span><br><span class="line">  <span class="literal">nil</span>,    <span class="comment">// args</span></span><br><span class="line">)</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to register a consumer&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> forever <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;Received a message: %s&quot;</span>, d.Body)</span><br><span class="line">    dotCount := bytes.Count(d.Body, []<span class="type">byte</span>(<span class="string">&quot;.&quot;</span>))</span><br><span class="line">    t := time.Duration(dotCount)</span><br><span class="line">    time.Sleep(t * time.Second)</span><br><span class="line">    log.Printf(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">    d.Ack(<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>)</span><br><span class="line">&lt;-forever</span><br></pre></td></tr></table></figure><p>使用这段代码，可以确保即使在处理消息时使用<code>CTRL+C</code>杀死一个<code>worker</code>，也不会丢失任何内容。在<code>worker</code>死后不久，所有未确认的消息都将被重新发送。</p><p>消息确认必须在接收消息的同一通道（Channel）上发送。尝试使用不同的通道（Channel）进行消息确认将导致通道级协议异常。</p><ul><li><strong>忘记确认</strong></li></ul><p>忘记确认是一个常见的错误。这是一个简单的错误，但后果是严重的。当你的客户机退出时，消息将被重新传递（这看起来像随机重新传递），但是RabbitMQ将消耗越来越多的内存，因为它无法释放任何未确认的消息。</p><p>为了调试这种错误，可以使用rabbitmqctl打印messages_unacknowledged字段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_queues name messages_ready messages_unacknowledged</span><br></pre></td></tr></table></figure><ul><li><strong>持久化</strong></li></ul><p>我们已经学会了如何确保即使消费者死亡，任务也不会丢失。但是如果RabbitMQ服务器停止运行，我们的任务仍然会丢失。</p><p>当RabbitMQ退出或崩溃时，它将忘记队列和消息，除非您告诉它不要这样做。要确保消息不会丢失，需要做两件事：我们需要将队列和消息都标记为持久的。</p><p>首先，我们需要确保队列能够在RabbitMQ节点重新启动后继续运行。为此，我们需要声明它是持久的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明队列时</span></span><br><span class="line">q, err := ch.QueueDeclare(</span><br><span class="line"><span class="string">&quot;hello&quot;</span>, <span class="comment">// name</span></span><br><span class="line"><span class="literal">true</span>,    <span class="comment">// 声明为持久队列</span></span><br><span class="line"><span class="literal">false</span>,   <span class="comment">// delete when unused</span></span><br><span class="line"><span class="literal">false</span>,   <span class="comment">// exclusive</span></span><br><span class="line"><span class="literal">false</span>,   <span class="comment">// no-wait</span></span><br><span class="line"><span class="literal">nil</span>,     <span class="comment">// arguments</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>虽然这个命令本身是正确的，但它在我们当前的设置中不起作用。这是因为我们已经定义了一个名为<code>hello</code>的队列，它不是持久的。<strong>RabbitMQ不允许你使用不同的参数重新定义现有队列，并将向任何尝试重新定义的程序返回错误。</strong>但是有一个快速的解决方法——让我们声明一个具有不同名称的队列，例如<code>task_queue</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">q, err := ch.QueueDeclare(</span><br><span class="line"><span class="string">&quot;task_queue&quot;</span>, <span class="comment">// name</span></span><br><span class="line"><span class="literal">true</span>,         <span class="comment">// 声明为持久队列</span></span><br><span class="line"><span class="literal">false</span>,        <span class="comment">// delete when unused</span></span><br><span class="line"><span class="literal">false</span>,        <span class="comment">// exclusive</span></span><br><span class="line"><span class="literal">false</span>,        <span class="comment">// no-wait</span></span><br><span class="line"><span class="literal">nil</span>,          <span class="comment">// arguments</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这种持久的选项更改需要<strong>同时</strong>应用于生产者代码和消费者代码。</p><p>现在，我们确信即使RabbitMQ重新启动，任务<strong>队列</strong>也不会丢失。</p><p>现在我们需要将<strong>消息</strong>标记为持久的——通过使用<code>amqp.Publishing</code>中的持久性选项<code>amqp.Persistent</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">err = ch.Publish(</span><br><span class="line"><span class="string">&quot;&quot;</span>,     <span class="comment">// exchange</span></span><br><span class="line">q.Name, <span class="comment">// routing key</span></span><br><span class="line"><span class="literal">false</span>,  <span class="comment">// 立即</span></span><br><span class="line"><span class="literal">false</span>,  <span class="comment">// 强制</span></span><br><span class="line">amqp.Publishing&#123;</span><br><span class="line">DeliveryMode: amqp.Persistent, <span class="comment">// 持久（交付模式：瞬态/持久）</span></span><br><span class="line">ContentType:  <span class="string">&quot;text/plain&quot;</span>,</span><br><span class="line">Body:         []<span class="type">byte</span>(body),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="公平分发"><a href="#公平分发" class="headerlink" title="公平分发"></a>公平分发</h4><p>在一个有两个<code>worker</code>的情况下，假设所有的奇数消息都是重消息，而偶数消息都是轻消息时，一个<code>worker</code>将持续忙碌，而另一个<code>worker</code>几乎不做任何工作。而RabbitMQ对此一无所知，仍然会均匀地发送消息。</p><p>为了避免这种情况，我们可以将预取计数设置为<code>1</code>。这告诉RabbitMQ不要一次向一个<code>worker</code>发出多个消息。或者，换句话说，在处理并确认前一条消息之前，不要向<code>worker</code>发送新消息。相反，它将把它发送给下一个不忙的<code>worker</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">err = ch.Qos(</span><br><span class="line">  <span class="number">1</span>,     <span class="comment">// prefetch count</span></span><br><span class="line">  <span class="number">0</span>,     <span class="comment">// prefetch size</span></span><br><span class="line">  <span class="literal">false</span>, <span class="comment">// global</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="完整代码示例"><a href="#完整代码示例" class="headerlink" title="完整代码示例"></a>完整代码示例</h4><ul><li>new_task.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/streadway/amqp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 尝试连接RabbitMQ，建立连接</span></span><br><span class="line"><span class="comment">// 该连接抽象了套接字连接，并为我们处理协议版本协商和认证等。</span></span><br><span class="line">conn, err := amqp.Dial(<span class="string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;connect to RabbitMQ failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 接下来，我们创建一个通道，大多数API都是用过该通道操作的。</span></span><br><span class="line">ch, err := conn.Channel()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;open a channel failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> ch.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 要发送，我们必须声明要发送到的队列。</span></span><br><span class="line">q, err := ch.QueueDeclare(</span><br><span class="line"><span class="string">&quot;task_queue&quot;</span>, <span class="comment">// name</span></span><br><span class="line"><span class="literal">true</span>,         <span class="comment">// 持久的</span></span><br><span class="line"><span class="literal">false</span>,        <span class="comment">// delete when unused</span></span><br><span class="line"><span class="literal">false</span>,        <span class="comment">// 独有的</span></span><br><span class="line"><span class="literal">false</span>,        <span class="comment">// no-wait</span></span><br><span class="line"><span class="literal">nil</span>,          <span class="comment">// arguments</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;declare a queue failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 然后我们可以将消息发布到声明的队列</span></span><br><span class="line">body := bodyFrom(os.Args)</span><br><span class="line">err = ch.Publish(</span><br><span class="line"><span class="string">&quot;&quot;</span>,     <span class="comment">// exchange</span></span><br><span class="line">q.Name, <span class="comment">// routing key</span></span><br><span class="line"><span class="literal">false</span>,  <span class="comment">// 立即</span></span><br><span class="line"><span class="literal">false</span>,  <span class="comment">// 强制</span></span><br><span class="line">amqp.Publishing&#123;</span><br><span class="line">DeliveryMode: amqp.Persistent, <span class="comment">// 持久</span></span><br><span class="line">ContentType:  <span class="string">&quot;text/plain&quot;</span>,</span><br><span class="line">Body:         []<span class="type">byte</span>(body),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;publish a message failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot; [x] Sent %s&quot;</span>, body)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bodyFrom 从命令行获取将要发送的消息内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bodyFrom</span><span class="params">(args []<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">len</span>(args) &lt; <span class="number">2</span>) || os.Args[<span class="number">1</span>] == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">s = <span class="string">&quot;hello&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s = strings.Join(args[<span class="number">1</span>:], <span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>work.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/streadway/amqp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">conn, err := amqp.Dial(<span class="string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;connect to RabbitMQ failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">ch, err := conn.Channel()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;open a channel failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> ch.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个queue</span></span><br><span class="line">q, err := ch.QueueDeclare(</span><br><span class="line"><span class="string">&quot;task_queue&quot;</span>, <span class="comment">// name</span></span><br><span class="line"><span class="literal">true</span>,         <span class="comment">// 声明为持久队列</span></span><br><span class="line"><span class="literal">false</span>,        <span class="comment">// delete when unused</span></span><br><span class="line"><span class="literal">false</span>,        <span class="comment">// exclusive</span></span><br><span class="line"><span class="literal">false</span>,        <span class="comment">// no-wait</span></span><br><span class="line"><span class="literal">nil</span>,          <span class="comment">// arguments</span></span><br><span class="line">)</span><br><span class="line">err = ch.Qos(</span><br><span class="line"><span class="number">1</span>,     <span class="comment">// prefetch count</span></span><br><span class="line"><span class="number">0</span>,     <span class="comment">// prefetch size</span></span><br><span class="line"><span class="literal">false</span>, <span class="comment">// global</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;ch.Qos() failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即返回一个Delivery的通道</span></span><br><span class="line">msgs, err := ch.Consume(</span><br><span class="line">q.Name, <span class="comment">// queue</span></span><br><span class="line"><span class="string">&quot;&quot;</span>,     <span class="comment">// consumer</span></span><br><span class="line"><span class="literal">false</span>,  <span class="comment">// 注意这里传false,关闭自动消息确认</span></span><br><span class="line"><span class="literal">false</span>,  <span class="comment">// exclusive</span></span><br><span class="line"><span class="literal">false</span>,  <span class="comment">// no-local</span></span><br><span class="line"><span class="literal">false</span>,  <span class="comment">// no-wait</span></span><br><span class="line"><span class="literal">nil</span>,    <span class="comment">// args</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;ch.Consume failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启循环不断地消费消息</span></span><br><span class="line">forever := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Received a message: %s&quot;</span>, d.Body)</span><br><span class="line">dotCount := bytes.Count(d.Body, []<span class="type">byte</span>(<span class="string">&quot;.&quot;</span>))</span><br><span class="line">t := time.Duration(dotCount)</span><br><span class="line">time.Sleep(t * time.Second)</span><br><span class="line">log.Printf(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">d.Ack(<span class="literal">false</span>) <span class="comment">// 手动传递消息确认</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>)</span><br><span class="line">&lt;-forever</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发布-x2F-订阅"><a href="#发布-x2F-订阅" class="headerlink" title="发布&#x2F;订阅"></a>发布&#x2F;订阅</h3><h4 id="交换器"><a href="#交换器" class="headerlink" title="交换器"></a>交换器</h4><p>RabbitMQ消息传递模型中的核心思想是生产者从不将任何消息<strong>直接</strong>发送到队列。实际上，生产者经常甚至根本不知道是否将消息传递到任何队列。</p><p>相反，生产者只能将消息发送到<strong>交换器</strong>。交换器是非常简单的东西。一方面，它接收来自生产者的消息，另一方面，将它们推入队列。</p><p><strong>交换器的类型</strong></p><ul><li>direct</li><li>topic</li><li>headers</li><li>fanout</li></ul><p>现在定义一个<code>fanout</code>类型的交换器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">err = ch.ExchangeDeclare(</span><br><span class="line">  <span class="string">&quot;logs&quot;</span>,   <span class="comment">// name</span></span><br><span class="line">  <span class="string">&quot;fanout&quot;</span>, <span class="comment">// type</span></span><br><span class="line">  <span class="literal">true</span>,     <span class="comment">// durable</span></span><br><span class="line">  <span class="literal">false</span>,    <span class="comment">// auto-deleted</span></span><br><span class="line">  <span class="literal">false</span>,    <span class="comment">// internal</span></span><br><span class="line">  <span class="literal">false</span>,    <span class="comment">// no-wait</span></span><br><span class="line">  <span class="literal">nil</span>,      <span class="comment">// arguments</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>fanout</code>（扇出）交换器非常简单。它只是将接收到的所有消息广播到它知道的所有队列中。而这正是我们记录器所需要的。</p><p><strong>交换器清单</strong></p><p>要列出服务器上的交换器，可以使用rabbitmqctl</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabitmqctl list_exchanges</span><br></pre></td></tr></table></figure><h4 id="发布消息"><a href="#发布消息" class="headerlink" title="发布消息"></a><strong>发布消息</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">err = ch.ExchangeDeclare(</span><br><span class="line">  <span class="string">&quot;logs&quot;</span>,   <span class="comment">// 使用命名的交换器</span></span><br><span class="line">  <span class="string">&quot;fanout&quot;</span>, <span class="comment">// 交换器类型</span></span><br><span class="line">  <span class="literal">true</span>,     <span class="comment">// durable</span></span><br><span class="line">  <span class="literal">false</span>,    <span class="comment">// auto-deleted</span></span><br><span class="line">  <span class="literal">false</span>,    <span class="comment">// internal</span></span><br><span class="line">  <span class="literal">false</span>,    <span class="comment">// no-wait</span></span><br><span class="line">  <span class="literal">nil</span>,      <span class="comment">// arguments</span></span><br><span class="line">)</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to declare an exchange&quot;</span>)</span><br><span class="line"></span><br><span class="line">body := bodyFrom(os.Args)</span><br><span class="line">err = ch.Publish(</span><br><span class="line">  <span class="string">&quot;logs&quot;</span>, <span class="comment">// exchange</span></span><br><span class="line">  <span class="string">&quot;&quot;</span>,     <span class="comment">// routing key</span></span><br><span class="line">  <span class="literal">false</span>,  <span class="comment">// mandatory</span></span><br><span class="line">  <span class="literal">false</span>,  <span class="comment">// immediate</span></span><br><span class="line">  amqp.Publishing&#123;</span><br><span class="line">          ContentType: <span class="string">&quot;text/plain&quot;</span>,</span><br><span class="line">          Body:        []<span class="type">byte</span>(body),</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h4 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h4><p>我们希望收到所有日志消息，而不仅仅是它们的一部分。我们也只对当前正在发送的消息感兴趣，而对旧消息不感兴趣。为了解决这个问题，我们需要两件事。</p><p>首先，当我们连接到Rabbit时，我们需要一个新的、空的队列。为此，我们可以创建一个随机名称的队列，或者更好的方法是让服务器为我们选择一个随机队列名称。</p><p>其次，<strong>一旦我们断开消费者的连接，队列就会自动删除</strong>。</p><p>在<code>amqp</code>客户端中，当我们传递一个空字符串作为队列名称时，我们将使用随机生成的名称创建一个非持久的队列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">q, err := ch.QueueDeclare(</span><br><span class="line">  <span class="string">&quot;&quot;</span>,    <span class="comment">// 空字符串作为队列名称</span></span><br><span class="line">  <span class="literal">false</span>, <span class="comment">// 非持久队列</span></span><br><span class="line">  <span class="literal">false</span>, <span class="comment">// delete when unused</span></span><br><span class="line">  <span class="literal">true</span>,  <span class="comment">// 独占队列（当前声明队列的连接关闭后即被删除）</span></span><br><span class="line">  <span class="literal">false</span>, <span class="comment">// no-wait</span></span><br><span class="line">  <span class="literal">nil</span>,   <span class="comment">// arguments</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>述方法返回时，生成的队列实例包含RabbitMQ生成的随机队列名称。例如，它可能看起来像<code>amq.gen-JzTY20BRgKO-HjmUJj0wLg</code>。</p><p>当声明它的连接关闭时，该队列将被删除，因为它被声明为独占。</p><h4 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h4><p><img src="/.com//.%5Cbindings.png" alt="bingdings"></p><p>我们已经创建了一个扇出交换器和一个队列。现在我们需要告诉交换器将消息发送到我们的队列。交换器和队列之间的关系称为<strong>绑定</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">err = ch.QueueBind(</span><br><span class="line">  q.Name, <span class="comment">// queue name</span></span><br><span class="line">  <span class="string">&quot;&quot;</span>,     <span class="comment">// routing key</span></span><br><span class="line">  <span class="string">&quot;logs&quot;</span>, <span class="comment">// exchange</span></span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">nil</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果没有队列绑定到交换器，那么消息将丢失，但这对我们来说是ok的。如果没有消费者在接收，我们可以安全地丢弃该消息。</p><p><strong>列出绑定关系</strong></p><p>可以使用<code>rabbitmqctl</code>指令列出绑定关系</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_bindings</span><br></pre></td></tr></table></figure><h4 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h4><p><code>receive.go</code>的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;github.com/streadway/amqp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">failOnError</span><span class="params">(err <span class="type">error</span>, msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatalf(<span class="string">&quot;%s: %s&quot;</span>, msg, err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        conn, err := amqp.Dial(<span class="string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)</span><br><span class="line">        failOnError(err, <span class="string">&quot;Failed to connect to RabbitMQ&quot;</span>)</span><br><span class="line">        <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">        ch, err := conn.Channel()</span><br><span class="line">        failOnError(err, <span class="string">&quot;Failed to open a channel&quot;</span>)</span><br><span class="line">        <span class="keyword">defer</span> ch.Close()</span><br><span class="line"></span><br><span class="line">        err = ch.ExchangeDeclare(</span><br><span class="line">                <span class="string">&quot;logs&quot;</span>,   <span class="comment">// name</span></span><br><span class="line">                <span class="string">&quot;fanout&quot;</span>, <span class="comment">// type</span></span><br><span class="line">                <span class="literal">true</span>,     <span class="comment">// durable</span></span><br><span class="line">                <span class="literal">false</span>,    <span class="comment">// auto-deleted</span></span><br><span class="line">                <span class="literal">false</span>,    <span class="comment">// internal</span></span><br><span class="line">                <span class="literal">false</span>,    <span class="comment">// no-wait</span></span><br><span class="line">                <span class="literal">nil</span>,      <span class="comment">// arguments</span></span><br><span class="line">        )</span><br><span class="line">        failOnError(err, <span class="string">&quot;Failed to declare an exchange&quot;</span>)</span><br><span class="line"></span><br><span class="line">        q, err := ch.QueueDeclare(</span><br><span class="line">                <span class="string">&quot;&quot;</span>,    <span class="comment">// name</span></span><br><span class="line">                <span class="literal">false</span>, <span class="comment">// durable</span></span><br><span class="line">                <span class="literal">false</span>, <span class="comment">// delete when unused</span></span><br><span class="line">                <span class="literal">true</span>,  <span class="comment">// exclusive</span></span><br><span class="line">                <span class="literal">false</span>, <span class="comment">// no-wait</span></span><br><span class="line">                <span class="literal">nil</span>,   <span class="comment">// arguments</span></span><br><span class="line">        )</span><br><span class="line">        failOnError(err, <span class="string">&quot;Failed to declare a queue&quot;</span>)</span><br><span class="line"></span><br><span class="line">        err = ch.QueueBind(</span><br><span class="line">                q.Name, <span class="comment">// queue name</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>,     <span class="comment">// routing key</span></span><br><span class="line">                <span class="string">&quot;logs&quot;</span>, <span class="comment">// exchange</span></span><br><span class="line">                <span class="literal">false</span>,</span><br><span class="line">                <span class="literal">nil</span>,</span><br><span class="line">        )</span><br><span class="line">        failOnError(err, <span class="string">&quot;Failed to bind a queue&quot;</span>)</span><br><span class="line"></span><br><span class="line">        msgs, err := ch.Consume(</span><br><span class="line">                q.Name, <span class="comment">// queue</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>,     <span class="comment">// consumer</span></span><br><span class="line">                <span class="literal">true</span>,   <span class="comment">// auto-ack</span></span><br><span class="line">                <span class="literal">false</span>,  <span class="comment">// exclusive</span></span><br><span class="line">                <span class="literal">false</span>,  <span class="comment">// no-local</span></span><br><span class="line">                <span class="literal">false</span>,  <span class="comment">// no-wait</span></span><br><span class="line">                <span class="literal">nil</span>,    <span class="comment">// args</span></span><br><span class="line">        )</span><br><span class="line">        failOnError(err, <span class="string">&quot;Failed to register a consumer&quot;</span>)</span><br><span class="line"></span><br><span class="line">        forever := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">                        log.Printf(<span class="string">&quot; [x] %s&quot;</span>, d.Body)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        log.Printf(<span class="string">&quot; [*] Waiting for logs. To exit press CTRL+C&quot;</span>)</span><br><span class="line">        &lt;-forever</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要将日志保存到文件，只需打开控制台并输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run receive_logs.go &gt; logs_from_rabbit.log</span><br></pre></td></tr></table></figure><ul><li><p>注意程序本身将日志输出到标准错误流（stderr），而不是标准输出流（stdout）。使用 “&gt; log” 只会重定向标准输出流，因此程序仍然将日志输出到终端。要同时重定向标准错误流和标准输出流，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run receive_logs.go &gt; logs_from_rabbit.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure></li></ul><p>使用<code>rabbitmqctl list_bindings</code>命令，可以验证代码是否确实根据需要创建了绑定关系和队列。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmqctl list_bindings</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=&gt; Listing bindings ...</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=&gt; logs    exchange        amq.gen-JzTY20BRgKO-HjmUJj0wLg  queue           []</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=&gt; logs    exchange        amq.gen-vso0PVvyiRIL2WoV3i48Yg  queue           []</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">=&gt; ...<span class="keyword">done</span>.</span></span><br></pre></td></tr></table></figure><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h4 id="绑定-1"><a href="#绑定-1" class="headerlink" title="绑定"></a><strong>绑定</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">err = ch.QueueBind(</span><br><span class="line">  q.Name, <span class="comment">// queue name</span></span><br><span class="line">  <span class="string">&quot;&quot;</span>,     <span class="comment">// routing key</span></span><br><span class="line">  <span class="string">&quot;logs&quot;</span>, <span class="comment">// exchange</span></span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>绑定是交换器和队列之间的关系。可以简单理解为：队列对来自此交换器的信息感兴趣。</p><p>绑定可以采用额外的<code>routing_key</code>参数。为了避免与<code>Channel.Publish</code>参数混淆，我们将其称为<code>binding key</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建绑定</span></span><br><span class="line">err = ch.QueueBind(</span><br><span class="line">  q.Name,    <span class="comment">// queue name</span></span><br><span class="line">  <span class="string">&quot;black&quot;</span>,   <span class="comment">// routing key</span></span><br><span class="line">  <span class="string">&quot;logs&quot;</span>,    <span class="comment">// exchange</span></span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h4 id="直连交换器"><a href="#直连交换器" class="headerlink" title="直连交换器"></a><strong>直连交换器</strong></h4><p>在之前的日志系统的基础上，希望实现根据消息的严重性过滤消息。例如，我们可能希望将日志消息写入磁盘的脚本只接收严重错误，而不会在warning或info日志消息上浪费磁盘空间。</p><p>使用<code>direct</code>交换器。<code>direct</code>交换器背后的路由算法很简单——消息进入其<code>binding key</code>与消息的<code>routing key</code>完全匹配的队列。</p><p><img src="/.com//.%5Cdirect-exchange.png" alt="directExchange"></p><p>在此设置中，我们可以看到绑定了两个队列的<code>direct</code>交换器<code>X</code>。第一个队列绑定键为<code>orange</code>，第二个队列绑定为两个，一个绑定键为<code>black</code>，另一个为<code>green</code>。</p><p>在这种设置中，使用<code>orange</code>路由键发布到交换器的消息将被路由到队列<code>Q1</code>。路由键为<code>black</code>或<code>green</code>的消息将转到<code>Q2</code>。所有其他消息将被丢弃。</p><h4 id="多重绑定"><a href="#多重绑定" class="headerlink" title="多重绑定"></a><strong>多重绑定</strong></h4><p><img src="/.com//.%5Cdirect-exchange-multiple.png" alt="direct-exchange-multiple"></p><p>用相同的绑定键绑定多个队列是完全合法的。</p><h4 id="发送日志"><a href="#发送日志" class="headerlink" title="发送日志"></a><strong>发送日志</strong></h4><p>创建一个交换器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">err = ch.ExchangeDeclare(</span><br><span class="line">  <span class="string">&quot;logs_direct&quot;</span>, <span class="comment">// name</span></span><br><span class="line">  <span class="string">&quot;direct&quot;</span>,      <span class="comment">// type</span></span><br><span class="line">  <span class="literal">true</span>,          <span class="comment">// durable</span></span><br><span class="line">  <span class="literal">false</span>,         <span class="comment">// auto-deleted</span></span><br><span class="line">  <span class="literal">false</span>,         <span class="comment">// internal</span></span><br><span class="line">  <span class="literal">false</span>,         <span class="comment">// no-wait</span></span><br><span class="line">  <span class="literal">nil</span>,           <span class="comment">// arguments</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>发送消息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">err = ch.ExchangeDeclare(</span><br><span class="line">  <span class="string">&quot;logs_direct&quot;</span>, <span class="comment">// name</span></span><br><span class="line">  <span class="string">&quot;direct&quot;</span>,      <span class="comment">// type</span></span><br><span class="line">  <span class="literal">true</span>,          <span class="comment">// durable</span></span><br><span class="line">  <span class="literal">false</span>,         <span class="comment">// auto-deleted</span></span><br><span class="line">  <span class="literal">false</span>,         <span class="comment">// internal</span></span><br><span class="line">  <span class="literal">false</span>,         <span class="comment">// no-wait</span></span><br><span class="line">  <span class="literal">nil</span>,           <span class="comment">// arguments</span></span><br><span class="line">)</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to declare an exchange&quot;</span>)</span><br><span class="line"></span><br><span class="line">body := bodyFrom(os.Args)</span><br><span class="line">err = ch.Publish(</span><br><span class="line">  <span class="string">&quot;logs_direct&quot;</span>,         <span class="comment">// exchange</span></span><br><span class="line">  severityFrom(os.Args), <span class="comment">// routing key</span></span><br><span class="line">  <span class="literal">false</span>, <span class="comment">// mandatory</span></span><br><span class="line">  <span class="literal">false</span>, <span class="comment">// immediate</span></span><br><span class="line">  amqp.Publishing&#123;</span><br><span class="line">    ContentType: <span class="string">&quot;text/plain&quot;</span>,</span><br><span class="line">    Body:        []<span class="type">byte</span>(body),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a><strong>订阅</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">q, err := ch.QueueDeclare(</span><br><span class="line">  <span class="string">&quot;&quot;</span>,    <span class="comment">// name</span></span><br><span class="line">  <span class="literal">false</span>, <span class="comment">// durable</span></span><br><span class="line">  <span class="literal">false</span>, <span class="comment">// delete when unused</span></span><br><span class="line">  <span class="literal">true</span>,  <span class="comment">// exclusive</span></span><br><span class="line">  <span class="literal">false</span>, <span class="comment">// no-wait</span></span><br><span class="line">  <span class="literal">nil</span>,   <span class="comment">// arguments</span></span><br><span class="line">)</span><br><span class="line">failOnError(err, <span class="string">&quot;Failed to declare a queue&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &lt; <span class="number">2</span> &#123;</span><br><span class="line">  log.Printf(<span class="string">&quot;Usage: %s [info] [warning] [error]&quot;</span>, os.Args[<span class="number">0</span>])</span><br><span class="line">  os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 建立多个绑定关系</span></span><br><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">  log.Printf(<span class="string">&quot;Binding queue %s to exchange %s with routing key %s&quot;</span>,</span><br><span class="line">     q.Name, <span class="string">&quot;logs_direct&quot;</span>, s)</span><br><span class="line">  err = ch.QueueBind(</span><br><span class="line">    q.Name,        <span class="comment">// queue name</span></span><br><span class="line">    s,             <span class="comment">// routing key</span></span><br><span class="line">    <span class="string">&quot;logs_direct&quot;</span>, <span class="comment">// exchange</span></span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    <span class="literal">nil</span>)</span><br><span class="line">  failOnError(err, <span class="string">&quot;Failed to bind a queue&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="topic"><a href="#topic" class="headerlink" title="topic"></a><strong>topic</strong></h3><h4 id="topic交换器"><a href="#topic交换器" class="headerlink" title="topic交换器"></a>topic交换器</h4><p>发送到<code>topic</code>交换器的消息不能具有随意的<code>routing_key</code>——它必须是单词列表，<strong>以点分隔</strong>。这些词可以是任何东西，但通常它们指定与消息相关的某些功能。一些有效的<code>routing_key</code>示例：“<code>stock.usd.nyse</code>”，“<code>nyse.vmw</code>”，“<code>quick.orange.rabbit</code>”。<code>routing_key</code>中可以包含任意多个单词，最多255个字节。</p><p>绑定键也必须采用相同的形式。<code>topic</code>交换器背后的逻辑类似于<code>direct</code>交换器——用特定路由键发送的消息将传递到所有匹配绑定键绑定的队列。但是，绑定键有两个重要的<strong>特殊情况</strong>： - <code>*</code>（星号）可以代替一个单词。 - <code>＃</code>（井号）可以替代零个或多个单词。</p><p><img src="/.com//.%5CtopicExchange.png" alt="topicExchange"></p><p>在这个例子中，我们将发送一些都是描述动物的信息。将使用包含三个词（两个点）的路由密钥发送消息。路由键中的第一个单词将描述速度，第二个是颜色，第三个是种类：“<code>&lt;speed&gt;.&lt;colour&gt;.&lt;species&gt;</code>”。</p><p>我们创建了三个绑定关系：Q1与绑定键“<code>*.orange.*</code>”绑定，Q2与“<code>*.*.rabbit</code>”和“<code>lazy.＃</code>”绑定。</p><p>这些绑定可以总结为：</p><ul><li>Q1对所有橙色动物都感兴趣。</li><li>Q2想接收有关兔子（rabbit）的一切消息，以及有关懒惰（lazy）动物的一切消息。</li></ul><p>如果一条消息匹配了一个消费者中的两个绑定，那么该消息也只会传递到这个消费者一次</p><p>如果我们打破约定并发送一个或四个单词的消息，例如“<code>orange</code>”或“<code>quick.orange.male.rabbit</code>”，这些消息将不匹配任何绑定，并且将会丢失。</p><p>另外，“<code>lazy.orange.male.rabbit</code>”即使有四个单词，也将匹配最后一个绑定，并将其传送到第二个队列。</p><h4 id="绑定topic"><a href="#绑定topic" class="headerlink" title="绑定topic"></a>绑定<strong>topic</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定topic</span></span><br><span class="line">        <span class="keyword">for</span> _, s := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">                log.Printf(<span class="string">&quot;Binding queue %s to exchange %s with routing key %s&quot;</span>,</span><br><span class="line">                        q.Name, <span class="string">&quot;logs_topic&quot;</span>, s)</span><br><span class="line">                err = ch.QueueBind(</span><br><span class="line">                        q.Name,       <span class="comment">// queue name</span></span><br><span class="line">                        s,            <span class="comment">// routing key</span></span><br><span class="line">                        <span class="string">&quot;logs_topic&quot;</span>, <span class="comment">// exchange</span></span><br><span class="line">                        <span class="literal">false</span>,</span><br><span class="line">                        <span class="literal">nil</span>)</span><br><span class="line">                failOnError(err, <span class="string">&quot;Failed to bind a queue&quot;</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p><img src="/.com//.%5CrpcQueue.png" alt="rpcQueue"></p><p>RPC工作流程如下：</p><ul><li>客户端启动时，它将创建一个匿名排他<strong>回调队列</strong>。</li><li>对于RPC请求，客户端发送一条消息，该消息具有两个属性：<code>reply_to</code>（设置为回调队列）和<code>correlation_id</code>（设置为每个请求的唯一值）。</li><li>该请求被发送到<code>rpc_queue</code>队列。</li><li>RPC工作程序（又名：服务器）正在等待该队列上的请求。当出现请求时，它会完成计算工作并把结果作为消息使用<code>replay_to</code>字段中的队列发回给客户端。</li><li>客户端等待回调队列上的数据。出现消息时，它将检查<code>correlation_id</code>属性。如果它与请求中的值匹配，则将响应返回给应用程序。</li></ul><h4 id="关联ID（Correlation-ID）"><a href="#关联ID（Correlation-ID）" class="headerlink" title="关联ID（Correlation ID）"></a>关联ID（Correlation ID）</h4><p>在回调队列中收到响应后，尚不清楚响应属于哪个请求。这个时候就该使用<code>correlation_id</code>这个属性了。针对每个请求我们将为其设置一个唯一值。随后，当我们在回调队列中收到消息时，我们将查看该属性，并基于这个属性将响应与请求进行匹配。如果我们看到未知的<code>correlation_id</code>值，则丢弃该消息。</p><p><strong>检验Correlation ID</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">        <span class="keyword">if</span> corrId == d.CorrelationId &#123;</span><br><span class="line">                res, err = strconv.Atoi(<span class="type">string</span>(d.Body))</span><br><span class="line">                failOnError(err, <span class="string">&quot;Failed to convert body to integer&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NSQ-GO"><a href="#NSQ-GO" class="headerlink" title="NSQ+GO"></a>NSQ+GO</h2><h3 id="NSQ特性"><a href="#NSQ特性" class="headerlink" title="NSQ特性"></a>NSQ特性</h3><ul><li>消息默认不持久化，可以配置成持久化模式。nsq采用的方式是<code>内存+硬盘</code>的模式，当内存达到一定程度时就会将数据持久化到硬盘<ol><li>如果将<code>--mem-queue-size</code>设置为0，所有的消息都会存储到磁盘。</li><li>服务器重启时也会将当时在内存的消息持久化。</li></ol></li><li>每条消息至少传递一次</li><li>消息不保证有序</li></ul><h3 id="Topic和Channel"><a href="#Topic和Channel" class="headerlink" title="Topic和Channel"></a>Topic和Channel</h3><p>每个nsqd实例旨在一次处理多个数据流。这些数据流成为<code>topic</code>，一个<code>topic</code>具有一个或多个<code>channel</code>。每个<code>channel</code>都会收到<code>topic</code>所有消息的副本。实际上，下游的服务是通过对应的<code>channel</code>来消费<code>topic</code>消息的。</p><p><code>topic</code>和<code>channel</code>都不是预先配置的。<code>topic</code>在首次使用时创建的，方法是将其发布到指定<code>topic</code>，或者订阅指定<code>topic</code>上的<code>channel</code>。<code>channel</code>是通过订阅指定的<code>channel</code>在第一次使用时创建的。</p><p><code>topic</code>和<code>channel</code>都相互<strong>独立地缓冲数据</strong>，防止缓慢的消费者导致其他<code>chennel</code>的积压（同样适用于<code>topic</code>级别）。</p><p><code>channel</code>可以并且通常会<strong>连接多个客户端</strong>。假设所有连接的客户端都处于准备接收消息的状态，则每条消息将被传递到随机客户端。</p><p>总而言之，消息是从<code>topic -&gt; channel</code>（每个channel接收该topic）<strong>多播</strong>的，但是从<code>channel -&gt; consumers</code><strong>均匀分布</strong>（每个消费者接收该channel的一部分消息）。</p><h3 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a><strong>生产者</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> producer *nsq.Producer</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化生产者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initProducer</span><span class="params">(str <span class="type">string</span>)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">config := nsq.NewConfig()</span><br><span class="line">producer, err = nsq.NewProducer(str, config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;create producer failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">nsqAddress := <span class="string">&quot;127.0.0.1:4150&quot;</span></span><br><span class="line">err := initProducer(nsqAddress)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;init producer failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader := bufio.NewReader(os.Stdin) <span class="comment">// 从标准输入读取</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">data, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;read string from stdin failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">data = strings.TrimSpace(data)</span><br><span class="line"><span class="keyword">if</span> strings.ToUpper(data) == <span class="string">&quot;Q&quot;</span> &#123; <span class="comment">// 输入Q退出</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向 &#x27;topic_demo&#x27; publish 数据</span></span><br><span class="line">err = producer.Publish(<span class="string">&quot;topic_demo&quot;</span>, []<span class="type">byte</span>(data))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;publish msg to nsq failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nsqdadmin管理页面"><a href="#nsqdadmin管理页面" class="headerlink" title="nsqdadmin管理页面"></a>nsqdadmin管理页面</h3><p>使用浏览器打开<code>http://127.0.0.1:4171/</code>可以查看到nsqdadmin的页面</p><h3 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyHandler 是一个消费者类型</span></span><br><span class="line"><span class="keyword">type</span> MyHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">Title <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleMessage 是需要实现的处理消息的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyHandler)</span></span> HandleMessage(msg *nsq.Message) (err <span class="type">error</span>) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s recv from %v, msg:%v\n&quot;</span>, m.Title, msg.NSQDAddress, <span class="type">string</span>(msg.Body))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化消费者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initConsumer</span><span class="params">(topic <span class="type">string</span>, channel <span class="type">string</span>, address <span class="type">string</span>)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">config := nsq.NewConfig()</span><br><span class="line">config.LookupdPollInterval = <span class="number">15</span> * time.Second</span><br><span class="line">c, err := nsq.NewConsumer(topic, channel, config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;create consumer failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">consumer := &amp;MyHandler&#123;</span><br><span class="line">Title: <span class="string">&quot;沙河1号&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">c.AddHandler(consumer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// if err := c.ConnectToNSQD(address); err != nil &#123; // 直接连NSQD</span></span><br><span class="line"><span class="keyword">if</span> err := c.ConnectToNSQLookupd(address); err != <span class="literal">nil</span> &#123; <span class="comment">// 通过lookupd查询</span></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := initConsumer(<span class="string">&quot;topic_demo&quot;</span>, <span class="string">&quot;first&quot;</span>, <span class="string">&quot;127.0.0.1:4161&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;init consumer failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)        <span class="comment">// 定义一个信号的通道</span></span><br><span class="line">signal.Notify(c, syscall.SIGINT) <span class="comment">// 转发键盘中断信号到c</span></span><br><span class="line">&lt;-c                              <span class="comment">// 阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>gRPC</title>
      <link href="/2023/03/12/gRPC/"/>
      <url>/2023/03/12/gRPC/</url>
      
        <content type="html"><![CDATA[<h1 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h1><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><h3 id="单体架构的缺点"><a href="#单体架构的缺点" class="headerlink" title="单体架构的缺点"></a>单体架构的缺点</h3><ol><li>某个服务宕机，整个应用都不可用，隔离性差</li><li>整体应用进行扩展，浪费资源，可伸缩性差</li><li>代码耦合在一起，可维护性差</li></ol><h3 id="RPC的缺点"><a href="#RPC的缺点" class="headerlink" title="RPC的缺点"></a>RPC的缺点</h3><ol><li>代码冗余</li><li>服务与服务间存在调用关系</li></ol><p>服务进行拆分之后，服务和服务之间发生的时进程和进程之间的调用，也就是服务器要调用服务器</p><p>于是就要发起网络调用，但由于<strong>http</strong>的性能较低，这时候需要引入<strong>RPC</strong>，通过自定义协议发起<strong>TCP</strong>调用，来加快传输效率</p><p><strong>RPC</strong>的全称是<strong>Remote Procedure Call</strong>，远程过程调用，这是一种协议，用来屏蔽分布式计算中的各种调用细节，使得可以像调用一个本地的函数一样调用远程的函数</p><h2 id="gRPC-1"><a href="#gRPC-1" class="headerlink" title="gRPC"></a>gRPC</h2><p><strong>gRPC是一个高性能的、开源的、通用的RPC框架</strong></p><p><img src="https://grpc.io/img/landing-2.svg" alt="Concept Diagram"></p><h3 id="为什么要用gRPC"><a href="#为什么要用gRPC" class="headerlink" title="为什么要用gRPC"></a>为什么要用gRPC</h3><p>使用gRPC，可以一次性在一个 <code>.proto</code>文件中定义服务并使用任何支持它的语言去实现客户端和服务端，它们可以应用在各种场景中，解决了不同语言及环境间通信的复杂性。使用<code>protocol buffers</code>还可以或的其他好处，比如高效的序列化，简单的<code>IDL</code>以及容易进行接口更新。总而言之，gRPC能让我们更容易编写跨语言的分布式代码</p><p><strong>IDL?</strong></p><p>IDL(Interface description language) 是指接口描述语言，是用来描述软件组件接口的一种计算机语言，是跨平台开发的基础。IDL通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信交流。</p><h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><p>Protobuf全程Protocol Buffer，是Google公司于2008年开源的一种与语言无关、平台无关、可扩展的用于序列化结构化数据——类似于XML，但比XML更小、更快、更简单但，它可用于（数据）通信协议、数据存储等。只需定义一次你想要的数据结构，然后你就可以使用特殊生成的源代码来轻松地从各种数据流和各种语言中写入和读取你的结构化数据。目前Protobuf被广泛用作微服务中的通信协议。</p><h3 id="生成Go代码"><a href="#生成Go代码" class="headerlink" title="生成Go代码"></a>生成Go代码</h3><h4 id="编译器调用"><a href="#编译器调用" class="headerlink" title="编译器调用"></a>编译器调用</h4><p>当使用<code>go_out</code>标志调用<code>protoc</code>时，<code>protocol buffer</code>编译器将生成Go代码。<code>protocol buffer</code>编译器会将生成的Go代码输出到命令行参数<code>go_out</code>指定的位置。<code>go_out</code>标志的参数是你希望编译器编写Go输出的目录。编译器为每个<code>.proto</code>文件输入创建一个源文件。输出文件的名称是通过<code>.proto</code>扩展名替换为<code>pb.go</code>而创建的。</p><p>生成的<code>.pb.go</code>文件放置的位置取决于编译器标志。有以下几种输出模式：</p><ul><li><code>paths=import</code></li></ul><p>输出文件放在以Go包的导入路径命名目录中。例如<code>protos/buzz.proto</code>文件中带有<code>example.com/project/protos/fizz</code>的导入路径，则输出的生成文件会保存在<code>example/project/protos/fizz/buzz.pb.go</code>。如果为指定路径标志这就是默认输出模式</p><ul><li><code>module=$PREFIX</code></li></ul><p>输入文件放在以Go包的导入路径命名的目录中，但是从输出文件名中删除了指定的目录前缀。例如，输入文件<code>protos/buzz.proto</code>，其导入路径为<code>example.com/project/protos/fizz</code>并指定<code>example/project</code>为module前缀，结果会产生一个名为<code>pros/fizz/buzz.pb.go</code>的输出文件。在module路径之外生成任何Go包都会导致错误。此模式对于将生成的文件直接输出到Go模块非常有用</p><ul><li><code>paths=source_relative</code></li></ul><p>输出文件与输入文件放在相同的相对目录中。例如一个<code>protos/buzz.proto</code></p><p>输入文件会产生一个位于<code>protos/buzz.pb.go</code>的输入文件</p><p>在调用<code>protoc</code>时，通过传递<code>go_opt</code>标志来提供特定于<code>protocol-gen-go</code>的标志位参数。可以传递等多个<code>go_opt</code>标志位参数。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=src --go_out=out --go_opt=paths=source_relative foo.proto bar/baz.proto</span><br></pre></td></tr></table></figure><p>编译器从<code>src</code>目录中读取输入文件<code>foo.proto</code>和<code>bar/baz.proto</code>，并将输出文件<code>foo.pb.go</code>和<code>bar/baz.pb.go</code>写入<code>out</code>目录。如果需要，编译器会递归创建输出子目录，但不会创建输出目录本身。</p><h4 id="go-package"><a href="#go-package" class="headerlink" title="go_package"></a>go_package</h4><p>为了生成Go代码，必须为每个<code>.proto</code>文件（包括被生成的<code>.proto</code>文件传递依赖的文件）提供Go包的导入路径。有两种方法可以指定Go导入路径：</p><ul><li>通过在<code>.proto</code>文件中声名</li><li>通过在调用<code>protoc</code>时在命令行上声明它</li></ul><p>官方推荐在<code>.proto</code>文件中声明它，以便<code>.proto</code>文件的Go包可以与<code>.proto</code>文件本身集中标识。如果给定<code>.proto</code>文件的Go导入路径由<code>.proto</code>文件本身和命令行提供，则优先级：<strong>命令行&gt;proto文件中的声明</strong></p><p>在<code>.proto</code>文件中指定Go的导入路径</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;example.com/project/protos/fizz&quot;</span>;</span><br></pre></td></tr></table></figure><p>调用编译器时，可以在命令行上指定Go的导入路径，方法是传递一个或多个<code>M$&#123;PROTO_FILE&#125;=$&#123;GO_IMPORT_PATH&#125;</code>标志位。用法示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=src\</span><br><span class="line">--go_opt=Mprotos/buzz.proto=example.com/project/protos/fizz\</span><br><span class="line">--go_opt=Mprotos/fizz.proto=example.com/project/protos/foo\</span><br><span class="line">protos/buzz.proto protos/bar.proto</span><br></pre></td></tr></table></figure><p>如果一个<code>.proto</code>文件有重复的条目，则指定的最后一个条目优先。</p><p><strong>指定一个显示的包名称</strong></p><p>对与<code>go_package</code>和<code>M</code>标志位，它们的值可以包含一个显示的包名称，该名称与导入路径之间用分号分隔。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example.com/protos/foo;package_name</span><br></pre></td></tr></table></figure><p>但是并不鼓励这种做法，因为默认情况下包名称将以合理的方式从导入路径派生。</p><p><strong>注意</strong></p><p><strong>Go导入路径的package和<code>.proto</code>文件中的package没有关联</strong></p><p><strong>Go导入路径的package和<code>.proto</code>导入路径没有关联</strong></p><h3 id="Go使用protoc示例"><a href="#Go使用protoc示例" class="headerlink" title="Go使用protoc示例"></a>Go使用protoc示例</h3><h4 id="普通编译"><a href="#普通编译" class="headerlink" title="普通编译"></a>普通编译</h4><p>定义一个<code>price.proto</code>文件</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proto/book/price.proto</span></span><br><span class="line"></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> book;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;github.com/Q1mi/demo/proto/book&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Price</span> &#123;</span><br><span class="line">    <span class="type">int64</span> market_price = <span class="number">1</span>;  <span class="comment">// 建议使用下划线的命名方式</span></span><br><span class="line">    <span class="type">int64</span> sale_price = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用<code>option go_package=&quot;github.com/Q1mi/demo/proto/book&quot;;</code>语句声明生成的Go代码的导入路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//项目当前的目录结构</span><br><span class="line">demo</span><br><span class="line">└── proto</span><br><span class="line">    └──book</span><br><span class="line">       └──price.proto</span><br></pre></td></tr></table></figure><p>生成代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=proto --go_out=proto --go_opt=paths=source_relative book/price.proto</span><br></pre></td></tr></table></figure><ul><li><code>--proto_path=proto</code>表示从proto目录下读取proto文件。等同于<code>-I</code>，这里可以省略。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//执行完编译后的目录结构</span><br><span class="line">demo</span><br><span class="line"> └── proto</span><br><span class="line">     └── book</span><br><span class="line">         ├── price.pb.go</span><br><span class="line">         └── price.proto</span><br></pre></td></tr></table></figure><p>如果像将Go代码保存在其他文件夹中（例如<code>bp</code>文件夹），那么我么需要先在<code>demo</code>目录下创建一个<code>pb</code>文件夹。然后在命令行通过<code>go_out=pb</code>指定生成的Go代码保存的路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=proto --go_out=pb --go_opt=paths=source_relative book/price.proto</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//执行完编译后的目录结构</span><br><span class="line">demo</span><br><span class="line">├── pb</span><br><span class="line">│   └── book</span><br><span class="line">│       └── price.pb.go</span><br><span class="line">└── proto</span><br><span class="line">    └── book</span><br><span class="line">        ├── price.pb.go</span><br><span class="line">        └── price.proto</span><br></pre></td></tr></table></figure><h4 id="import同目录下protobuf文件"><a href="#import同目录下protobuf文件" class="headerlink" title="import同目录下protobuf文件"></a>import同目录下protobuf文件</h4><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo/proto/book/book.proto</span></span><br><span class="line"></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明protobuf中的包名</span></span><br><span class="line"><span class="keyword">package</span> book;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明生成的Go代码的导入路径</span></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;github.com/Q1mi/demo/proto/book&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入同目录下的protobuf文件（注意起始位置为proto_path的下层）</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;book/price.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="type">string</span> title = <span class="number">1</span>;</span><br><span class="line">    Price price = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=proto --go_out=proto --go_opt=paths=source_relative book/book.proto book/price.proto</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ol><li>编译命令指定<code>--proto_path=proto</code>，所以import导入语句需要从<code>demo/proto</code>文件夹的下层目录<code>book</code>这一层开始写。</li><li>一位内导入的<code>price.proto</code>与<code>book.proto</code>同属于一个<code>package book</code>，所以可以直接使用<code>price</code>作为类型，无需添加package前缀。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//执行编译指令后的目录结构</span><br><span class="line">demo</span><br><span class="line">└── proto</span><br><span class="line">    └── book</span><br><span class="line">        ├── book.pb.go</span><br><span class="line">        ├── book.proto</span><br><span class="line">        ├── price.pb.go</span><br><span class="line">        └── price.proto</span><br></pre></td></tr></table></figure><h4 id="import其他目录下的文件"><a href="#import其他目录下的文件" class="headerlink" title="import其他目录下的文件"></a>import其他目录下的文件</h4><p>在<code>demo/proto</code>目录下新建了一个<code>author</code>文件夹，用来存放与author相关的protobuf文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// demo/proto/author/author.proto</span><br><span class="line"></span><br><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">// 声明protobuf中的包名</span><br><span class="line">package author;</span><br><span class="line"></span><br><span class="line">// 声明生成的Go代码的导入路径</span><br><span class="line">option go_package = &quot;github.com/Q1mi/demo/proto/author&quot;;</span><br><span class="line"></span><br><span class="line">message Info &#123;</span><br><span class="line">    string name = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的目录结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">demo</span><br><span class="line">└── proto</span><br><span class="line">    ├── author</span><br><span class="line">    │   └── author.proto</span><br><span class="line">    └── book</span><br><span class="line">        ├── book.pb.go</span><br><span class="line">        ├── book.proto</span><br><span class="line">        ├── price.pb.go</span><br><span class="line">        └── price.proto</span><br></pre></td></tr></table></figure><p>这时如果想在book中增加一个作者信息的字段–authorInfo，就需要在<code>demo/proto/book/book.proto</code>中导入其他目录下的<code>author.proto</code>文件。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proto/proto/book/book.proto</span></span><br><span class="line"></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明protobuf中的包名</span></span><br><span class="line"><span class="keyword">package</span> book;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明生成的Go代码的导入路径</span></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;github.com/Q1mi/demo/proto/book&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入同目录下的protobuf文件（注意起始位置为proto_path的下层）</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;book/price.proto&quot;</span>;</span><br><span class="line"><span class="comment">// 引入其他目录下的protobuf文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;author/author.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="type">string</span> title = <span class="number">1</span>;</span><br><span class="line">    Price price = <span class="number">2</span>;</span><br><span class="line">    author.Info authorInfo = <span class="number">3</span>;  <span class="comment">// 需要带package前缀</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="import-google-proto文件"><a href="#import-google-proto文件" class="headerlink" title="import google proto文件"></a>import google proto文件</h4><p>Google定义了一些很常用的类型如，<code>Timestamp</code>、<code>Any</code>等</p><p>比如我们要在<code>book/book.proto</code>中导入<code>Timestamp</code>类型</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo/proto/book/book.proto</span></span><br><span class="line"></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明protobuf中的包名</span></span><br><span class="line"><span class="keyword">package</span> book;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明生成的Go代码的导入路径</span></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;github.com/Q1mi/demo/proto/book&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入同目录下的protobuf文件（注意起始位置为proto_path的下层）</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;book/price.proto&quot;</span>;</span><br><span class="line"><span class="comment">// 引入其他目录下的protobuf文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;author/author.proto&quot;</span>;</span><br><span class="line"><span class="comment">// 引入google/protobuf/timestamp.proto文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/timestamp.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="type">string</span> title = <span class="number">1</span>;</span><br><span class="line">    Price price =<span class="number">2</span>;</span><br><span class="line">    author.Info authorInfo = <span class="number">3</span>;  <span class="comment">// 需要带package前缀</span></span><br><span class="line">    google.protobuf.Timestamp date = <span class="number">4</span>;  <span class="comment">// 注意包名前缀</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成gRPC代码"><a href="#生成gRPC代码" class="headerlink" title="生成gRPC代码"></a>生成gRPC代码</h3><p>由于我们通常搭配gRPC来使用protobuf，所以也需要基于<code>.proto</code>文件生成gRPC代码</p><p>操作是在<code>go_out</code>、<code>go_opt</code>中加入<code>grpc</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=proto --go_out=proto --go_opt=paths=source_relative --go-grpc_out=proto --go-grpc_opt=paths=source_relative book/book.proto book/price.proto author/author.proto</span><br></pre></td></tr></table></figure><h2 id="metadata"><a href="#metadata" class="headerlink" title="metadata"></a>metadata</h2><p>元数据(metadata)是指在处理RPC请求和响应过程中需要但又不属于具体业务（例如身份验证详细信息）的信息，采用键值对列表的形式，其中键是<strong>string</strong>类型，值通常是**[]string**类型，但也可以是二进制数据。gRPC中的metadata类似于我们在HTTP headers中的键值对，元数据可以包含token、请求标识和监控标签等。</p><p>metadata中的键是大小写不敏感的，有字幕、数字和特殊字符<code>-</code>、<code>_</code>、<code>.</code>组成并且不能以<code>grpc-</code>开头(gRPC保留自用)，二进制的键名必须以<code>-bin</code>结尾。</p><p>元数据对gRPC本身是不可见的，我们通常是在应用程序代码或者中间件中处理元数据，我们不需要在<code>.proto</code>文件中指定元数据。</p><p>如何访问元数据取决于具体使用的编程语言</p><p>metadata类型定义如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MD <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span></span><br></pre></td></tr></table></figure><p>元数据可以像普通map一样读取。注意，这个map的值类型是[]string，因此用户可以使用一个键附加多个值。</p><h4 id="创建新的metadata"><a href="#创建新的metadata" class="headerlink" title="创建新的metadata"></a>创建新的metadata</h4><p><strong>第一种方法</strong>是使用New基于map[string]string创建元数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md:=metadata.New(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;key1&quot;</span>:<span class="string">&quot;val1&quot;</span>,<span class="string">&quot;key2&quot;</span>:<span class="string">&quot;val2&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p><strong>另一种方法</strong>是使用<code>Paris</code>。具有相同键的值将合并到一个列表中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">md:=metadata.Paris(</span><br><span class="line"><span class="string">&quot;key1&quot;</span>,<span class="string">&quot;val1&quot;</span>,</span><br><span class="line"><span class="string">&quot;key2&quot;</span>,<span class="string">&quot;val2&quot;</span>,   <span class="comment">//&quot;key1&quot;的值将会是[]string&#123;&quot;val1&quot;,&quot;val1-2&quot;&#125;</span></span><br><span class="line"><span class="string">&quot;key3&quot;</span>,<span class="string">&quot;val3&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>元数据中存储二进制数据</strong></p><p>在元数据中，键始终是字符串。但是值可以是字符串或二进制数据。要在元数据中存储二进制数据值，只需在密钥中添加<code>-bin</code>后缀。在创建元数据时，将对带有<code>-bin</code>后缀键的值进行编码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">md := metadata.Pairs(</span><br><span class="line">    <span class="string">&quot;key&quot;</span>, <span class="string">&quot;string value&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key-bin&quot;</span>, <span class="type">string</span>([]<span class="type">byte</span>&#123;<span class="number">96</span>, <span class="number">102</span>&#125;), <span class="comment">// 二进制数据在发送前会进行(base64) 编码</span></span><br><span class="line">                                        <span class="comment">// 收到后会进行解码</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="从请求上下文中获取元数据"><a href="#从请求上下文中获取元数据" class="headerlink" title="从请求上下文中获取元数据"></a>从请求上下文中获取元数据</h4><p>可以使用<code>FromIncomingContext</code>可以从RPC请求的上下文中获取元数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SomeRPC(ctx context.Context, in *pb.SomeRequest) (*pb.SomeResponse, err) &#123;</span><br><span class="line">    md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line">    <span class="comment">// do something with metadata</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端发送和接受元数据"><a href="#客户端发送和接受元数据" class="headerlink" title="客户端发送和接受元数据"></a>客户端发送和接受元数据</h4><h5 id="发送metadata"><a href="#发送metadata" class="headerlink" title="发送metadata"></a>发送metadata</h5><p><strong>第一种方法</strong><code>AppendToOutgoingContext</code>将kv对附加到context。无论在context中是否已经有元数据都可以使用这个方法。如果先前没有元数据，则添加元数据；如果context中已经存在元数据，则将kv对合并进去。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建带有metadata的context</span></span><br><span class="line">ctx := metadata.AppendToOutgoingContext(ctx, <span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>, <span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v2&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一些 metadata 到 context (e.g. in an interceptor)</span></span><br><span class="line">ctx := metadata.AppendToOutgoingContext(ctx, <span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起普通RPC请求</span></span><br><span class="line">response, err := client.SomeRPC(ctx, someRequest)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者发起流式RPC请求</span></span><br><span class="line">stream, err := client.SomeStreamingRPC(ctx)</span><br></pre></td></tr></table></figure><p><strong>第二种方法</strong><code>NewOutgoingContext</code>将元数据附加到context。但是这将替换context中的任何已有的元数据，因此必须保留现有元数据（如果需要的话）。这个方法比使用<code>AppendToOutgoingContext</code>要慢。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建带有metadata的context</span></span><br><span class="line">md := metadata.Pairs(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>, <span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v2&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v3&quot;</span>)</span><br><span class="line">ctx := metadata.NewOutgoingContext(context.Background(), md)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一些metadata到context (e.g. in an interceptor)</span></span><br><span class="line">send, _ := metadata.FromOutgoingContext(ctx)</span><br><span class="line">newMD := metadata.Pairs(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//metadata.Join可以将两个metadata合并</span></span><br><span class="line">ctx = metadata.NewOutgoingContext(ctx, metadata.Join(send, newMD))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起普通RPC请求</span></span><br><span class="line">response, err := client.SomeRPC(ctx, someRequest)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者发起流式RPC请求</span></span><br><span class="line">stream, err := client.SomeStreamingRPC(ctx)</span><br></pre></td></tr></table></figure><h5 id="接收metadata"><a href="#接收metadata" class="headerlink" title="接收metadata"></a>接收metadata</h5><p>客户端可以接收的元数据包括header和trailer</p><p><strong>trailer?</strong></p><p>trailer可以用于服务器希望在处理请求后给客户端发送任何内容，例如在流式RPC中只有等所有结果都留到客户端后才能计算负载信息，这时候不能使用headers（header在数据之前，trailer在数据数据之后）</p><p><strong>普通调用</strong></p><p>可以使用<strong>CallOption</strong>中的<strong>Header</strong>和<strong>Trailer</strong>函数来获取普通RPC调用发送的header和trailer</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> header,trailer metadata.MD <span class="comment">//声明存储header和trailer的变量</span></span><br><span class="line">r,err:=client.SomeRPC(</span><br><span class="line">ctx,</span><br><span class="line">    someRequest,</span><br><span class="line">    grpc.Header(&amp;header),<span class="comment">// 将会接收header</span></span><br><span class="line">    grpc.Trailer(&amp;trailer),<span class="comment">// 将会接收trailer</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//do something with header and trailer</span></span><br></pre></td></tr></table></figure><p><strong>流式调用</strong></p><p>使用接口ClientStream中的Header和Trailer函数，可以从返回的流中就收Header和Trailer</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stream, err := client.SomeStreamingRPC(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收 header</span></span><br><span class="line">header, err := stream.Header()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收 trailer</span></span><br><span class="line">trailer := stream.Trailer()</span><br></pre></td></tr></table></figure><h4 id="服务端发送和接收元数据"><a href="#服务端发送和接收元数据" class="headerlink" title="服务端发送和接收元数据"></a>服务端发送和接收元数据</h4><h5 id="接收metadata-1"><a href="#接收metadata-1" class="headerlink" title="接收metadata"></a>接收metadata</h5><p>要读取客户端发送的元数据，服务器要从RPC上下文检索它。如果是普通RPC调用，则可以使用RPC处理程序的上下文，如果是流调用，需要从流中获取上下文。</p><p><strong>普通调用</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SomeRPC(ctx context.Context, in *pb.someRequest) (*pb.someResponse, <span class="type">error</span>) &#123;</span><br><span class="line">    md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line">    <span class="comment">// do something with metadata</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>流式调用</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SomeStreamingRPC(stream pb.Service_SomeStreamingRPCServer) <span class="type">error</span> &#123;</span><br><span class="line">    md, ok := metadata.FromIncomingContext(stream.Context())     <span class="comment">// get context from stream</span></span><br><span class="line">    <span class="comment">// do something with metadata</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="发送metadata-1"><a href="#发送metadata-1" class="headerlink" title="发送metadata"></a>发送metadata</h5><p><strong>普通调用</strong></p><p>在普通调用中，服务器可以调用gRPC模块中的<code>SendTrailer</code>和<code>SetTrailer</code>函数像客户端发送header和trailer。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SomeRPC(ctx context.Context, in *pb.someRequest) (*pb.someResponse, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建和发送 header</span></span><br><span class="line">    header := metadata.Pairs(<span class="string">&quot;header-key&quot;</span>, <span class="string">&quot;val&quot;</span>)</span><br><span class="line">    grpc.SendHeader(ctx, header)</span><br><span class="line">    <span class="comment">// 创建和发送 trailer</span></span><br><span class="line">    trailer := metadata.Pairs(<span class="string">&quot;trailer-key&quot;</span>, <span class="string">&quot;val&quot;</span>)</span><br><span class="line">    grpc.SetTrailer(ctx, trailer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>流式调用</strong></p><p>可以使用接口<code>ServerStream</code>中的<code>SendHeader</code>和<code>SetTrailer</code>函数发送header和trailer</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SomeStreamingRPC(stream pb.Service_SomeStreamingRPCServer) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 创建和发送 header</span></span><br><span class="line">    header := metadata.Pairs(<span class="string">&quot;header-key&quot;</span>, <span class="string">&quot;val&quot;</span>)</span><br><span class="line">    stream.SendHeader(header)</span><br><span class="line">    <span class="comment">// 创建和发送 trailer</span></span><br><span class="line">    trailer := metadata.Pairs(<span class="string">&quot;trailer-key&quot;</span>, <span class="string">&quot;val&quot;</span>)</span><br><span class="line">    stream.SetTrailer(trailer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加密或认证"><a href="#加密或认证" class="headerlink" title="加密或认证"></a>加密或认证</h2><p><strong>无加密认证</strong></p><ul><li>client</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn,_:=grpc.Dial(<span class="string">&quot;127.0.0.1:8972&quot;</span>,grpc.WithTransprotCredentials(insucure.NewCredentials()))</span><br><span class="line">client:=pb.NewGreeterClient(conn)</span><br></pre></td></tr></table></figure><ul><li>server</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s:=grpc.NewServer()</span><br><span class="line">lis,_:=net.Listen(<span class="string">&quot;tcp&quot;</span>,<span class="string">&quot;:127.0.0.1:8972&quot;</span>)</span><br><span class="line"><span class="comment">//error handing omitted</span></span><br><span class="line">s.Serve(lis)</span><br></pre></td></tr></table></figure><p><strong>使用服务器身份验证SSL&#x2F;TLS</strong></p><p>gRPC内置支持SSL&#x2F;TLS，可以通过SSL&#x2F;TLS证书建立安全连接，对传输的数据进行加密处理。</p><p><strong>生成证书</strong></p><ol><li><p>生成私钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl ecparam -genkey -name secp384r1 -out server.key</span><br></pre></td></tr></table></figure><p>执行上面的命令生成私钥文件<code>server.key</code></p></li><li><p>生成自签名的证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -nodes -new -x509 -sha256 -days 3650 -config server.cnf -extensions &#x27;req_ext&#x27; -key server.key -out server.crt</span><br></pre></td></tr></table></figure><p>执行上面的命令生成自签名证书<code>server.crt</code></p></li></ol><p><strong>建立安全连接</strong></p><ul><li>server</li></ul><p>Server端使用<code>credentials.NewServerTLSFromFIle</code>函数分别加载证书<code>server.cert</code>和密钥<code>server.key</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">creds, _ := credentials.NewServerTLSFromFile(certFile, keyFile)</span><br><span class="line">s := grpc.NewServer(grpc.Creds(creds))</span><br><span class="line">lis, _ := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8972&quot;</span>)</span><br><span class="line"><span class="comment">// error handling omitted</span></span><br><span class="line">s.Serve(lis)</span><br></pre></td></tr></table></figure><ul><li>client</li></ul><p>client使用上一步生成的证书文件<code>server.cert</code>建立安全连接</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">creds, _ := credentials.NewClientTLSFromFile(certFile, <span class="string">&quot;&quot;</span>)</span><br><span class="line">conn, _ := grpc.Dial(<span class="string">&quot;127.0.0.1:8972&quot;</span>, grpc.WithTransportCredentials(creds))</span><br><span class="line"><span class="comment">// error handling omitted</span></span><br><span class="line">client := pb.NewGreeterClient(conn)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><strong>除了这种自签名证书的方式外，生产环境对外通信时通常需要使用受信任的CA证书</strong></p><h2 id="拦截器（中间件）"><a href="#拦截器（中间件）" class="headerlink" title="拦截器（中间件）"></a><strong>拦截器</strong>（中间件）</h2><p>在常规http服务器中，我们可以在服务器上设置一个中间件包装我们的处理程序。可用于在服务器处理实际请求之前执行服务器想要执行的任何操作。可以是身份验证或者日志记录。</p><p><strong>而gRPC允许在客服端和服务器都使用拦截器</strong>。</p><h3 id="客户端拦截器"><a href="#客户端拦截器" class="headerlink" title="客户端拦截器"></a>客户端拦截器</h3><ul><li><strong>普通拦截器&#x2F;一元拦截器</strong></li></ul><p><code>UnaryClientInterceptor</code>是客户端一元拦截器的类型，函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnaryCLientInterceptor <span class="function"><span class="keyword">func</span> <span class="params">(ctx context.Context,method <span class="type">string</span>,req,reply <span class="keyword">interface</span>&#123;&#125;,cc *ClientConn,invoker UnaryInvok,opts ...CallOption)</span></span><span class="type">error</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnaryClientInterceptor</span><span class="params">()</span></span> grpc.UnaryClientInterceptor &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, method <span class="type">string</span>, req, reply <span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// 预处理(pre-processing)</span></span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="comment">// 获取正在运行程序的操作系统</span></span><br><span class="line">cos := runtime.GOOS</span><br><span class="line"><span class="comment">// 将操作系统信息附加到传出请求</span></span><br><span class="line">ctx = metadata.AppendToOutgoingContext(ctx, <span class="string">&quot;client-os&quot;</span>, cos)</span><br><span class="line"><span class="comment">// 调用RPC方法(invoking RPC method)</span></span><br><span class="line">err := invoker(ctx, method, req, reply, cc, opts...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后处理(post-processing)</span></span><br><span class="line">end := time.Now()</span><br><span class="line">log.Printf(<span class="string">&quot;RPC: %s,,client-OS: &#x27;%v&#x27; req:%v start time: %s, end time: %s, err: %v&quot;</span>, method, cos, req, start.Format(time.RFC3339), end.Format(time.RFC3339), err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ctx：go语言中的上下文</li><li>method：当前调用的RPC方法名</li><li>req：本次请求的参数，只有在RPC调用前修改才有效</li><li>reply：本次请求响应，在RPC调用后才能获取到</li><li>cc：gRPC连接信息</li><li>invoker：可以看作是当前RPC方法，一般在拦截器中调用invoker能达到调用RPC方法的效果，底层还是gRPC在处理</li><li>opts：本次调用指定的options信息</li></ul><p>一元拦截器的实现可以分为三个部分：</p><ol><li>预处理（调用RPC方法之前）。用户可以通过检查传入的参数（如RPC上下文、方法字符串、要发送的请求和CallOptions配置）来获得有关当前RPC调用的信息。</li><li>RPC调用（预处理完后）。可以通过<code>invoker</code>执行RPC调用。</li><li>调用后（调用RPC方法后）。调用者返回应答和错误，用户既可以对RPC调用进行后处理。一般与处理返回的响应和错误有关。若要在<code>ClientConn</code>上安装一元拦截器，要使用<code>DialOptionWithUnaryInterceptor</code>的<code>DialOption</code>配置Dial</li></ol><p><strong>添加一元拦截器</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn, err := grpc.Dial(<span class="string">&quot;:&quot;</span>+PORT, grpc.WithInsecure(),</span><br><span class="line">grpc.WithUnaryInterceptor(Interceptor.UnaryClientInterceptor()))</span><br></pre></td></tr></table></figure><ul><li><strong>流拦截器</strong></li></ul><p>流拦截器的实现包括预处理和流操作拦截。</p><ol><li>预处理：与一元拦截器类似</li><li>流操作拦截：流拦截器并没有时候进行RPC方法调用和后处理，而是拦截了用户在流上的操作。首先，拦截器调用传入的streamer以获得ClientStream，然后包装ClientStream并用拦截逻辑重载其方法。最后拦截器将包装好的ClientStream返回给用户操作。</li></ol><p><code>StreamClientInterceptor</code>是客户端拦截器的类型，函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StreamClienInterceptor <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, desc *StreamDesc, cc *ClientConn, method <span class="type">string</span>, streamer Streamer, opts ...CallOption)</span></span> (ClientStream, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><ul><li>streamer Streamer是一个创建客户端流的处理器。</li></ul><h3 id="服务端拦截器"><a href="#服务端拦截器" class="headerlink" title="服务端拦截器"></a>服务端拦截器</h3><ul><li><strong>普通拦截器&#x2F;一元拦截器</strong></li></ul><p>UnaryServerInterceptor是服务端的一元拦截器类型，函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnaryServerinterceptor <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *UnaryServerInfo, handler UnaryHandler)</span></span> (resp <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>流拦截器</strong></li></ul><p>StreamServerInterceptor是服务端流式拦截器的类型，函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StreamServerInterceptor <span class="function"><span class="keyword">func</span><span class="params">(srv <span class="keyword">interface</span>&#123;&#125;, ss ServerStream, info *StreamServerInfo, handler StreamHandler)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure><h3 id="拦截器示例"><a href="#拦截器示例" class="headerlink" title="拦截器示例"></a><strong>拦截器示例</strong></h3><h4 id="客户端拦截器定义"><a href="#客户端拦截器定义" class="headerlink" title="客户端拦截器定义"></a>客户端拦截器定义</h4><ul><li>一元拦截器</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unaryInterceptor 客户端一元拦截器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unaryInterceptor</span><span class="params">(ctx context.Context, method <span class="type">string</span>, req, reply <span class="keyword">interface</span>&#123;&#125;, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">var</span> credsConfigured <span class="type">bool</span></span><br><span class="line"><span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line">_, ok := o.(grpc.PerRPCCredsCallOption)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">credsConfigured = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !credsConfigured &#123;</span><br><span class="line">opts = <span class="built_in">append</span>(opts, grpc.PerRPCCredentials(oauth.NewOauthAccess(&amp;oauth2.Token&#123;</span><br><span class="line">AccessToken: <span class="string">&quot;some-secret-token&quot;</span>,</span><br><span class="line">&#125;)))</span><br><span class="line">&#125;</span><br><span class="line">start := time.Now()</span><br><span class="line">err := invoker(ctx, method, req, reply, cc, opts...)</span><br><span class="line">end := time.Now()</span><br><span class="line">fmt.Printf(<span class="string">&quot;RPC: %s, start time: %s, end time: %s, err: %v\n&quot;</span>, method, start.Format(<span class="string">&quot;Basic&quot;</span>), end.Format(time.RFC3339), err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>流拦截器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OAuth&amp;OIDC</title>
      <link href="/2023/03/12/Oauth2.0/"/>
      <url>/2023/03/12/Oauth2.0/</url>
      
        <content type="html"><![CDATA[<h1 id="OAuth-amp-OIDC"><a href="#OAuth-amp-OIDC" class="headerlink" title="OAuth&amp;OIDC"></a>OAuth&amp;OIDC</h1><h2 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h2><h3 id="OAuth简介"><a href="#OAuth简介" class="headerlink" title="OAuth简介"></a>OAuth简介</h3><p>OAuth是一个开放授权标准，允许用户授权第三方网站访问它们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容。为了保护用户数据额安全和隐私，第三方网站访问用户数据前都需要显式地像用户征求授权。</p><p>OAuth协议有两个版本，2.0版本授权验证流程更简单更安全，关注客户端开发者的简易性，同时为Web应用、桌面应用、手机和只能设备提供专门的认证流程，也是目前最主要的用户身份验证和授权方式。</p><h3 id="OAuth2工作流程"><a href="#OAuth2工作流程" class="headerlink" title="OAuth2工作流程"></a>OAuth2工作流程</h3><p><img src="/2023/03/12/Oauth2/Users\Liang\Documents\oauthProcess.PNG" alt="oauthProcess"></p><ul><li>client：第三方应用程序，代指任何资源服务器的第三方应用</li><li>authorization grant：认证授权</li><li>resource owner：资源所有者，即用户</li><li>authorization：认证服务器，即服务提供商专门用来处理认证的服务器</li><li>resource server：资源服务器，即用户提供商存放用户生成的资源的服务器，与认证服务器可以是一台服务器，也可以是不同服务器。</li></ul><ol><li>用户打开客户端后，客户端要求用户给予授权。</li><li>用户同意给予客户端授权。</li><li>客户端使用上一步获得的授权，向认证服务器申请令牌</li><li>认证服务器对客户端进行认证以后，确认无误，同意发放令牌</li><li>客户端使用令牌，向资源服务器申请获取资源</li><li>资源服务器确认令牌无误，同意向客户端开放资源</li></ol><p>最重要的是Access Token，一般保安三类信息：</p><ul><li>客户端标识</li><li>用户标识</li><li>客户端能访问资源所有者的哪些资源以及相应的权限</li></ul><h3 id="OAuth的授权模式"><a href="#OAuth的授权模式" class="headerlink" title="OAuth的授权模式"></a>OAuth的授权模式</h3><p>客户端必须得到用户的授权（authorization grant)，才能获的令牌。</p><p>OAuth 2的四种授权模式：</p><ul><li>授权码模式（authorization code）</li><li>简化模式（implicit）</li><li>密码模式（resource owner password credentials）</li><li>客户端模式（client credentials）</li></ul><h4 id="Authorization-code"><a href="#Authorization-code" class="headerlink" title="Authorization code"></a>Authorization code</h4><p>授权码模式是功能最完整、流程最严密的授权模式。通过客户端（client）的后台服务器，与服务提供商的认证服务器（authorization server）进行互动。</p><p><img src="/2023/03/12/Oauth2/Users\Liang\Documents\authorizationCodeProcess.PNG" alt="authorizationCodeProcess"></p><p>步骤如下：</p><ol><li>用户访问客户端，客户端将用户导向认证服务器</li><li>用户选择是否给予客户端授权</li><li>如果给予授权，认证服务器将用户的导向客户端事先指定的重定向URI，同时附上一个授权码</li><li>客户端收到授权码和重定向URI，确认无误后，向客户端发送访问令牌和可选的更新令牌</li></ol><p><strong>第1步中，客户端申请认证的URI，包括以下参数：</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http://oauth.com/authorize?response_type=code&amp;client_id=1&amp;state=xyz&amp;redirection_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Foauth2&amp;scope=user,photo</span><br></pre></td></tr></table></figure><ul><li>response_type：表示授权类型，<strong>必选</strong></li><li>client_id：表示客户端的id，<strong>必选</strong></li><li>redirect_uri：表示重定向URI，<strong>可选</strong></li><li>scope：表示申请的权限范围，<strong>可选</strong></li><li>state：客户端应当指定一个随机字符串，认证服务会原封不动地返回这个值，<strong>推荐</strong></li></ul><p><strong>第3步中，服务器回应客户端的URI包含以下参数：</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://client.example.com/callback?code=SplxlOBeZQQYbYS6WxSbIA&amp;state=dfDFjmlFV6PGF1963</span><br></pre></td></tr></table></figure><ul><li>code：表示授权码，<strong>必选</strong></li><li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一摸一样包含这个参数</li></ul><p><strong>第4步中，客户端向认证服务器申请令牌的HTTP回复，包含以下此参数：</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST http://oauth.com/token?grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb&amp;client_id=111111&amp;client_secret=22222</span><br></pre></td></tr></table></figure><ul><li>access_token：表示访问令牌。<strong>必选</strong></li><li>token_type：表示令牌类型，大小写不敏感，可以是bearer类型或者mac类型。<strong>必选</strong></li><li>expires_in：表示过期时间，单位为秒。<strong>如果省略该参数，必须通过其他方式设置过期时间</strong></li><li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，<strong>可选</strong></li><li>scope：表示权限范围，<strong>如果客户端申请的范围一致，此项可省略</strong></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;2YotnFZFEjr1zCsicMWpAA&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;token_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;example&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;expires_in&quot;</span><span class="punctuation">:</span><span class="number">3600</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;refresh_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;example_parameter&quot;</span><span class="punctuation">:</span><span class="string">&quot;example_value&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="刷新令牌"><a href="#刷新令牌" class="headerlink" title="刷新令牌"></a>刷新令牌</h4><p>在得到访问令牌（access token），一般会提供一个过期时间和刷新令牌。以便在访问令牌过期失效的时候，可以由客户端获取新的访问令牌，而不是让用户再次登录授权。 如下刷新令牌的客户端需要提供给认证服务器（Authorization Server）的参数：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST http://oauth.com/token?grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA&amp;client_id=111111*client_secret=22222</span><br></pre></td></tr></table></figure><ul><li>grant_type：这里是”refresh_token”。<strong>必选</strong></li><li>refresh_token：客户端得到access token的同时得到的刷新令牌。<strong>必选</strong></li><li>scope：表示申请的授权范围，不可以超出上一次申请的范围。<strong>如果省略该参数，则表示与上一次一致</strong></li><li>client_id：表示客户端id，<strong>必选</strong></li><li>client_secret：表示客户端密钥，<strong>必选</strong></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2022/12/20/git/"/>
      <url>/2022/12/20/git/</url>
      
        <content type="html"><![CDATA[<h1 id="创建本地新仓库"><a href="#创建本地新仓库" class="headerlink" title="创建本地新仓库"></a>创建本地新仓库</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>创建本地仓库的条件是需要一个空目录，然后在空目录中初始化项目</p><ol><li><code>mkdir project</code> 创建名为project的目录</li><li><code>cd project</code> 进入目录</li><li><code>git init </code> 初始化当前仓库，会创建一个<code>.git</code> 的隐藏文件</li></ol><p><img src="/.com//git.png" alt="git"></p><h2 id="操作本地仓库"><a href="#操作本地仓库" class="headerlink" title="操作本地仓库"></a>操作本地仓库</h2><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status </span><br><span class="line"><span class="comment">#查看工作区的状态</span></span><br></pre></td></tr></table></figure><p>返回结果分为三个部分</p><ol><li>拟提交的变更：这是已经放入暂存区，准备使用 git commit 命令提交的变更</li><li>未暂存的变更：这是工作目录和暂存区快照之间存在差异的文件列表</li><li>未跟踪的文件：这类文件对于 Git 系统来说是未知的，也是可以被忽略的</li></ol><p><code>--ignore</code> 列出被忽略的文件</p><p><code>--short/-s</code> 简洁输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git diff file </span><br><span class="line"><span class="comment">#查看file进行了什么修改</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"><span class="comment">#查看commit 的历史记录</span></span><br><span class="line"></span><br><span class="line">git reflog</span><br><span class="line"><span class="comment">#查看有版本号的commit的历史记录</span></span><br></pre></td></tr></table></figure><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><ol><li><code>git add file/./-all</code> 将文件添加到暂存区</li><li><code>git commit -m &quot;meesage&quot;</code> 注释message把文件提交到本地仓库</li></ol><h2 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h2><p>!!!回退完成后要记得重新提交</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><ul><li>分支<ol><li>我们可以把<strong>分支</strong>看作<strong>是一条线段，</strong>上面刻画有每次<strong>事件发生时的时间标记。</strong></li><li><strong>git可以有很多分支。</strong>不仅包括master分支，而且还可以包括任何你想要的分支<strong>。</strong></li><li><strong>以树比喻，</strong>可以把<strong>master</strong>看作<strong>是</strong>本地的必须存在的<strong>主干或者主分支，其他分支</strong>可以看作是master的<strong>分支或者分枝，</strong>但<strong>其他分支</strong>最终都会<strong>合并至master分支</strong></li></ol></li><li>当前分支<ol><li>我们可以把<strong>分支</strong>看作<strong>是一条线段，</strong>上面刻画有每次<strong>事件发生时的时间标记。</strong></li><li><strong>git可以有很多分支。</strong>不仅包括master分支，而且还可以包括任何你想要的分支<strong>。</strong></li><li><strong>以树比喻，</strong>可以把<strong>master</strong>看作<strong>是</strong>本地的必须存在的<strong>主干或者主分支，其他分支</strong>可以看作是master的<strong>分支或者分枝，</strong>但<strong>其他分支</strong>最终都会<strong>合并至master分支</strong></li></ol></li><li>分支变化<ol><li>执行git commit命令<strong>，</strong>HEAD指向<strong>当前分支（不一定是master分支）最近一次提交commit后的时间标记点</strong></li><li>执行git reset命令<strong>，</strong>HEAD指向<strong>reset命令后的</strong>事件的时间标记点</li><li>git commit命令，<strong>可以更改</strong>（准确地说，是通过添加新的时间标记点来增长）当前分支线，同时使<strong>HEAD指向当前分支线上最新的时间标记点</strong></li><li>git reset命令<strong>，</strong>可以使HEAD重新指向<strong>当前分支线上的某个时间标记点，同时更改（</strong>准确地说，是<strong>缩短</strong>或者<strong>回退）当前分支线，</strong>并<strong>同时更新工作区内</strong>容为相应的版本</li></ol></li></ul><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p><strong>两种用法</strong></p><p><strong>用法一：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset [-q] [&lt;commit&gt;] [--] &lt;path&gt;</span><br><span class="line"><span class="comment">#用指定的commit所指向的目录树中的path路径下文件替换暂存区中的文件</span></span><br></pre></td></tr></table></figure><p>相当于git add 的逆向操作</p><p>使用git log <path></path> 可以查看可以回滚的版本</p><p><strong>用法二：</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset [--soft|--hard|--mixed|--merge|--keep] [-q] [&lt;commit&gt;]</span><br></pre></td></tr></table></figure><p>这时git reset执行三个操作：</p><ol><li>将HEAD指针移动到指定的ID上</li><li>替换暂存区。替换后，暂存区和引用指向的目录树一致</li><li>替换工作区。替换后，替换后，工作区与暂存区相同</li></ol><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>soft</td><td>进行操作1</td></tr><tr><td>mixed</td><td>进行操作1、2</td></tr><tr><td>hard</td><td>进行操作1、2、3</td></tr></tbody></table><h3 id="git-checkout-–file"><a href="#git-checkout-–file" class="headerlink" title="git checkout –file"></a>git checkout –file</h3><p>该指令可以将文件恢复到上一次提交的状态。</p><p>不能迭代回复，只能回滚一个版本。</p><h1 id="操作远程仓库"><a href="#操作远程仓库" class="headerlink" title="操作远程仓库"></a>操作远程仓库</h1><p>在本地仓库中使用<code>git remote</code>查看该本地仓库链接的远程仓库</p><p><strong>本地仓库向远程仓库推送</strong></p><ol><li><code>git remote add &lt;指定远程库名&gt; &lt;github上的仓库链接&gt;</code> 添加远程仓库</li><li><code>git push -u &lt;远程库名&gt; master</code>  Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令</li><li>现在只要本地提交了，就可以通过<code>git push &lt;远程库名&gt; master</code> 推送到Github上了</li></ol><p><strong>从远程仓库克隆一个本地仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;github上的仓库地址&gt;</span><br></pre></td></tr></table></figure><h1 id="分支-1"><a href="#分支-1" class="headerlink" title="分支"></a>分支</h1><p><strong>创建分支</strong></p><ol><li><code>git branch &lt;分支名&gt;</code>创建分支</li><li><code>git checkout [-b] &lt;分支名&gt; 切换到指定的分支 -b 表示创建并切换</code></li><li><code>git branch</code> 查看所有的分支</li></ol><p><strong>合并分支</strong></p><p>通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，可以使用参数 –no-ff来禁用”Fast forward”模式。</p><p>可以使用-m参数添加注释。</p><ol><li><code>git checkout master </code> 切换到master分支</li><li><code>git merge &lt;要合并的分支&gt; 将指定的分支和master分支合并</code></li></ol><p><strong>删除分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;要删除的分支&gt;</span><br></pre></td></tr></table></figure><p>一般操作：</p><ol><li>拉取远程仓库</li><li>创建自己的分支</li><li>切换到自己的分支,merge合并主分支进行代码修改</li><li>add到缓存区</li><li>切换到主分支</li><li>commit提交，pull以下看看要不要合并</li><li>push推送到远程仓库</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2022/12/20/Docker/"/>
      <url>/2022/12/20/Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看docker 详细信息,镜像和容器</span></span><br><span class="line">docker info </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看docker版本</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><h3 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">登入docker hub</span></span><br><span class="line">docker login</span><br><span class="line">docker logou</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拉取镜像</span></span><br><span class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">搜索镜像</span></span><br><span class="line">docker search [OPTIONS]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">推送一个image到库</span></span><br><span class="line">docker push [OPTIONS] NAME[:TAG]</span><br></pre></td></tr></table></figure><h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出本地镜像</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.repository 镜像仓库源 2.tag 镜像的标签 3.image <span class="built_in">id</span> 镜像<span class="built_in">id</span> 4.created 创建时间 5.size 大小</span></span><br><span class="line">docker images [OPTIONS]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除镜像,不同镜像间以空格间隔</span></span><br><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除全部镜像</span></span><br><span class="line">docker rmi -f $(docker images -qa)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">保存镜像,将image保存为tar压缩文件，方便镜像转移</span></span><br><span class="line">docker save -o &lt;保存路径/文件名.tar&gt; IMAGE [IMAGE...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">加载镜像保存文件(.tar)，使其回复成image</span></span><br><span class="line">docker load -i &lt;.tar文件的路径&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看镜像/容器/数据卷所占的空间</span></span><br><span class="line">docker system df</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">提交一个镜像</span></span><br><span class="line">docker commit -m&quot;提交信息&quot; -a=&quot;作者信息&quot;  &lt;容器id/容器名&gt; &lt;提交后的镜像名&gt;[:tag] </span><br></pre></td></tr></table></figure><h3 id="镜像标签"><a href="#镜像标签" class="headerlink" title="镜像标签"></a>镜像标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">给image添加标签,若省略tag,则默认为latest,也可指定路径</span></span><br><span class="line">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</span><br></pre></td></tr></table></figure><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="容器信息"><a href="#容器信息" class="headerlink" title="容器信息"></a>容器信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看运行容器列表</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看所有容器</span></span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建并启动一个容器</span></span><br><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><ul><li><code>-i</code>  表示与容器进行交互式启动，通常和<code>-t</code>搭配使用</li><li><code>-d</code> 表示可后台运行（守护式运行）</li><li><code>-t</code> 分配一个伪tty</li><li><code>--name</code> 命名容器</li><li><code>/bin/bash</code> 交互路径（未指定时，有的镜像是默认是以<code>bash shell</code>进行输入，有的不是，比如<code>python</code>默认是python，<code>redis</code>默认是<code>redis-server</code>）</li><li><code>-p&lt;宿主机端口&gt;:&lt;容器端口&gt;</code> 指定端口映射 <code>-P</code> 随机端口映射</li><li><code>-d</code> 后台运行容器，并返回容器id</li><li><code>-v</code> 挂载一个卷 -v 宿主机文件存储位置:容器内文件位置 -v 宿主机文件存储位置:容器内文件位置 -v 宿主机文件存储位置:容器内文件位置</li></ul><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">exec</span></span></span><br><span class="line">docker exec -it &lt;容器id/容器名&gt; [shell]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.未设置后台运行时，<span class="built_in">exit</span>退出，容器停止</span></span><br><span class="line">exit</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.Ctrl+p+q退出，容器不停止</span></span><br><span class="line">ctrl+p+q</span><br></pre></td></tr></table></figure><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看容器日志</span></span><br><span class="line">docker logs [OPTIONS] &lt;容器id&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止容器</span></span><br><span class="line">docker stop &lt;容器id&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动已经停止的容器</span></span><br><span class="line">docker start &lt;容器id&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启容器</span></span><br><span class="line">docker restart &lt;容器id&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看容器内运行的进程</span></span><br><span class="line">docker top &lt;容器id&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看容器内部细节</span></span><br><span class="line">docker inspect &lt;容器id&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">更改容器名</span></span><br><span class="line">docker rename &lt;容器id/容器名&gt; &lt;新容器名&gt;</span><br></pre></td></tr></table></figure><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2022/12/20/Redis/"/>
      <url>/2022/12/20/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="一般"><a href="#一般" class="headerlink" title="一般"></a>一般</h2><h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><p><strong><code>set</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value [EX seconds|PX milliseconds|EXAT timestamp|PXAT milliseconds-timestamp|KEEPTTL] [NX|XX] [GET]</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">EX</th><th>表明过期时间，单位是秒 和 <strong>setex</strong> 相同</th></tr></thead><tbody><tr><td align="center"><strong>PX</strong></td><td><strong>单位毫秒</strong></td></tr><tr><td align="center"><strong>EXAT</strong></td><td><strong>设置时间到某个时间戳（秒级）</strong></td></tr><tr><td align="center"><strong>PXAT</strong></td><td><strong>设置时间到某个时间戳（毫秒级）</strong></td></tr><tr><td align="center"><strong>NX</strong></td><td><strong>当键k不存在时，设置键；设置成功返回ok，不成功时返回nil；和SETNX等价</strong></td></tr><tr><td align="center"><strong>XX</strong></td><td><strong>与NX相反只在键已经存在时， 才对键进行设置操作</strong></td></tr><tr><td align="center"><strong>GET</strong></td><td><strong>返回之前设的值</strong></td></tr></tbody></table><p><strong><code>ttl</code></strong></p><p>查看Key的过期时间(ms) -1是永久 -2是没有这个值</p><p><strong><code>SETEX</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setex key seconds value</span><br></pre></td></tr></table></figure><p>和 set key value ex 一样</p><p>**<code>PSETEX</code>**同理</p><p><strong><code>MSET</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSET key value [key value ...]</span><br></pre></td></tr></table></figure><p>同时设置多个键值对 返回OK</p><p><strong><code>MGET</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MGET key [key key ....]</span><br></pre></td></tr></table></figure><p>同时获取多个值</p><p><strong><code>MSETNX</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msetnx key value [key value ...]</span><br></pre></td></tr></table></figure><p>批量设置键值对，当所有key都不存在时返回1，否则返回0</p><p><strong><code>GETEX</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETEX key [EX seconds|PX milliseconds|EXAT timestamp|PXAT milliseconds-timestamp|PERSIST]</span><br></pre></td></tr></table></figure><ul><li><p>用于获取k的值，并设置或者移除过期时间，参数类似于set</p></li><li><p>PERSIST移除k的过期时间</p></li><li><p>EX,PX,EXAT,PXAT 和set的相同</p></li></ul><p><strong><code>GETSET</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getset key value</span><br></pre></td></tr></table></figure><p>获取原来的值并设置一个新的值</p><p><strong><code>GETRANGE</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getrange key start end</span><br></pre></td></tr></table></figure><p>截取值的字符串，下标从0开始</p><p><strong><code>SETRANGE</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setrange key offset value</span><br></pre></td></tr></table></figure><p>setrange 用value从偏移量（offset）开始(<strong>包括offset</strong>)，覆盖key的值</p><p><strong><code>STRLEN</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen key</span><br></pre></td></tr></table></figure><p>strlen key 返回键key存储的值的长度，<strong>不存在的k返回0</strong></p><p><strong><code>APPEND</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">append key value</span><br></pre></td></tr></table></figure><p>在值的末尾添加字符串</p><p><strong><code>DEL</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure><p>删除键值对</p><h3 id="数量相关"><a href="#数量相关" class="headerlink" title="数量相关"></a>数量相关</h3><h4 id="加"><a href="#加" class="headerlink" title="加"></a>加</h4><p><strong><code>INCR</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incr key</span><br></pre></td></tr></table></figure><p>incr 对key的值加1，并返回加1后的结果；如果k的值是字符串，无法加1，则提示错误</p><p><strong><code>INCRBY</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incrby key increment</span><br></pre></td></tr></table></figure><p>类似 INCR,只不过可以设置任意数</p><p><strong><code>INCRBYFLOAT</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incrbyfloat key increment</span><br></pre></td></tr></table></figure><p>增加浮点值或者加整型值</p><h4 id="减"><a href="#减" class="headerlink" title="减"></a>减</h4><p><strong><code>DECR</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decr key</span><br></pre></td></tr></table></figure><p><strong><code>DECRBY</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decrby key decrement</span><br></pre></td></tr></table></figure><p>操作类似于<code>incr</code>和<code>incrby</code></p><h3 id="set缓存对象"><a href="#set缓存对象" class="headerlink" title="set缓存对象"></a>set缓存对象</h3><ul><li><p>直接缓存整个对象的 JSON </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET user:1 &#x27;&#123;&quot;name&quot;:&quot;wxgg&quot;, &quot;age&quot;:18&#125;&#x27;</span><br></pre></td></tr></table></figure></li><li><p>采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSET user:1:name lwj user:1:age 18 user:2:name tzm user:2:age 18</span><br></pre></td></tr></table></figure></li></ul><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>Hash 是一个键值对（key - value）集合</p><p>其中 value 的形式 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value=[&#123;field1，value1&#125;，...&#123;fieldN，valueN&#125;]</span><br></pre></td></tr></table></figure><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><p>Hash 类型的底层数据结构是由**压缩列表（ziplist)或哈希表(hashlist)**实现的：</p><ul><li>如果哈希类型元素个数小于 <strong>512</strong> 个（默认值，可由 <code>hash-max-ziplist-entries</code> 配置），所有值小于 <strong>64</strong>字节（默认值，可由 <code>hash-max-ziplist-value</code> 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构</li><li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的 底层数据结构</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong></p><h3 id="基本指令-1"><a href="#基本指令-1" class="headerlink" title="基本指令"></a>基本指令</h3><p><strong><code>HSET</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hset key field value</span><br></pre></td></tr></table></figure><p>一个key的值可以有多个 field但一个 field只能有一个 value ，类似于go中的map</p><p><strong><code>HSETNX</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hsetnx key field value</span><br></pre></td></tr></table></figure><p>当指定的字段不存在时才会被设置</p><p><strong><code>HSET/HMSET</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hset/hmset key field value [field value ...]</span><br></pre></td></tr></table></figure><p>hset&#x2F;hmset都可以设置一个哈希的多个字段的值</p><p><strong><code>HGET</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hget key field</span><br></pre></td></tr></table></figure><p>获取一个哈希的一个字段的值</p><p><strong><code>HMGET</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmget key field [field ...]</span><br></pre></td></tr></table></figure><p>获取一个哈希的多个字段的值</p><p><strong><code>HGETALL</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hgetall key</span><br></pre></td></tr></table></figure><p>获取一个哈希所有字段的值,输出时依次轮流输出<code>field</code>和<code>value</code></p><p><strong><code>HKEYS</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hkeys key</span><br></pre></td></tr></table></figure><p>hvals key</p><p><strong><code>HVALS</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hvals key</span><br></pre></td></tr></table></figure><p>获取指定哈希的所有值，不获取字段名</p><p><strong><code>HEXIST</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexist key field</span><br></pre></td></tr></table></figure><p>判断字段是否存在于指定哈希中，存在返回<code>1</code>，不存在返回<code>0</code></p><p><strong><code>HLEN</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlen key</span><br></pre></td></tr></table></figure><p>获取指定哈希中字段的数量</p><p><strong><code>HSTRLEN</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hstrlen key field</span><br></pre></td></tr></table></figure><p>获取指定哈希中某个字段的长度</p><p><strong><code>HDEL</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdel key</span><br></pre></td></tr></table></figure><p>删除一个哈希</p><h3 id="数量相关-1"><a href="#数量相关-1" class="headerlink" title="数量相关"></a>数量相关</h3><p><strong><code>HINCRBY</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hincrby key field increment</span><br></pre></td></tr></table></figure><p>和 incryby类似 将指定哈希中的指定字段的值加一个指定的整型值</p><p><strong><code>HINCRBYFLOAT</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hincrbyfloat key field increment</span><br></pre></td></tr></table></figure><p>将指定哈希中的指定字段的值加一个指定的浮点型值 也可以加整型值</p><h3 id="用hash缓存对象"><a href="#用hash缓存对象" class="headerlink" title="用hash缓存对象"></a>用hash缓存对象</h3><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HSET uid:1 name lmj age 18</span><br><span class="line">HSET uid:2 name wx  age 18</span><br><span class="line">HSET uid:2 name yxh age 18</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>List 列表是简单的字符串列表，<strong>按照插入顺序排序</strong>，可以从头部或尾部向 List 列表添加元素。</p><p>列表的最大长度为 <strong>2^32 - 1</strong>，也即每个列表支持超过 <strong>40 亿</strong>个元素。</p><h3 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h3><p>List 类型的底层数据结构是由<strong>双向链表或压缩列表</strong>实现的：</p><ul><li>如果列表的元素个数小于 <strong>512</strong> 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 <strong>64</strong> 字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li><li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li></ul><p><strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist（快速表） 实现了，替代了双向链表和压缩列表</strong></p><h3 id="基本指令-2"><a href="#基本指令-2" class="headerlink" title="基本指令"></a>基本指令</h3><p><strong><code>LPUSH</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpush key element [element ...]</span><br></pre></td></tr></table></figure><p>当key存在但是却不是列表会返回错误</p><p><strong><code>LRANGE</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key start stop</span><br><span class="line">lrange gocybee 0 -1</span><br></pre></td></tr></table></figure><p>-1是倒数第一个 依次类推</p><p><strong><code>LPOP</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPOP key [count]</span><br></pre></td></tr></table></figure><p>移除列表key的表头元素，出队列 counts是出队次数</p><p><strong><code>RPOP</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPOP key [count]</span><br></pre></td></tr></table></figure><p>与LPOP类似，移除列表key的尾元素</p><p><strong><code>LSET</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lset key index element</span><br></pre></td></tr></table></figure><p>通过<strong>索引</strong>设置列表元素的值</p><p><strong><code>LLEN</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llen key</span><br></pre></td></tr></table></figure><p>获取列表长度</p><p><strong><code>BLPOP</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blpop key [key ...] timeout</span><br></pre></td></tr></table></figure><p>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</p><p><code>timeout</code>以秒做单位</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。</p><p>一个集合最多可以存储 <strong>2^32-1</strong>个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。</p><p>Set 类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、错集和并集等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储</p><p>Set 类型和 List 类型的区别如下：</p><ul><li>List 可以存储重复元素，Set 只能存储非重复元素</li><li>List 是按照元素的先后顺序存储元素的，而 Set 则是无序方式存储元素的</li></ul><h3 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a>内部实现</h3><p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p><ul><li>如果集合中的元素都是整数且元素个数小于 <strong>512</strong> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构</li><li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构</li></ul><h3 id="基本指令-3"><a href="#基本指令-3" class="headerlink" title="基本指令"></a>基本指令</h3><p><strong><code>SADD</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD key member [member ...]</span><br></pre></td></tr></table></figure><p>往集合key中存入元素，元素存在则忽略，若key不存在则新建</p><p><strong><code>SREM</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SREM key member [member ...]</span><br></pre></td></tr></table></figure><p>从集合key中删除元素</p><p><strong><code>SMEMBERS</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS key</span><br></pre></td></tr></table></figure><p>查看所有的members</p><p><strong><code>SCARD</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCARD key</span><br></pre></td></tr></table></figure><p>查看元素个数</p><p><strong><code>SISMEMBER</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER key member</span><br></pre></td></tr></table></figure><p>判断元素是否是在集合中</p><p><strong><code>SRANDMEMBER</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRANDMEMBER key [count]</span><br></pre></td></tr></table></figure><p>从集合key中随机选出count个元素，<strong>元素不从key中删除</strong></p><p><strong><code>SPOP</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPOP key [count]</span><br></pre></td></tr></table></figure><p>从集合key中随机选出count个元素，<strong>元素从key中删除</strong></p><h3 id="集合间运算"><a href="#集合间运算" class="headerlink" title="集合间运算"></a>集合间运算</h3><p><strong><code>SINTER</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTER key [key ...]</span><br></pre></td></tr></table></figure><p>交集运算返回两个set的交集</p><p><strong><code>SINTERSTORE</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line">SINTERSTORE common gocybee lanshan</span><br></pre></td></tr></table></figure><p>将交集结果存入新集合destination中</p><p><strong><code>SUNION</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNION gocybee lanshan</span><br></pre></td></tr></table></figure><p>并集运算</p><p><strong><code>SUNIONSTORE</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNIONSTORE destination key [key ...]</span><br></pre></td></tr></table></figure><p>将并集结果存入新集合destination中</p><p><strong><code>SDIFF</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIFF key [key ...]</span><br></pre></td></tr></table></figure><p>差集运算</p><p><strong><code>SDIFFSTORE</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIFFSTORE destination key [key ...]</span><br></pre></td></tr></table></figure><p>将差集结果存入新集合destination中</p><p>**潜在的风险:**Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞</p><p>在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h4><p>Set 类型可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章id，value 是用户id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SADD article:1 uid:1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SADD article:1 uid:2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SADD article:1 uid:3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SCARD article:1</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; SREM article:1 uid:1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SCARD article:1</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h4 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h4><p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</p><p>key 可以是用户id，value 则是已关注的公众号的id。</p><p><code>uid:1</code> 用户关注频道号 id 为 5、6、7、8、9，<code>uid:2</code> 用户关注 频道号id 为 7、8、9、10、11。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SADD uid:1 5 6 7 8 9</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; SADD uid:2 7 8 9 10 11</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure><h4 id="抽奖活动"><a href="#抽奖活动" class="headerlink" title="抽奖活动"></a>抽奖活动</h4><p>存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。</p><p>key为抽奖活动名，value为员工名称，把所有员工名称放入抽奖箱</p><p>再利用 <code>SRANDRM </code>（放回）或者是 <code>SPOP</code>（不放回）</p><h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><h3 id="内部实现-3"><a href="#内部实现-3" class="headerlink" title="内部实现"></a>内部实现</h3><p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p><ul><li>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构</li><li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong></p><h3 id="基本指令-4"><a href="#基本指令-4" class="headerlink" title="基本指令"></a>基本指令</h3><p><strong><code>ZADD</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD key score member [[score member]...]</span><br></pre></td></tr></table></figure><p>往有序集合key中加入带<strong>分值</strong>元素 ,score必须是<strong>浮点数</strong>或者<strong>整型</strong>，添加成功后返回被成功添加的新成员的数量</p><p><code>ZREM</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member [member...]</span><br></pre></td></tr></table></figure><p>往有序集合key中删除元素</p><p><code>ZSCORE</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCORE key member</span><br></pre></td></tr></table></figure><p>返回有序集合key中元素member的<strong>分值</strong></p><p><strong><code>ZCARD</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCARD key</span><br></pre></td></tr></table></figure><p>返回有序集合个数</p><p><strong><code>ZRANGE</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line">ZRANGE movie 0 -1</span><br></pre></td></tr></table></figure><p>正序获取有序集合key从start下标到stop下标的元素</p><p><strong><code>ZREVRANGE</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure><p>倒序获取有序集合key从start下标到stop下标的元素</p><p><strong><code>ZRANGENYSCORE</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br></pre></td></tr></table></figure><p>返回有序集合中指定分数区间内的成员，分数由<strong>低到高排序</strong></p><p><strong><code>ZREVRANGEBYSCORE</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</span><br></pre></td></tr></table></figure><p>返回有序集合中指定分数区间内的成员，分数由<strong>高到低排序</strong></p><p><strong><code>ZRANGEBYLEX</code></strong>(没啥用zrange就是按字典排的)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYLEX key min max [LIMIT offset count]</span><br></pre></td></tr></table></figure><p>返回指定成员区间内的成员，按字典正序排列, <strong>分数必须相同</strong></p><p><strong><code>ZREVRANGEBYLEX</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGEBYLEX key max min [LIMIT offset count]</span><br></pre></td></tr></table></figure><p>返回指定成员区间内的成员，按字典倒序排列, <strong>分数必须相同</strong></p><h3 id="数量相关-2"><a href="#数量相关-2" class="headerlink" title="数量相关"></a>数量相关</h3><p><strong><code>ZINCRBY</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY key increment member</span><br></pre></td></tr></table></figure><p>为有序集合key中元素member的<strong>分值</strong>加上increment</p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>Zset 类型（Sorted Set，有序集合） 可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值</p><p>在面对需要<strong>展示最新列表</strong>、<strong>排行榜</strong>等场景时，如果<strong>数据更新频繁</strong>或者<strong>需要分页显示</strong>，可以优先考虑使用 <strong>Sorted Set</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql</title>
      <link href="/2022/12/20/MySQL/"/>
      <url>/2022/12/20/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><table><thead><tr><th align="center">操作</th><th align="center">命令</th></tr></thead><tbody><tr><td align="center">增</td><td align="center">insert</td></tr><tr><td align="center">删</td><td align="center">delete&#x2F;drop</td></tr><tr><td align="center">改</td><td align="center">update&#x2F;alter</td></tr><tr><td align="center">查</td><td align="center">select&#x2F;show</td></tr></tbody></table><h2 id="库操作"><a href="#库操作" class="headerlink" title="库操作"></a>库操作</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p><strong>创建数据库</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database name;</span><br></pre></td></tr></table></figure><p><del><strong>创建带字符集的数据库</strong></del></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database name CHARACTER SET =utf8;</span><br></pre></td></tr></table></figure><p><del><strong>创建带校验的数据库</strong></del></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database name CHARACTER SET =utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></table></figure><h3 id="显示数据库"><a href="#显示数据库" class="headerlink" title="显示数据库"></a><strong>显示数据库</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a><strong>删除数据库</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database name;</span><br></pre></td></tr></table></figure><h3 id="修改数据库编码"><a href="#修改数据库编码" class="headerlink" title="修改数据库编码"></a><del><strong>修改数据库编码</strong></del></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database name character set gb2312;</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><table><thead><tr><th align="center">类型</th><th>字节大小</th></tr></thead><tbody><tr><td align="center">TINIY</td><td>1</td></tr><tr><td align="center">SMALLINT</td><td>2</td></tr><tr><td align="center">MEDIUMINT</td><td>3</td></tr><tr><td align="center">INT(INTEGER)</td><td>4</td></tr><tr><td align="center">BIGINT</td><td>8</td></tr><tr><td align="center">FLOAT</td><td>4</td></tr><tr><td align="center">DOUBLE</td><td>8</td></tr><tr><td align="center">DECIMAL(小数)</td><td>对DECIMAL(M,D)中 M&gt;D 则为M+2，否则为D+2</td></tr></tbody></table><h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><table><thead><tr><th>类型</th><th>字节大小</th><th>格式形式</th><th>用途</th></tr></thead><tbody><tr><td>DATE</td><td>3</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期值和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期值和时间值和时间戳</td></tr></tbody></table><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><table><thead><tr><th>类型</th><th>字节大小</th><th>用途</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255</td><td>定长字符串</td></tr><tr><td>VARCHAR</td><td>0-65535</td><td>变长字符串</td></tr><tr><td>TINYBLOB</td><td>0-255</td><td>&lt;&#x3D;255个字符的二进制字符串</td></tr><tr><td>TINYTEXT</td><td>0-255</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65535</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65535</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16777215</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16777215</td><td>中等长度的文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4294967295</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4294967295</td><td>极大文本数据</td></tr></tbody></table><h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><p>&#x2F;&#x2F;首先都要进入数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use name;</span><br></pre></td></tr></table></figure><h3 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure><h3 id="查看表的信息"><a href="#查看表的信息" class="headerlink" title="查看表的信息"></a>查看表的信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc name;</span><br></pre></td></tr></table></figure><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table name(字段列表);</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user` (</span><br><span class="line">`id` BIGINT(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">`name` VARCHAR(60) DEFAULT &#x27;&#x27;,</span><br><span class="line">`account`VARCHAR(60)NOT NULL,</span><br><span class="line">`password` VARCHAR(60) NOT NULL,</span><br><span class="line">`question` varchar(60) default &#x27;&#x27;,</span><br><span class="line">`answer` varchar(60) default &#x27;&#x27;,</span><br><span class="line">PRIMARY KEY(`id`)</span><br><span class="line">)ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table name;</span><br></pre></td></tr></table></figure><h3 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table &lt;旧表名&gt; rename &lt;新表名&gt;;</span><br></pre></td></tr></table></figure><h2 id="列操作"><a href="#列操作" class="headerlink" title="列操作"></a>列操作</h2><h3 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table name add &lt;列名&gt; &lt;类型&gt;;</span><br></pre></td></tr></table></figure><h3 id="修改列"><a href="#修改列" class="headerlink" title="修改列"></a>修改列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table name change drop column &lt;列名&gt;;</span><br></pre></td></tr></table></figure><h3 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table tablename drop column &lt;列名&gt;;</span><br></pre></td></tr></table></figure><h2 id="DML数据处理语言"><a href="#DML数据处理语言" class="headerlink" title="DML数据处理语言"></a>DML数据处理语言</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into tablename values(值,.,.,.,);</span><br><span class="line">insert into tablename (列名,...) values (值,.,.,,.);</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from tablename [where&lt;表达式&gt;](不带where语句表示全部删除)</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tablename set &lt;字段&gt;=&lt;值&gt;[,&lt;字段&gt;=&lt;值&gt;...][where&lt;表达式&gt;]</span><br></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="*查询"></a>*查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from tablename;//查询所有</span><br><span class="line">select &lt;字段&gt;[,&lt;字段&gt;...] from tablename;//查找指定字段</span><br><span class="line">select distinct [&lt;字段&gt;...或者*] from tablename;//查找不重复记录</span><br></pre></td></tr></table></figure><h3 id="where子句运算符"><a href="#where子句运算符" class="headerlink" title="where子句运算符"></a>where子句运算符</h3><table><thead><tr><th align="center">运算符</th><th>描述</th></tr></thead><tbody><tr><td align="center">&#x3D;</td><td>等于</td></tr><tr><td align="center">&lt;&gt;</td><td>不等于</td></tr><tr><td align="center">&gt;(&lt;)</td><td>大于（小于）</td></tr><tr><td align="center">&gt;&#x3D;(&lt;&#x3D;)</td><td>大于等于（小于等于）</td></tr><tr><td align="center">BETWEEN</td><td>在某个范围内</td></tr><tr><td align="center">LIKE</td><td>搜索某种模式</td></tr><tr><td align="center">IN</td><td>指定针对某个列的多个可能值</td></tr></tbody></table><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><strong>And</strong>: 与 同时满足两个条件的值<br><strong>Or</strong>: 或 满足其中一个条件的值<br><strong>Not</strong>: 非 满足不包含该条件的值</p><h3 id="ODER-BY关键字"><a href="#ODER-BY关键字" class="headerlink" title="ODER BY关键字"></a>ODER BY关键字</h3><p>oder by &lt;列名…&gt; 按照列名升序排序</p><p>oder by &lt;列名…&gt; 按照列名降序排序</p><h3 id="SQL函数"><a href="#SQL函数" class="headerlink" title="SQL函数"></a>SQL函数</h3><p>AVG() 返回平均值</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux操作</title>
      <link href="/2022/12/20/Linux/"/>
      <url>/2022/12/20/Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="文件操作操作"><a href="#文件操作操作" class="headerlink" title="文件操作操作"></a>文件操作操作</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd 查看当前工作目录</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd 改变目录</span><br></pre></td></tr></table></figure><ul><li><code>cd ..</code> 返回上级目录</li><li><code>cd /.../...</code>  跳转到绝对路径下的目录</li><li><code>cd .../.../... </code>跳转到相对路径下的目录</li><li><code>cd /</code> 跳转到根目录</li><li><code>cd ~</code>跳转到当前用户目录</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file 在当前目录下创建文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mk 创建目录或文件</span><br></pre></td></tr></table></figure><ul><li><code>mkdir name </code> 在当前目录下创建目录，相对路径</li><li><code>mkdir ./name</code> 同上</li><li><code>mkdir /.../name</code> 创建目录，绝对路径</li><li><code>mkdir -p file1/file2/file3</code>递归创建目录</li><li><code>mk name</code> 创建<code>name</code>文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &lt;字符串&gt; &gt;&gt; &lt;文件名&gt; 输入字符串</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls 查看当前目录下的文件</span><br></pre></td></tr></table></figure><ul><li><code>ls -l</code> 查看详细 相当于 <code>ll</code></li><li><code>ls -a</code> 查看全部包括隐藏文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> 删除目录或文件</span><br></pre></td></tr></table></figure><ul><li><code>rmdir path</code>删除目录</li><li><code>rm -f </code> 忽略不存在的文件，不会出现警告，强制删除</li><li><code>rm -r</code> 递归删除</li><li><code>rm -l</code>删除询问是否删除 </li><li><code>rm -rf dir/</code> 删除目录</li><li><code>rmdir dir_name</code> 删除空目录</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv src dest 移动文件或目录（也可以用来重命名文件）</span><br></pre></td></tr></table></figure><ul><li><code>mv -f</code> 强制移动</li><li><code>mv file file1</code>  将<code>file</code>文件重命名为<code>file1</code></li><li><code>mv -u</code> 只替换已经更新过的文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp src dest 拷贝文件</span><br></pre></td></tr></table></figure><p> <code>cp -r </code> 递归复制文件</p><h1 id="文件属性查看和修改"><a href="#文件属性查看和修改" class="headerlink" title="文件属性查看和修改"></a>文件属性查看和修改</h1><p>第一个字符代表这个文件是目录、文件或链接文件:</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>d</td><td>目录</td></tr><tr><td>-</td><td>文件</td></tr><tr><td>l</td><td>链接文档（快捷方式）</td></tr><tr><td>b</td><td>装置文件里可供储存的接口设备</td></tr><tr><td>c</td><td>装置文件里的串行端口设备，如键盘、鼠标</td></tr></tbody></table><p>接下来的字符以三个为一组，且均为<code>rwx</code>三个参数的组合</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>r</td><td>可读</td></tr><tr><td>w</td><td>可写</td></tr><tr><td>x</td><td>可执行</td></tr><tr><td>-</td><td>没有权限</td></tr></tbody></table><p>1、2、3代表<strong>属主</strong>的读、写、执行权限</p><p>4、5、6代表<strong>属组</strong>的读、写、执行权限</p><p>7、8、9代表<strong>其他用户</strong>的读、写、执行权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-r] 属组名 文件名</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown [-r] 属主名 文件名</span><br><span class="line">chown [-r] 属主名:属组名 文件名 </span><br></pre></td></tr></table></figure><p><code>-r</code> 表示递归</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-r] xyz 文件名或者目录</span><br></pre></td></tr></table></figure><p>Linux文件属性有两种设置方法 一种是数字，一种是符号</p><h2 id="1-数字设置"><a href="#1-数字设置" class="headerlink" title="1.数字设置"></a>1.数字设置</h2><p>r: 4  w: 2  x: 1</p><p>每种身份(owner&#x2F;group&#x2F;others)各自的权限(read&#x2F;write&#x2F;execute)的权限是需要累加的</p><p>例如当权限为 <code>rwxrwxrwx</code> 时对应的分数是777</p><h2 id="2-符号设置"><a href="#2-符号设置" class="headerlink" title="2.符号设置"></a>2.符号设置</h2><p>u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是</p><p>+ 表示增加权限、- 表示取消权限、&#x3D; 表示唯一设定权限</p><p>r 表示可读取，w 表示可写入，x 表示可执行</p><p>如将文件<code>file1.txt</code>设置为所有人皆可读取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ugo+r file1.txt </span><br></pre></td></tr></table></figure><h1 id="文件内容查看"><a href="#文件内容查看" class="headerlink" title="文件内容查看"></a>文件内容查看</h1><ul><li><code>cat</code> 由第一行开始显示文件内容</li><li><code>tac</code> 从最后一行开始显示文件内容</li><li><code>nl</code> 显示的时候输出行号</li><li><code>more</code> 分页显示文件内容,空格键翻页，回车键换行，:f显示行号,按下q退出</li><li><code>less</code> 与 more 类似，可以往前翻页，空格表示下翻页，Pg Up&#x2F;Pg Down翻动页面，按下q退出,&#x2F;查询字符串（向下查询），?向上查询,小写n往下大写N往上</li><li><code>head</code> 只看头行</li><li><code>tail</code> 只看末行</li></ul><h1 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h1><p><strong>硬链接:<strong>硬链接即让多个不在或者同在一个目录下的文件名，同时能够修改同一个文件，其中一个修改后，所有与其有硬链接的文件都一起修改了。</strong>硬链接源文件删除后链接文件还存在</strong></p><p><strong>软链接：</strong>软链接也称之为符号链接（Symbolic Link）。这个文件包含了另一个文件的路径名。可以是任意文件或目录，可以链接不同文件系统的文件。软链接类似于 Windows的快捷方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln 创建链接</span><br></pre></td></tr></table></figure><p><code>ln 链接文件名 文件名</code> 创建硬链接</p><p><code>ln -s 链接文件名 文件名</code> 创建软链接</p><h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><ul><li><strong>i</strong> 进入输入模式</li><li><strong>x</strong> 删除光标所在处的字符</li><li><strong>:</strong> 进入底线命令模式</li></ul><table><thead><tr><th>i, I</th><th>进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。(常用)</th></tr></thead><tbody><tr><td>a, A</td><td>进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td>o, O</td><td>进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！(常用)</td></tr><tr><td>r, R</td><td>进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td>[Esc]</td><td></td></tr></tbody></table><table><thead><tr><th align="left">移动光标的方法</th><th></th></tr></thead><tbody><tr><td align="left">h 或 向左箭头键(←)</td><td>光标向左移动一个字符</td></tr><tr><td align="left">j 或 向下箭头键(↓)</td><td>光标向下移动一个字符</td></tr><tr><td align="left">k 或 向上箭头键(↑)</td><td>光标向上移动一个字符</td></tr><tr><td align="left">l 或 向右箭头键(→)</td><td>光标向右移动一个字符</td></tr><tr><td align="left">[Ctrl] + [f]</td><td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="left">[Ctrl] + [b]</td><td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="left">[Ctrl] + [d]</td><td>屏幕『向下』移动半页</td></tr><tr><td align="left">[Ctrl] + [u]</td><td>屏幕『向上』移动半页</td></tr><tr><td align="left">+</td><td>光标移动到非空格符的下一行</td></tr><tr><td align="left">-</td><td>光标移动到非空格符的上一行</td></tr><tr><td align="left">n&lt; space&gt;</td><td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。</td></tr><tr><td align="left">0 或功能键[Home]</td><td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="left">$ 或功能键[End]</td><td>移动到这一行的最后面字符处(常用)</td></tr><tr><td align="left">H</td><td>光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="left">M</td><td>光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="left">L</td><td>光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="left">G</td><td>移动到这个档案的最后一行(常用)</td></tr><tr><td align="left">nG</td><td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="left">gg</td><td>移动到这个档案的第一行，相当于 1G 啊！(常用)</td></tr><tr><td align="left">n&lt; Enter&gt;</td><td>n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><table><thead><tr><th align="left">搜索替换</th><th></th></tr></thead><tbody><tr><td align="left">&#x2F;word</td><td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！(常用)</td></tr><tr><td align="left">?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="left">n</td><td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="left">N</td><td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr></tbody></table><table><thead><tr><th align="left">删除、复制与粘贴</th><th></th></tr></thead><tbody><tr><td align="left">x, X</td><td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="left">nx</td><td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="left">dd</td><td>删除游标所在的那一整行(常用)</td></tr><tr><td align="left">ndd</td><td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</td></tr><tr><td align="left">d1G</td><td>删除光标所在到第一行的所有数据</td></tr><tr><td align="left">dG</td><td>删除光标所在到最后一行的所有数据</td></tr><tr><td align="left">d$</td><td>删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="left">d0</td><td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="left">yy</td><td>复制游标所在的那一行(常用)</td></tr><tr><td align="left">nyy</td><td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="left">y1G</td><td>复制游标所在行到第一行的所有数据</td></tr><tr><td align="left">yG</td><td>复制游标所在行到最后一行的所有数据</td></tr><tr><td align="left">y0</td><td>复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="left">y$</td><td>复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="left">p, P</td><td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用)</td></tr><tr><td align="left">J</td><td>将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="left">c</td><td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="left">u</td><td>复原前一个动作。(常用)</td></tr><tr><td align="left">[Ctrl]+r</td><td></td></tr></tbody></table><h2 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h2><ul><li><strong>字符按键以及Shift组合</strong>，输入字符</li><li><strong>ENTER</strong>，回车键，换行</li><li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li><li><strong>DEL</strong>，删除键，删除光标后一个字符</li><li><strong>方向键</strong>，在文本中移动光标</li><li><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</li><li><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</li><li><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</li><li><strong>ESC</strong>，退出输入模式，切换到命令模式</li></ul><h2 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h2><table><thead><tr><th align="left">指令行的储存、离开等指令</th><th></th></tr></thead><tbody><tr><td align="left">:w</td><td>将编辑的数据写入硬盘档案中(常用)</td></tr><tr><td align="left">:w!</td><td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关</td></tr><tr><td align="left">:q</td><td>离开 vi (常用)</td></tr><tr><td align="left">:q!</td><td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td></tr><tr><td align="left">:wq</td><td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td></tr><tr><td align="left">ZZ</td><td>这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</td></tr><tr><td align="left">:w [filename]</td><td>将编辑的数据储存成另一个档案（类似另存新档）</td></tr><tr><td align="left">:r [filename]</td><td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td></tr><tr><td align="left">:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr><tr><td align="left">:! command</td><td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls &#x2F;home』即可在 vi 当中看 &#x2F;home 底下以 ls 输出的档案信息！</td></tr><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号</td></tr></tbody></table><h1 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h1><p>用户信息都保存在etc文件夹中如 &#x2F;etc&#x2F;passwd &#x2F;etc&#x2F;group &#x2F;etc&#x2F;shadow</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd username 创建用户</span><br></pre></td></tr></table></figure><p><code>useradd -m username </code>创建用户，自动创建这个用户的目录录&#x2F;home&#x2F;username</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel username 删除用户</span><br></pre></td></tr></table></figure><p><code>userdel -r username</code> 删除用户和其目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod [OPTIONS] usernmae 修改用户</span><br></pre></td></tr></table></figure><p>常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值</p><p>[用户名@主机名 目录]#($) </p><p>$表示普通用户</p><p>#表示超级用户，也就是root用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd [OPTIONS] username 修改用户密码</span><br></pre></td></tr></table></figure><ul><li>-l 锁定口令，即禁用账号。</li><li>-u 口令解锁。</li><li>-d 使账号无口令。</li><li>-f 强迫用户下次登录时修改口令。</li></ul><p>&#x2F;etc&#x2F;group</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名:口令(登录密码，不可见):用户<span class="built_in">id</span>:组<span class="built_in">id</span>:注释:主目录:登录shell</span><br></pre></td></tr></table></figure><h1 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h1><p>本质都是对&#x2F;etc&#x2F;group文件的修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd 创建一个用户组</span><br><span class="line">groupdel 删除一个用户组</span><br></pre></td></tr></table></figure><p>创建用户组会指定一个id，这个id是可以指定的<code>-g id</code>，若不指定就是自增</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改用户的id或者名字</span></span><br><span class="line">group -g <span class="built_in">id</span> -n newname</span><br></pre></td></tr></table></figure><p>用户切换用户组</p><ol><li>登录用户</li><li>切换用户组 <code>newgrp  组名</code></li></ol><h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><h2 id="查看磁盘容量"><a href="#查看磁盘容量" class="headerlink" title="查看磁盘容量"></a>查看磁盘容量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df </span><br></pre></td></tr></table></figure><p><strong>默认情况下会将系统内所有的 (不含特殊内存内的文件系统与 swap) 都以 1 Kbytes 的容量来列出来</strong></p><ul><li><code>df -h</code> 将容量结果以易读的容量格式显示出来</li><li><code>df -aT</code> 将系统内的所有特殊文件格式及名称都列出来</li><li><code>df -h path </code> 将目录下的可用的磁盘容量以易读的容量格式显示</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du 对文件和目录磁盘使用的空间的查看</span><br></pre></td></tr></table></figure><ul><li>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</li><li>-h ：以人们较易读的容量格式 (G&#x2F;M) 显示；</li><li>-s ：列出总量而已，而不列出每个各别的目录占用容量；</li><li>-S ：不包括子目录下的总计，与 -s 有点差别。</li><li>-k ：以 KBytes 列出容量显示；</li><li>-m ：以 MBytes 列出容量显示；</li></ul><h2 id="磁盘的挂载与卸除"><a href="#磁盘的挂载与卸除" class="headerlink" title="磁盘的挂载与卸除"></a>磁盘的挂载与卸除</h2><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [-t 文件系统][-L label名][-o 额外选项][-n]装置文件名 挂载点</span><br></pre></td></tr></table></figure><h3 id="卸除"><a href="#卸除" class="headerlink" title="卸除"></a>卸除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount [-fn] 装置文件名或挂载点</span><br></pre></td></tr></table></figure><ul><li>-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；</li><li>-n ：不升级 &#x2F;etc&#x2F;mtab 情况下卸除。</li></ul><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><ul><li>Linux中每一个程序都有自己的一个进程，每一个进程都有一个id号</li><li>每一个进程都有一个父进程</li><li>进程有两种存在方式：1.前台 2.后台运行</li><li>一般的话服务都是在后台运行的，基本的程序都是前台运行</li></ul><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps 查看当前系统中正在执行的各种进程的信息</span><br></pre></td></tr></table></figure><ul><li><strong><code>ps -a</code></strong> 显示当前终端运行的所有的进程信息</li><li><strong><code>ps -u</code></strong> 以用户的信息显示进程</li><li><strong><code>ps -x</code></strong> 显示后台运行进程的参数</li><li><strong><code>ps -ef</code></strong> 显示父进程信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ps -aux 查看所有的进程</span></span><br><span class="line"><span class="comment">#查看mysql的进程</span></span><br><span class="line">ps -aux|grep mysql </span><br><span class="line"></span><br><span class="line"><span class="comment"># | 在Linux中叫做管道符</span></span><br><span class="line"><span class="comment">#grep 查找文件中符合条件的字符串</span></span><br></pre></td></tr></table></figure><h2 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pstree -pu</span><br><span class="line"><span class="comment">#p 显示父进程 u 显示用户组</span></span><br></pre></td></tr></table></figure><h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 PID</span><br><span class="line"><span class="comment">#强制结束进程</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
